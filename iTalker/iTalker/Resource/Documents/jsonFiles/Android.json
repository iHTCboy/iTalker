{"success":1,"total":210,"result":[
  {
    "ID" : "55bb36a7e4b0809382e39937",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "rowOrderPreserved",
    "optionC" : "columnOrderPreserved",
    "optionAnswer" : "C",
    "answer" : "android:columnOrderPreserved\n属性说明： 设置该网格布局是否保留列序号。默认是true。",
    "optionB" : "rowCount",
    "type" : "1",
    "optionA" : "columnCount",
    "question" : "下列是设置该网格布局是否保留列序号的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39928",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Service：服务，具有一段较长生命周期且有用户界面的程序",
    "optionC" : "content Provider：内容提供器，android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。",
    "optionAnswer" : "D",
    "answer" : "Service：服务，具有一段较长生命周期且没有用户界面的程序",
    "optionB" : "Broadcast Receiver：广播接收器，一个专注于接收广播通知信息，并做出对应处理的组件。应用程序可以拥有任意数量的广播接收器。没有用户界面。",
    "type" : "1",
    "optionA" : "Activity：活动，是最基本的android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。",
    "question" : "下列关于Android四大组件说法错误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39973",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "gen 目录中存放所有由Android开发工具自动生成的文件。目录中最重要的就是R.java文件。里面的内容我们也可以改变。",
    "optionC" : "res\/values 专门存放应用使用到的各种类型数据。不同类型的数据存放在不同的文件中",
    "optionAnswer" : "D",
    "answer" : "gen\/ 自动生成目录\ngen 目录中存放所有由Android开发工具自动生成的文件。目录中最重要的就是R.java文件。 这个文件由Android开发工具自动产生的。Android开发工具会自动根据你放入res目录的xml界面文件、图标与常量，同步更新修改 R.java文件。正因为R.java文件是由开发工具自动生成的，所以我们应避免手工修改R.java。R.java在应用中起到了字典的作用，它包含了界面、图标、常量等各种资源的id，通过R.java，应用可以很方便地找到对应资源。另外编绎器也会检查R.java列表中的资源是否被使用到，没有被使用到的资源不会编绎进软件中，这样可以减少应用在手机占用的空间。\nres\/drawable 专门存放png、jpg等图标文件。在代码中使用getResources().getDrawable(resourceId)获取该目录下的资源。\nres\/layout 专门存放xml界面文件，xml界面文件和HTML文件一样，主要用于显示用户操作界面。\nres\/values 专门存放应用使用到的各种类型数据。不同类型的数据存放在不同的文件中",
    "optionB" : "res\/layout 专门存放xml界面文件，xml界面文件和HTML文件一样，主要用于显示用户操作界面。",
    "type" : "1",
    "optionA" : "res\/drawable 专门存放png、jpg等图标文件。在代码中使用getResources().getDrawable(resourceId)获取该目录下的资源。",
    "question" : "Android应用程序架构（目录）说明有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39983",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "System.io.out System.io.in",
    "optionC" : "System.io.in System.io.out",
    "optionAnswer" : "A",
    "answer" : "输入：System.in;输出：System.out",
    "optionB" : "System.out System.in",
    "type" : "1",
    "optionA" : "System.in System.out",
    "question" : "一般用()创建InputStream对象,表示从标准输入中获取数据,用()创建OutputStream对象，表示输出到标准输出设备中。"
  },
  {
    "ID" : "55bb36a8e4b0809382e39981",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "bindService只能通过Activity()来调用unbindService()方法来结束Service，Service会调用onUnBind()方法，以及onDestroy()方法。",
    "optionC" : "StartService启动的Service,Activity中可以调用stopService()方法来结束一个Service，",
    "optionAnswer" : "A",
    "answer" : "1）StartService启动了Service之后无法与Activity之间进行通信，与现有的Activity分离，即使Activity被杀掉了之后，Service还可以运行，同时通过设置Service的粘性，还可以让Service被杀掉之后，可以自启动。而bindService启动Service之后，与绑定的Activity之间有关系，可以依据Server\/Client模式来进行通信(binder客户端主动请求模式，或者通过信使)，但是无法设置Serrvice的粘性。\n2) StartService启动的Service,Activity中可以调用stopService()方法来结束一个Service，或者通过Service自己调用stopSelf()方法来结束Service。而bindService只能通过Activity()来调用unbindService()方法来结束Service，Service会调用onUnBind()方法，以及onDestroy()方法。",
    "optionB" : "bindService启动Service之后，与绑定的Activity之间有关系，可以依据Server\/Client模式来进行通信(binder客户端主动请求模式，或者通过信使)，但是无法设置Serrvice的粘性。",
    "type" : "1",
    "optionA" : "StartService启动了Service之后无法与Activity之间进行通信，与现有的Activity分离，但是Activity被杀掉了之后，Service也会停止运行",
    "question" : "StartService与bindService之间的区别说法不正确的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39921",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "4、8",
    "optionC" : "4、4",
    "optionAnswer" : "D",
    "answer" : "java中int是占4个字节，long是占8个字节",
    "optionB" : "2、4",
    "type" : "1",
    "optionA" : "2、2",
    "question" : "java文件里面int跟long是占几个字节？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b1",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "模型层（ model ）： 对数据库的操作、对网络等的操作都应该在 model 里面处理，当然对业务计算等操作也是必须放在的该层的。",
    "optionC" : "模型层（ model ）：： android 的控制层的重 任通常落在了众多的 acitvity 的肩上，这句话也就暗含了不要在 acitivity 中写代码，要通过 activity 交割 model 业务逻辑层处理， 这样做的另外一个原因是 android 中的 acitivity 的响应时间是 5s ，如果耗时的操作放在这里，程序就很容易被回收掉。",
    "optionAnswer" : "C",
    "answer" : "1) 视图层（ view ） ：一般采用 xml 文件进行界面的描述，使用的时候可以非常方便的引入，当然，如何你对 android 了解的比较的多了话，就一定可 以想到在 android 中也可以使用javascript+html 等的方式作为 view 层，当然这里需要进行 java 和 javascript 之间的通 信，幸运的是， android 提供了它们之间非常方便的通信实现。\n\n2) 控制层（ controller ）： android 的控制层的重 任通常落在了众多的 acitvity 的肩上，这句话也就暗含了不要在 acitivity 中写代码，要通过 activity 交割 model 业务逻辑层处理， 这样做的另外一个原因是 android 中的 acitivity 的响应时间是 5s ，如果耗时的操作放在这里，程序就很容易被回收掉。\n\n3) 模型层（ model ）： 对数据库的操作、对网络等的操作都应该在 model 里面处理，当然对业务计算等操作也是必须放在的该层的。\n",
    "optionB" : " 控制层（ controller ）： android 的控制层的重 任通常落在了众多的 acitvity 的肩上，这句话也就暗含了不要在 acitivity 中写代码，要通过 activity 交割 model 业务逻辑层处理， 这样做的另外一个原因是 android 中的 acitivity 的响应时间是 5s ，如果耗时的操作放在这里，程序就很容易被回收掉",
    "type" : "1",
    "optionA" : "视图层（ view ） ：一般采用 xml 文件进行界面的描述，使用的时候可以非常方便的引入，当然，如何你对 android 了解的比较的多了话，就一定可 以想到在 android 中也可以使用javascript+html 等的方式作为 view 层，当然这里需要进行 java 和 javascript 之间的通 信，幸运的是， android 提供了它们之间非常方便的通信实现。\n",
    "question" : "在 Android 中 MVC 具体名称以及具体体现？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b4",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "使用了contentView、",
    "optionC" : "activity中的对生命周期大于activity",
    "optionAnswer" : "D",
    "answer" : "GC内存泄露出现的情况：1、数据库的cursor没有关闭  2、Bitmap对象不使用时采用热recyle（）释放内存  3、activity中的对生命周期大于activity  4、没有使用了contentView、",
    "optionB" : "Bitmap对象不使用时采用热recyle（）释放内存",
    "type" : "1",
    "optionA" : "数据库的cursor没有关闭",
    "question" : "以下哪项不是GC内存泄露出现的情况（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39956",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Log.v()< Log.i()< Log.w()< Log.d()< Log.e()",
    "optionC" : "Log.v()< Log.d()< Log.w()< Log.i()< Log.e()",
    "optionAnswer" : "B",
    "answer" : "android.util.Log常用的方法有以下5个：Log.v() Log.d() Log.i() Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG,INFO, WARN，ERROR。\n1、Log.v 的调试颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思，平时使用就是Log.v(\"\",\"\");\n2、Log.d的输出颜色是蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择.\n3、Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息\n4、Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。\n5、Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。",
    "optionB" : "Log.v()< Log.d()< Log.i()< Log.w()< Log.e()",
    "type" : "1",
    "optionA" : "Log.v()< Log.i()< Log.d()< Log.w()< Log.e()",
    "question" : "android.util.Log常用的几个LOG打印按重要程度由轻到重的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39989",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " Uri  的 authority 部分：该部分是完整的类名。（使用大小写混写的形式）。",
    "optionC" : " Uri  的标准前缀：以 “content:\/\/” 作为前缀，这个是标准的前缀，表示该数据由  ContentProvider  管理。",
    "optionAnswer" : "D",
    "answer" : "URI：URI是ContentResolver和ContentProvider进行数据交换的标识。\n每个 ContentProvider 提供公共的 URI 来唯一标识其数据集。管理多个数据集的（多个表）的ContentProvider为每个数据集提供了\n单独的URI。\nURI的标准前缀：以 “content:\/\/” 作为前缀，这个是标准的前缀，表示该数据由  ContentProvider  管理。\nURI的authority 部分：该部分是完整的类名。（使用小写形式）。\nURI的path部分（资源部分、数据部分）：用于决定哪类数据被请求。",
    "optionB" : "  每个 ContentProvider 提供公共的 URI 来唯一标识其数据集。管理多个数据集的（多个表）的  ContentProvider  为每个数据集提供了\n单独的 URI",
    "type" : "1",
    "optionA" : "Uri 是 ContentResolver 和 ContentProvider 进行数据交换的标识。",
    "question" : "下列关于uri说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3997a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "create()方法创建并显示对话框",
    "optionC" : "AlertDialog不能直接用new关键字构建对象,而必须使用其内部类Builder\n",
    "optionAnswer" : "D",
    "answer" : "AlertDialog的构造方法被声明为protected，所以不能直接使用new关键字来创建AlertDialog类的对象实例。要想创建AlertDialog对话框，需要使用Builder类，该类是AlertDialog类中定义的一个内嵌类。因此必须创建AlertDialog.Builder类的对象实例，然后再调用show()来显示对话框。\n    例如：    AlertDialog.Builder db= new Builder(this);\n                    db..create().show();",
    "optionB" : "AlertDialog.Builder的create() 和show()方法都返回AlertDialog对象\n",
    "type" : "1",
    "optionA" : "show()方法只显示对话框",
    "question" : "关于AlertDialog描述错误的是( )."
  },
  {
    "ID" : "55bb36a8e4b0809382e3997c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态",
    "optionC" : "sleep暂停线程、但监控状态仍然保持，结束后会自动恢复",
    "optionAnswer" : "D",
    "answer" : "sleep是线程类（Thread）的方法，执行此方法会导致当前此线程暂停指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。\nwait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法或notifyAll后本线程才获得对象锁进入运行状态",
    "optionB" : "sleep不释放对象锁，wait放弃对象锁",
    "type" : "1",
    "optionA" : "sleep是线程类（Thread）的方法，wait是Object类的方法；",
    "question" : "关于sleep()和wait()，以下描述错误的一项是（ ）"
  },
  {
    "ID" : "55bb36a8e4b0809382e39974",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Sax跟Xmlpull一样简明，且不需要扫描完整个流。",
    "optionC" : "对于含有数据量十分巨大,而又不用对文档的所有数据进行遍历或者分析的时候,使用该方法十分有效.该方法不用将整个文档读入内存,而只需读取到程序所需的文档标签处即可",
    "optionAnswer" : "D",
    "answer" : "优点:\n\nSAX 对内存的要求比较低,因为它让开发人员自己来决定所要处理的标签.特别是当开发人员只需要处理文档中所包含的部分数据时,SAX 这种扩展能力得到了更好的体现.\n\n缺点:\n\n用SAX方式进行XML解析时,需要顺序执行,所以很难访问到同一文档中的不同数据.此外,在基于该方式的解析编码过程也相对复杂.\n     跟Xmlpull对比： XmlPull和Sax类似，是基于流（stream）操作文件，然后根据节点事件回调开发者编写的处理程序。因为是基于流的处理，因此Xmlpull和 Sax都比较节约内存资源，不会象Dom那样要把所有节点以对橡树的形式展现在内存中。 但Xmlpull比Sax更简明，而且不需要扫描完整个流。\n使用场景:\n\n对于含有数据量十分巨大,而又不用对文档的所有数据进行遍历或者分析的时候,使用该方法十分有效.该方法不用将整个文档读入内存,而只需读取到程序所需的文档标签处即可.",
    "optionB" : "用SAX方式进行XML解析时,需要顺序执行,所以很难访问到同一文档中的不同数据.此外,在基于该方式的解析编码过程也相对复杂.",
    "type" : "1",
    "optionA" : "SAX 对内存的要求比较低,因为它让开发人员自己来决定所要处理的标签.特别是当开发人员只需要处理文档中所包含的部分数据时,SAX 这种扩展能力得到了更好的体现.",
    "question" : "SAX解析的优缺点？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399bc",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Sqlite数据库存储",
    "optionC" : "CoreData存储",
    "optionAnswer" : "C",
    "answer" : "1）SQLite数据库存储结构化数据。\n2）文件存储：分为内部存储和外部存储(SD卡)两种存储方式。\n3）SharedPreferences共享参数，键值对形式存储。\n4）网络存储\n5）ContentProvider存储",
    "optionB" : "ContentProvider存储",
    "type" : "1",
    "optionA" : "网络存储",
    "question" : "下列不属于Android的数据存储方式的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39948",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "HashMap依然可用，但是性能受到重创。",
    "optionC" : "HashMap的性能会有一点影响，但总体依然是高效的",
    "optionAnswer" : "D ",
    "answer" : "大量冲突时HashMap退化为链表，性能收严重影响",
    "optionB" : "HashMap没有影响，依然可以高效的工作",
    "type" : "1",
    "optionA" : "HashMap崩溃，导致不可用",
    "question" : "如果HashMap发生大量Hash冲突，则会导致()"
  },
  {
    "ID" : "55bb36a8e4b0809382e39996",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "在开发Android应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。",
    "optionC" : "主线程通常又被叫做UI线程。",
    "optionAnswer" : "B",
    "answer" : " 当一个程序第一次启动时，Android会同时启动一个对应的主线程（Main Thread），主线程主要负责处理与UI相关的事件，如用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。在开发Android应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。",
    "optionB" : "主线程主要负责处理与UI相关的事件，如用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理，图片的下载等",
    "type" : "1",
    "optionA" : "当一个程序第一次启动时，Android会同时启动一个对应的主线程（Main Thread）",
    "question" : "有关单线程模型说法不对的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3990c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "2",
    "optionC" : "3",
    "optionAnswer" : "B",
    "answer" : "一个Activity基本上有4个生命状态： 1.activity\/Running 2.Pause 3.Stopped 4.Inactive",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "5",
    "question" : "Activity的生命状态有几种？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39960",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onStop()",
    "optionC" : "onCreateView()",
    "optionAnswer" : "C",
    "answer" : "activity的生命周期有：onCreate()、onStart()、onReStart（）、onResume（）、onPause（）、onStop()、onDestory()",
    "optionB" : "onDestory()",
    "type" : "1",
    "optionA" : "onCreate()",
    "question" : "哪项不是activity的生命周期？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399cb",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "应用程序框架层、系统运行库层、应用程序层和linux核心层",
    "optionC" : "应用程序框架层、应用程序层、系统运行库层和linux核心层",
    "optionAnswer" : "B",
    "answer" : "Android系统采用了分层架构，从高层到低层分别是：应用程序层、应用程序框架层、系统运行库层和linux核心层。",
    "optionB" : "应用程序层、应用程序框架层、系统运行库层和linux核心层",
    "type" : "1",
    "optionA" : "应用程序层、应用程序框架层、系统运行库层、应用程序框架层和linux核心层",
    "question" : "Android系统采用了分层架构，从高层到低层分别是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3990a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "6",
    "optionC" : "5",
    "optionAnswer" : "C",
    "answer" : "Log.v(VERBOSE)详细讯息、Log.d(DEBUG)除错讯息、Log.i(INFO)通知讯息、Log.w(WARN)警告讯息、Log.e(ERROR)错误讯息",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "3",
    "question" : "DDMS中Log信息分为几个级别(   )."
  },
  {
    "ID" : "55bb36a8e4b0809382e399d0",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "这个AsyncTask生来就是处理一些后台的比较耗时（这里一般是不超过10秒）的任务，给用户带来良好用户体验的，从编程的语法上显得优雅了许多，不再需要子线程和Handler就可以完成异步操作并且刷新用户界面。",
    "optionC" : "AsyncTask是Android提供的一个工具类，顾名思义异步任务",
    "optionAnswer" : "D",
    "answer" : "在开发Android移动客户端的时候往往要使用多线程来进行操作，我们通常会将耗时的操作放在单独的线程执行，避免其占用主线程而给用户带来不好的用户体验。但是在子线程中无法去操作主线程（UI 线程），在子线程中操作UI线程会出现错误。因此android提供了一个类Handler来在子线程中来更新UI线程，用发消息的机制更新UI界面，呈现给用户。这样就解决了子线程更新UI的问题。但是费时的任务操作总会启动一些匿名的子线程，太多的子线程给系统带来巨大的负担，随之带来一些性能问题。因此android提供了一个工具类AsyncTask，顾名思义异步执行任务。这个AsyncTask生来就是处理一些后台的比较耗时的任务（这里的任务一般是不超过5秒的），给用户带来良好用户体验的，从编程的语法上显得优雅了许多，不再需要子线程和Handler就可以完成异步操作并且刷新用户界面。",
    "optionB" : "在子线程中无法去操作主线程（UI 线程），在子线程中操作UI线程会出现错误。因此android提供了一个类Handler来在子线程中来更新UI线程，用发消息的机制更新UI界面，呈现给用户。这样就解决了子线程更新UI的问题。",
    "type" : "1",
    "optionA" : "在开发Android移动客户端的时候往往要使用多线程来进行操作，我们通常会将耗时的操作放在单独的线程执行，避免其占用主线程而给用户带来不好的用户体验。",
    "question" : "AsyncTask简介有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a9",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "SD卡支持",
    "optionC" : "缓存区大小",
    "optionAnswer" : "A",
    "answer" : "B\nSkin：Built-in其实就是定义屏幕尺寸的像素，可以使用由SDk直接提供的常见分辨率\nC、\n RAM:缓存\nD、\nSD Card Support 是否支持插入\/弹出闪存卡；",
    "optionB" : "屏幕分辨率",
    "type" : "1",
    "optionA" : "蓝牙支持",
    "question" : "在创建AVD时,下面哪些是不能配置的选项( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e39931",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后 向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。",
    "optionC" : "Vector 由于使用了synchroni zed 方法（线程安全），通常性能上较 ArrayList 强",
    "optionAnswer" : "C",
    "answer" : "ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按 序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchroni zed 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后 向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。",
    "optionB" : "ArrayList 和 Vector都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢",
    "type" : "1",
    "optionA" : "ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素",
    "question" : "有关于Arraylist、Vector、 LinkedList的说法不正确的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39930",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "List myList=new  List();",
    "optionC" : "ArrayList myList=new List();",
    "optionAnswer" : "B",
    "answer" : "ArrayList是List的子类",
    "optionB" : "List myList=new ArrayList();",
    "type" : "1",
    "optionA" : "ArrayList myList=new Object();",
    "question" : "构造ArrayList类的一个实例，此类继承里List接口，下面哪个方法是正确的（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39927",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "BroadCast Receiver：接受仅一种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型",
    "optionC" : "Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径",
    "optionAnswer" : "D",
    "answer" : "Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑\nservice：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事务，定义好需要接受的Intent提供同步和异步的接口\nContent Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径\nBroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型",
    "optionB" : "service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的实物，定义好需要接受的Intent提供同步和异步的接口",
    "type" : "1",
    "optionA" : "Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑",
    "question" : "下列对Android的四大组件描述错误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39969",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onPostExecute(Result)",
    "optionC" : "onProgressUpdate(Progress...)",
    "optionAnswer" : "B",
    "answer" : "doInBackground(Params...), 将在onPreExecute 方法执行后马上执行，该方法运行在后台线程中。这里将主要负责执行那些很耗时的后台计算工作。可以调用 publishProgress方法来更新实时的任务进度。该方法是抽象方法，子类必须实现。",
    "optionB" : "doInBackground(Params...)",
    "type" : "1",
    "optionA" : "onPreExecute()",
    "question" : "异步任务中一般进行耗时操作的方法是？"
  },
  {
    "answer" : "onSaveInstanceState()\n当你的程序中某一个Activity A在运行时，主动或被动地运行另一个新的Activity B，这个时候A会执行onSaveInstanceState()。B完成以后又会来找A，这个时候就有两种情况：一是A被回收，二是A没有被回收，被回收的A就要重新调用onCreate()方法，不同于直接启动的是这回onCreate()里是带上了参数savedInstanceState；而没被收回的就直接执行onResume()，跳过onCreate()了。",
    "ID" : "55f2e52be4b0152a611433ed",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c6",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "setNegativeButton方法是用来加取消按钮的",
    "optionC" : "setPositiveButton方法是用来加确定按钮的",
    "optionAnswer" : "A",
    "answer" : "对话框通过show()显示的",
    "optionB" : "对话框的显示需要调用show方法",
    "type" : "1",
    "optionA" : "要想使用对话框首先要使用new关键字创建AlertDialog的实例",
    "question" : "关于AlertDialog的说法不正确的是（   ）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39953",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "JSON的速度要远远快于XML",
    "optionC" : "JSON对数据的描述性比XML较好",
    "optionAnswer" : "C",
    "answer" : "JSON v.s. XML\n1.JSON和XML的数据可读性基本相同\n2.JSON和XML同样拥有丰富的解析手段\n3.JSON相对于XML来讲，数据的体积小\n4.JSON与JavaScript的交互更加方便\n5.JSON对数据的描述性比XML较差\n6.JSON的速度要远远快于XML",
    "optionB" : "JSON与JavaScript的交互更加方便",
    "type" : "1",
    "optionA" : "JSON相对于XML来讲，数据的体积小",
    "question" : "下列有关JSON跟XML的说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3996f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "static",
    "optionC" : "protected",
    "optionAnswer" : "B",
    "answer" : "接口可以用abstract修饰",
    "optionB" : "abstract",
    "type" : "1",
    "optionA" : "private",
    "question" : "下列能用来修饰interface的有（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e39987",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "011.activitj",
    "optionC" : "1",
    "optionAnswer" : "B",
    "answer" : "1.与(&,&&)和或(|,||)的区别 \n1.1使用与操作的时候，要求前后几个表达式的内容都是true,最终结果才是true，如果有一个是false，则最终结果就是false； \n  1.2使用或操作的时候，要求前后几个表达式只要有一个true，则最终结果就是true，如果全都是false，则最终结果才是false; \n\n2.与(&)和短路与(&&)的区别以及或(|)和短路或(||)的区别 ",
    "optionB" : "false ",
    "type" : "1",
    "optionA" : "true ",
    "question" : "下列程序段的输出结果是（）\nvoid complicatedexpression_r(){\n    int x=20,y=30;\n    boolean b;\n    b=x>50&&y>60 || x>50&&y<-60 || x<-50&&y>60 || x<-50&&y<-60;\n    System.out.println(b);\n}"
  },
  {
    "ID" : "55bb36a7e4b0809382e3995e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onDestory()",
    "optionC" : "onCreate()",
    "optionAnswer" : "A",
    "answer" : "Activity中调用startService（）方法启动一个Service的生命周期有：onCreate()-----onStartCommand()----运行中---(如果自己就是客户端（Activity）调用了stop Service的方法的话)onDestory()",
    "optionB" : "onStartCommand()",
    "type" : "1",
    "optionA" : "onBind()",
    "question" : "以下哪项不是在Activity中调用startService（）方法启动一个Service的生命周期？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e3999a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "如果在一个类 中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded 的 方法是绝对不可以改变返回值的类型。 ",
    "optionC" : "如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\"屏蔽\"了。",
    "optionAnswer" : "D",
    "answer" : " 方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\"屏蔽\"了。如果在一个类 中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded 的 方法是可以改变返回值的类型。 ",
    "optionB" : "重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。",
    "type" : "1",
    "optionA" : "方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。",
    "question" : "Overload 和 Override 的说法有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a7",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "动态扩充对象功能",
    "optionC" : "处于安全目的，保护被访问者",
    "optionAnswer" : "D",
    "answer" : "这个是装饰者模式的功能",
    "optionB" : "延迟加载，提升系统性能 ",
    "type" : "1",
    "optionA" : "控制对象访问和通信 ",
    "question" : "对代理模式的作用，描述最不恰当的一项是（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e39986",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "如果是Remote?Service，那么对应的 Service也是运行在主进程的 main 线程上的。",
    "optionC" : "Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。",
    "optionAnswer" : "D",
    "answer" : "1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。\n2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote?Service，那么对应的 Service 则是运行在独立进程的 main 线程上。",
    "optionB" : "可以用 Thread 来执行一些异步的操作。",
    "type" : "1",
    "optionA" : "Thread 是程序执行的最小单元，它是分配CPU的基本单位。",
    "question" : "Service和Thread说法有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39970",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "DOM",
    "optionC" : "JSON",
    "optionAnswer" : "C",
    "answer" : "XML解析主要有三种方式，SAX、DOM、PULL。",
    "optionB" : "SAX",
    "type" : "1",
    "optionA" : "PULL",
    "question" : "android 中下列不属于解析xml的类的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399d3",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "这个文件列出了应用程序所提供的功能，在这个文件中，你可以指定应用程序使用到的服务(如电话服务、互联网服务、短信服务、GPS服务等等)。另外当你新添加一个Activity的时候，也需要在这个文件中进行相应配置，只有配置好后，才能调用此Activity。",
    "optionC" : "在这个目录中我们可以存放应用使用到的各种资源，如xml界面文件，图片或数据。",
    "optionAnswer" : "A",
    "answer" : "指的是某些公司的产品型号，主要是一些针对硬件配置的东西,比如radio 方面的,若是采用TI 的,这里面会有TI提供的一些RIL方面的接口等。",
    "optionB" : "专门存放png、jpg等图标文件。在代码中使用getResources().getDrawable(resourceId)获取该目录下的资源。",
    "type" : "1",
    "optionA" : "指的是某些公司的产品型号，主要是一些针对硬件配置的东西,比如radio 方面的,若是采用TI 的,这里面会有TI提供的一些RIL方面的接口等。",
    "question" : "Android源码下vendor目录下文件的作用?"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b8",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中          的名是String类型，而值也是String类型",
    "optionC" : "他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的          名，可以为空，而值都是String类型 ",
    "optionAnswer" : "A",
    "answer" : "用于存储名值的，但是名和值的类型有要求：名是String类型，值是基本类型。基本数据类型有： byte \nshot\nint \nlong\nfloat\ndouble\nchar \nboolean      ",
    "optionB" : "他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的          名是任意类型，而值都是基本类型",
    "type" : "1",
    "optionA" : "他和Hashtable比较类似，也是负责存储一些名值对，但是他存储的名值对当中的          名是String类型，而值都是基本类型 ",
    "question" : "关于ContenValues类说法正确的是（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39939",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "SQLiteHelpe",
    "optionC" : "Cursor",
    "optionAnswer" : "A",
    "answer" : "在多个应用中读取共享存储数据时，需要用到ContentResolver的query方法，query()方法，返回值是 Cursor实例，用于迭代请求的数据。",
    "optionB" : "ContentProvider",
    "type" : "1",
    "optionA" : "ContentResolver",
    "question" : "在多个应用中读取共享存储数据时，需要用到哪个对象的query方法？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39966",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onItemSelected（）",
    "optionC" : "onCreateMenu（）",
    "optionAnswer" : "A ",
    "answer" : "android中使用Menu时可能需要重写的方法有：onCreateOptionMenu（）和onOptionItemSelected（）",
    "optionB" : "onCreate（）",
    "type" : "1",
    "optionA" : "onCreateOptionMenu（）",
    "question" : "在android中使用Menu时可能需要重写的方法是（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b5",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "activity中的对象的生命周期大于activity\n调试方法: DDMS==> HEAPSZIE==>dataobject==>[Total Size]",
    "optionC" : "Bitmap对象使用时采用recycle()释放内存",
    "optionAnswer" : "C",
    "answer" : "出现情况:\n1. 数据库的cursor没有关闭\n2.构造adapter时,没有使用缓存contentview\n   衍生listview的优化问题-----减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程\n3.Bitmap对象不使用时采用recycle()释放内存\n4.activity中的对象的生命周期大于activity\n调试方法: DDMS==> HEAPSZIE==>dataobject==>[Total Size]",
    "optionB" : "构造adapter时,没有使用缓存contentview\n   衍生listview的优化问题-----减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程",
    "type" : "1",
    "optionA" : "数据库的cursor没有关闭",
    "question" : "Android系统中GC出现内存泄露的描述错误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3996e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "没有这种关键字",
    "optionC" : "static",
    "optionAnswer" : "B",
    "answer" : "private：私有的，可以改；final类似与常量，不可以改；static：静态；",
    "optionB" : "final",
    "type" : "1",
    "optionA" : "private",
    "question" : "关键字()表明一个对象或变量在初始化后不能被修改。"
  },
  {
    "ID" : "55bb36a7e4b0809382e39965",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onCreate() -> onStart() –> onPause() -> onResume() –> onDestroy()–> onStop() ",
    "optionC" : "onCreate() -> onStart()–> onPause() -> onResume() –> onStop() –> onDestroy()",
    "optionAnswer" : "B",
    "answer" : "调用finish()， Activity调用顺序是onCreate() -> onStart() -> onResume()–> onPause() –> onStop() –> onDestroy()",
    "optionB" : "onCreate() -> onStart() -> onResume()–> onPause() –> onStop() –> onDestroy()",
    "type" : "1",
    "optionA" : "onCreate() -> onStart() -> onResume()–> onStop() –> onDestroy()–> onPause() ",
    "question" : "调用finish()， Activity调用顺序是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39909",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "6",
    "optionC" : "5",
    "optionAnswer" : "C",
    "answer" : "1）SQLite数据库存储结构化数据。\n2）文件存储：分为内部存储和外部存储(SD卡)两种存储方式。\n3）SharedPreferences共享参数，键值对形式存储。\n4）网络存储\n5）ContentProvider存储",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "3",
    "question" : "Android中的存储方式有几种？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39979",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "利用HttpURLConnection对象,我们可以从网络中获取网页数据",
    "optionC" : "当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据",
    "optionAnswer" : "B",
    "answer" : "SharedPreferences存储方式，它是Android提供的用来存储一些简单配置信息的一种机制；文件存储方式是一种较常用的方法，在Android中读取\/写入文件的方法，与Java中实现I\/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件；当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据；利用HttpURLConnection对象,我们可以从网络中获取网页数据",
    "optionB" : "文件存储方式是一种较常用的方法，在Android中读取\/写入文件的方法，提供了openFileInput()和openFileOutput()方法来读取设备上的文件，与Java中实现I\/O的程序是不一样的",
    "type" : "1",
    "optionA" : "SharedPreferences存储方式，它是Android提供的用来存储一些简单配置信息的一种机制",
    "question" : "下列有关于数据存储错误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3993e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "currentTimeMillis()",
    "optionC" : "gc() ",
    "optionAnswer" : "B",
    "answer" : "方法摘要 \nstatic void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) \n          从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 \nstatic String clearProperty(String key) \n          移除指定键指示的系统属性。 \nstatic long currentTimeMillis() \n          返回以毫秒为单位的当前时间。 \nstatic void exit(int status) \n          终止当前正在运行的 Java 虚拟机。 \nstatic void gc() \n          运行垃圾回收器。 \nstatic Map<String,String> getenv() \n          返回一个不能修改的当前系统环境的字符串映射视图。 \nstatic String getenv(String name) \n          获得指定的环境变量值。 \nstatic Properties getProperties() \n          确定当前的系统属性。 \nstatic String getProperty(String key) \n          获得指定键指示的系统属性。 \nstatic String getProperty(String key, String def) \n          获得用指定键描述的系统属性。 \nstatic SecurityManager getSecurityManager() \n          获得系统安全接口。 \nstatic int identityHashCode(Object x) \n          返回给定对象的哈希码，该代码与默认的方法 hashCode() 返回的代码一样，无论给定对象的类是否重写 hashCode()。 \nstatic Channel inheritedChannel() \n          返回从创建此 Java 虚拟机的实体中继承的信道。 \nstatic void load(String filename) \n          从作为动态库的本地文件系统中以指定的文件名加载代码文件。 \nstatic void loadLibrary(String libname) \n          加载由 libname 参数指定的系统库。 \nstatic String mapLibraryName(String libname) \n          将一个库名称映射到特定于平台的、表示本机库的字符串中。 \nstatic long nanoTime() \n          返回最准确的可用系统计时器的当前值，以毫微秒为单位。 \nstatic void runFinalization() \n          运行处于挂起终止状态的所有对象的终止方法。 \nstatic void runFinalizersOnExit(boolean value) \n          已过时。 该方法具有固有的不安全性。它可能对正在使用的对象调用终结方法，而其他线程同时正在操作这些对象，从而导致不正确的行为或死锁。 \nstatic void setErr(PrintStream err) \n          重新分配“标准”错误输出流。 \nstatic void setIn(InputStream in) \n          重新分配“标准”输入流。 \nstatic void setOut(PrintStream out) \n          重新分配“标准”输出流。 \nstatic void setProperties(Properties props) \n          将系统属性设置为 Properties 参数。 \nstatic String setProperty(String key, String value) \n          设置指定键指示的系统属性。 \nstatic void setSecurityManager(SecurityManager s) \n          设置系统安全性。 \n  从类 java.lang.Object 继承的方法 \nclone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait",
    "optionB" : "getTime()  ",
    "type" : "1",
    "optionA" : "exit() ",
    "question" : "以下哪个方法不是System的方法（  )"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c4",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "以上都不正确",
    "optionC" : "主机名 ip",
    "optionAnswer" : "B",
    "answer" : "超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：\n传送协议。\n服务器。\n端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）\n路径。（以“\/”字符区别路径中的每一个目录名称）\n查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）\n典型的统一资源定位符看上去是这样的：\n(带方括号[]的为可选项)：\nprotocol :\/\/ hostname[:port] \/ path \/ [;parameters][?query]#fragment",
    "optionB" : "协议 主机名",
    "type" : "1",
    "optionA" : "协议 用户名",
    "question" : " 一个完整的URL地址由(),(),端口和文件四部分组成。"
  },
  {
    "ID" : "55bb36a8e4b0809382e399d5",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "数据源",
    "optionC" : "适配器",
    "optionAnswer" : "A",
    "answer" : "列表的显示需要三个元素：\n1．ListVeiw：用来展示列表的View；\n2．适配器： 用来把数据映射到ListView上的中介；\n3．数据源： 具体的将被映射的字符串，图片，或者基本组件。",
    "optionB" : "listview",
    "type" : "1",
    "optionA" : "子布局",
    "question" : " 下列不属于列表的显示三元素是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39913",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "android.permission.SEND_SMS",
    "optionC" : "android.permission.RECEIVE_SMS ",
    "optionAnswer" : "D",
    "answer" : "在android的清单文件总的权限中查看关于发送电话的权限即可",
    "optionB" : "permission.SMS",
    "type" : "1",
    "optionA" : "发送短信,无需配置权限",
    "question" : "\n如果在android应用程序中需要发送短信,那么需要在AndroidManifest.xml文件中增加什么样的权限( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e39932",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "AsyncTask",
    "optionC" : "AsyncTask和Handler",
    "optionAnswer" : "A",
    "answer" : "Android处理耗时的操作基本思路为将耗时的操作放到非UI线程执行。常用的是AsyncTask，Handler和Thread，Loaders. ",
    "optionB" : "AsyncTask，Handler和Thread",
    "type" : "1",
    "optionA" : "AsyncTask，Handler和Thread，Loaders. ",
    "question" : "Android处理耗时的操作有哪些方式？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39985",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几\n个方法 ；",
    "optionC" : "该task不能被执行一次，否则多次调用时将会出现异常 ；",
    "optionAnswer" : "C",
    "answer" : "、为了正确的使用AsyncTask类，以下是几条必须遵守的准则：\n　　1) Task的实例必须在UI thread中创建；\n　　2) execute方法必须在UI thread中调用；\n　　3) 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几\n个方法 ；\n　　4) 该task只能被执行一次，否则多次调用时将会出现异常 ；\ndoInBackground方法和onPostExecute的参数必须对应，这两个参数在AsyncTask声明的泛型参数列表中指定，第一个为\ndoInBackground接受的参数，第二个为显示进度的参数，第三个为doInBackground返回和onPostExecute传入的参数。",
    "optionB" : "execute方法必须在UI thread中调用；",
    "type" : "1",
    "optionA" : "Task的实例必须在UI thread中创建；",
    "question" : "为了正确的使用AsyncTask类，以下是哪条不是必须遵守的准则（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e3994c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "float",
    "optionC" : "double",
    "optionAnswer" : "A",
    "answer" : "因为是id,所以要int型",
    "optionB" : "String",
    "type" : "1",
    "optionA" : "int",
    "question" : "R.id.textview1(textview1为xml下TextView的id)类型是什么？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c2",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "五角星的色彩",
    "optionC" : "分数的增量",
    "optionAnswer" : "D ",
    "answer" : "个数可以直接设置，颜色不可以",
    "optionB" : "当前分数",
    "type" : "1",
    "optionA" : "五角星个数",
    "question" : "RatingBar组件中不能用属性直接设置的是(  )"
  },
  {
    "ID" : "55bb36a7e4b0809382e3992a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "adnroid create acd -n myAvd -t 8 -C HVDA - s d:\\card.img",
    "optionC" : "adnroid create acd -n myAvd -s 8 -t HVDA - C d:\\card.img",
    "optionAnswer" : "A",
    "answer" : "adnroid create acd -n myAvd -t 8 -s HVDA - C d:\\card.img",
    "optionB" : "adnroid create acd -t myAvd -n 8 -s HVDA - C d:\\card.img",
    "type" : "1",
    "optionA" : "adnroid create acd -n myAvd -t 8 -s HVDA - C d:\\card.img",
    "question" : "请使用命令行的方式创建一个名字为myAvd,sdk版本为2.2,sd卡是在d盘的根目录下\n 名字为scard.img， 并指定屏幕大小HVGA."
  },
  {
    "ID" : "55bb36a7e4b0809382e39959",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "application：声明了用来测试此package或其他package指令组件的代码。",
    "optionC" : "permission： 声明了安全许可来限制哪些程序能你package中的组件和功能。",
    "optionAnswer" : "D",
    "answer" : "manifest：根节点，描述了package中所有的内容。\nuses-permission：请求你的package正常运作所需赋予的安全许可。\npermission： 声明了安全许可来限制哪些程序能你package中的组件和功能。\ninstrumentation：声明了用来测试此package或其他package指令组件的代码。",
    "optionB" : "uses-permission：请求你的package正常运作所需赋予的安全许可。",
    "type" : "1",
    "optionA" : "manifest：根节点，描述了package中所有的内容。",
    "question" : "Manifest.xml文件中描述信息有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3993c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念.",
    "optionC" : "DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,都拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程,所以说不是一个概念.",
    "optionAnswer" : "D",
    "answer" : "DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 \n \n 什么是android DVM:Dalvik是Google公司自己设计用于Android平台的Java虚拟机,每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。\n \n Dalvik和Java运行环境的区别　　[\n 1：Dalvik主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等等重要功能。 　　\n 2：Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。 　　\n 3：不同于Java虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex 　　 4:dex文件格式可以减少整体文件尺寸，提高I\/o操作的类查找速度。 　　\n 5:odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化。 　　\n 6：所有的Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制 　　\n 7：有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化，库的加载，预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的数据提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域。",
    "optionB" : "DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程,所以说不是一个概念.",
    "type" : "1",
    "optionA" : "DVM指dalivk的虚拟机.每一个Android应用程序都在它自己的进程中运行,不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux 中的一个进程,所以说可以认为是同一个概念.",
    "question" : "下面关于Android dvm的进程和Linux的进程,应用程序的进程说法正确的是(  )"
  },
  {
    "answer" : "startActivityResult()",
    "ID" : "55f2e52be4b0152a611433eb",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "当启动一个Activity并且新的Activity执行完后需要返回到启动它的Activity来执行的回调函数是（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a2",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "静态的可以直接用类名点变量就可以直接调用，非静态的在别的类中只能先实例化，再用对象点变量就可以调用;",
    "optionC" : "静态变量不可以直接用类名点变量调用",
    "optionAnswer" : "C",
    "answer" : "静态变量和实例变量都可以用一个具体实例加.来引用。如  a.x;  静态变量还可以直接用类名加.进行引用 如 ClassName.x。静态变量和实例变量最大的区别是静态变量在内存中只有一份，所以该类的所有实例共享该变量；而实例变量随实例的不同可以不相同。静态的可以直接用类名点变量就可以直接调用，非静态的在别的类中只能先实例化，再用对象点变量就可以调用;",
    "optionB" : "静态变量和实例变量最大的区别是静态变量在内存中只有一份，所以该类的所有实例共享该变量，实例变量随实例的不同可以不相同",
    "type" : "1",
    "optionA" : "静态变量和实例变量都可以用一个具体实例加.来引用",
    "question" : "有关静态变量和实例变量的说法错误的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39943",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Page layout",
    "optionC" : "AbsoluteLayout ",
    "optionAnswer" : "D",
    "answer" : "Android中的五中布局：1、FrameLayout 2、RelativeLayout  3、AbsoluteLayout 4、LinearLayout 5、TableLayout",
    "optionB" : "RelativeLayout ",
    "type" : "1",
    "optionA" : "FrameLayout",
    "question" : "Android中常用的五种布局，其中不包括"
  },
  {
    "ID" : "55bb36a7e4b0809382e39924",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "TableLayout",
    "optionC" : "FrameLayout",
    "optionAnswer" : "D",
    "answer" : "TableLayout顾名思义，此布局为表格布局，是LinearLayout的子类",
    "optionB" : "RelativeLayout",
    "type" : "1",
    "optionA" : "AbsoluteLayout",
    "question" : "下列是LinearLayout的子类的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39914",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "广播接收器可以在Activity中单独注册与注销",
    "optionC" : "广播接收器只能接收自定义的广播消息",
    "optionAnswer" : "D",
    "answer" : "A错，可在代码中注册：\r\n注册广播方法一：\r\nIntentFilter intentFilter = new IntentFilter( \"\"android.provider.Telephony.SMS_RECEIVED \"\" );\r\nregisterReceiver( mBatteryInfoReceiver , intentFilter);\r\n第一个参数是我们要处理广播的   BroadcastReceiver   （广播接收者，可以是系统的，也可以是自定义的）；第二个参数是意图过滤器。\r\n注册广播方法二：\r\n registerReceiver(receiver, filter, broadcastPermission, scheduler) \r\n第一个参数是 BroadcastReceiver   （广播接收者，可以是系统的，也可以是自定义的）；第二个参数是意图过滤器；第三个参数是广播权限；第四个参数是   Hander\r\nB错\r\n代码中注销广播 \r\nunregisterReceiver(mBatteryInfoReceiver);\r\nC错\r\n广播不仅能接收自定义的也可以接收系统的广播\"\r\n",
    "optionB" : "广播接收器注册后不能注销",
    "type" : "1",
    "optionA" : "广播接收器只能在配置文件中注册",
    "question" : "关于广播以下陈述正确的是( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e39962",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onCreate() -> onStart() –> onFreeze() -> onResume()–> onPause() ",
    "optionC" : "onCreate() -> onStart() -> onResume()–> onFreeze() –> onPause() ",
    "optionAnswer" : "C",
    "answer" : "在父Activity上显示透明的或非全屏的activity，Activity调用顺序是onCreate() -> onStart() -> onResume()–> onFreeze() –> onPause() ",
    "optionB" : "onCreate() -> onStart()–> onFreeze() –> onPause()  -> onResume()",
    "type" : "1",
    "optionA" : "onCreate() -> onStart() -> onResume() –> onPause() –> onFreeze()",
    "question" : "在父Activity上显示透明的或非全屏的activity，Activity调用顺序是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39990",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。",
    "optionC" : "DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用",
    "optionAnswer" : "A",
    "answer" : "XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。",
    "optionB" : "SAX优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。",
    "type" : "1",
    "optionA" : "常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是双向的",
    "question" : "下列有关于XML解析说法有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3998e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "设置Activity的android:configChanges=\"orientation\"时，切屏不会重新调用各个生命周期，切横、竖屏时只会执行一次",
    "optionC" : "设置Activity的android：configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法",
    "optionAnswer" : "D",
    "answer" : "activity在屏幕旋转时的生命周期：\n1、不设置Activity的android:configChanges事，切屏会重新调用各自生命周期，切横屏时会执行一次，切竖屏时会执行两次。  \n2、设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次  \n3、设置Activity的android：configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法",
    "optionB" : "设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次",
    "type" : "1",
    "optionA" : "不设置Activity的android:configChanges事，切屏会重新调用各自生命周期，切横屏时会执行一次，切竖屏时会执行两次。",
    "question" : "有关activity在屏幕旋转时的生命周期说法错误的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39963",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onCreate() -> onStart() -> onResume()–> onFreeze() –> onStop() — Maybe –> onDestroy() – Maybe –> onPause()",
    "optionC" : "onCreate() -> onStart() -> onResume()–> onFreeze() –> onStop() –> onPause() — Maybe –> onDestroy() – Maybe",
    "optionAnswer" : "A",
    "answer" : "用户点击Home，Actvity调用顺序是onCreate() -> onStart() -> onResume()–> onFreeze() –> onPause() –> onStop() — Maybe –> onDestroy() – Maybe",
    "optionB" : "onCreate() -> onStart() -> onResume()–> onFreeze()  –> onStop() — Maybe–> onPause() –> onDestroy() – Maybe",
    "type" : "1",
    "optionA" : "onCreate() -> onStart() -> onResume()–> onFreeze() –> onPause() –> onStop() — Maybe –> onDestroy() – Maybe",
    "question" : "用户点击Home，Actvity调用顺序是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39906",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "6",
    "optionC" : "5",
    "optionAnswer" : "C",
    "answer" : "用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。用new()来新建对象的，它会在存放于堆中。\"abc\"的实例在类加载的时候只会创建1个，\"abcd\"也会创建一个，在执行代码的时候 a1、a2、a3分别创建3个实例。\r\n",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "2",
    "question" : "String a1=new String(\"abc\");\nString a2=new String(\"abc\");\nString a3=new String(\"abcd\");\n总共创建(  )个String对象"
  },
  {
    "ID" : "55bb36a7e4b0809382e39912",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "当一个Activity被关闭再次开启的时候，此时的Activity就出在Restart状态",
    "optionC" : " 当一个Activity被其它的Activity完全遮蔽，被遮蔽Activity就是处于Stop的状态",
    "optionAnswer" : "D",
    "answer" : "一个Activity基本上有4个生命状态： 1.当一个Activity在屏幕的最上层时(系统堆栈中的最顶端)，此Activity就是属于active或running的状态。 2.当一个Activity失去焦点(Focus)但还看得到它的画面，那失去焦点的这个Activity则处在Paused的状态，像这个Activity它还是存活着，并没有从系统中消失(Activity本身所有的状态及数据都还存在，也跟窗口管理程式WindowManager保持连系着)，像这种属于Paused状态的Activity，当系统的内存不够用时，系统会自动判断，把优先级较低的Activity删除。3. 当一个Activity被其它的Activity完全遮蔽，被遮蔽Activity就是处于Stop的状态，不过仍保有全部的状态及数据，但因为已不再被使用者看见，所以它的画面是被隐藏起来的(画面不需要更新)，当系统内存不足时，这种Stop状态的Activity是最先被系统考虑拿来释放内存的。4.当一个曾经被启动过的Activity被杀死时，它就变成inactive。Inactive Activity会从Activity栈中移除，当它重新显示和使用时需要再次启动。",
    "optionB" : "当一个Activity失去焦点(Focus)但还看得到它的画面，那失去焦点的这个Activity则处在Paused的状态",
    "type" : "1",
    "optionA" : " 当一个Activity在屏幕的最上层时(系统堆栈中的最顶端)，此Activity就是属于active或running的状态。",
    "question" : "下列不属于Activity状态的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39975",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Thread",
    "optionC" : "Parcelable",
    "optionAnswer" : "D",
    "answer" : "bundle.putSerializable(key,object);\nbundle.putParcelable(key,object);使用两种方式接收的语法分别为：\nobject=(Object) getIntent().getSerializableExtra(key);\nobject=(Object) getIntent().getParcelableExtra(key);\n--------------------------------------------\nSerializable :将 Java 对象序列化为二进制文件的 Java 序列化技术是 Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现 Serializable 接口，使用ObjectInputStream 和 ObjectOutputStream 进行对象的读写。\n\nParcelable  :\nandroid提供了一种新的类型：Parcel。本类被用作封装数据的容器，封装后的数据可以通过Intent或IPC传递。 除了基本类型以\n外，只有实现了Parcelable接口的类才能被放入Parcel中。\n是GOOGLE在安卓中实现的另一种序列化,功能和Serializable相似,主要是序列化的方式不同\n \n",
    "optionB" : "File",
    "type" : "1",
    "optionA" : "Serializable",
    "question" : "Intent传递数据时，下列的数据类型不可以被传递的是（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e3992b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "ProgressDialog.Builder builder = new ProgressDialog.Builder(context);",
    "optionC" : "ProgressDialog dialog = new ProgressDialog(context);",
    "optionAnswer" : "C",
    "answer" : "B:\nAlertDialog的构造方法被声明为protected\n，所以不能直接使用new关键字来创建AlertDialog类的对象实例。要想创建AlertDialog对话框，需要使用Builder类，该类是AlertDialog类中定义的一个内嵌类。因此必须创建AlertDialog.Builder类的对象实例，然后再调用show()来显示对话框。\n例如： \n       AlertDialog.Builder db= new Builder(this);\n                    db..create().show();\n-------------------------------------\nC:\nProgressDialog pDialog;\/\/进度条对话框对象 \npDialog = new ProgressDialog(Context); \/\/构造进度条对话框 ",
    "optionB" : "AlertDialog.Builder builder = new AlertDialog.Builder(context);",
    "type" : "1",
    "optionA" : "AlertDialog dialog = new AlertDialog(context);",
    "question" : "下面哪条语句可以构造正确的对话框( )."
  },
  {
    "ID" : "55bb36a8e4b0809382e39988",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Animation",
    "optionC" : "Frame",
    "optionAnswer" : "D",
    "answer" : "Tween补间动画\nFrame逐帧动画",
    "optionB" : "Alpha",
    "type" : "1",
    "optionA" : "Tween",
    "question" : "下面哪一项不属于android的动画类型？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3995d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "自定义的item内容、Object数组、数据库的Cursor",
    "optionC" : "自定义的item内容、数据库的Cursor、Object数组",
    "optionAnswer" : "A",
    "answer" : "ArrayAdpter CursorAdapter都是BaseAdapter的子类。都是用来填充那些含有item的控件。\n主要区别是数据来源不同。ArrayAdapter数据来源是Object数组，CursorAdapter数据来源是数据库的Cursor,而BaseAdapter适合创建复杂自定义的item内容，通过继承BaseAdapter类，重写相关方法来实现。",
    "optionB" : "Object数组、数据库的Cursor、自定义的item内容",
    "type" : "1",
    "optionA" : "Object数组、自定义的item内容、数据库的Cursor",
    "question" : "ArrayAdapter BaseAdapter CursorAdapter的数据来源分别是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39976",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Writeable",
    "optionC" : "Comparable",
    "optionAnswer" : "A",
    "answer" : "serialization 允许你将实现了Serializable接口的对象转换为字节序列，这些字节序列可以被完全存储以备以后重新生成原来的对象。  \nserialization不但可以在本机做，而且可以经由网络操作（就是猫小说的RMI）。这个好处是很大的----因为它自动屏蔽了操作系统的差异，字节顺序等。比如，在Window平台生成一个对象并序列化之，然后通过网络传到一台Unix机器上，然后可以在这台Unix机器上正确地重构这个对象。 ",
    "optionB" : "Cloneable",
    "type" : "1",
    "optionA" : "Serializable",
    "question" : "只有实现了()接口的类，其对象才能序列化。"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b3",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "File stream",
    "optionC" : "节点流和处理流",
    "optionAnswer" : "C",
    "answer" : "功能上分：节点流和处理流",
    "optionB" : "字节流和字符流 ",
    "type" : "1",
    "optionA" : "输入流和输出流",
    "question" : "java.io包中定义了多个流类型来实现输入和输出功能，可以从不同的角度对其进行分 类,按功能分为：()"
  },
  {
    "ID" : "55bb36a8e4b0809382e3998a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "x(int m) ...",
    "optionC" : "x(int m, int n) ... ",
    "optionAnswer" : "B",
    "answer" : "与类名称具有一样名称的成员函数是构造函数。构造函数不能有返回值,甚至不能有return语句。说明一个有返回值的构造函数是错误的,取构造函数的地址也是错误的。 \n如果一个类有构造函数,在程序中每个该类类型的对象在使用之前由此构造函数进行初始化(有关初始化的更多信息参见本章后面的“用特殊成员函数进行初始化”)。",
    "optionB" : "void x(int m) ... ",
    "type" : "1",
    "optionA" : "x(int h,int m,int n) ...   ",
    "question" : "设 i、j、k 为类 x 中定义的 int 型属性名,下列类 x 的构造函数中错误的是（ ）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39967",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onStop（）",
    "optionC" : "onFinish（）",
    "optionAnswer" : "A",
    "answer" : "系统销毁了这个Activity的实例在内存中占据的空间。\n在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。",
    "optionB" : "onClear（）",
    "type" : "1",
    "optionA" : "onDestrory（）",
    "question" : "我们知道Hanlder是线程与Activity通信的桥梁，如果线程处理不当，你的机器就会变得越来越慢，那么线程销毁的方法是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3995b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Sqserver2000",
    "optionC" : "Orcal",
    "optionAnswer" : "B",
    "answer" : "SQLite用于存储数据",
    "optionB" : "SQlite",
    "type" : "1",
    "optionA" : "Mysql",
    "question" : "以下那个是Android用以存储数据的数据库？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c5",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "一个类序列化，它的子类和包含的类型也必须可序列化",
    "optionC" : "标识一个类可以序列化[Serializable()]",
    "optionAnswer" : "B",
    "answer" : "序列化转换的是文本文件，序列化是一种将对象以一连串的字节描述的过程",
    "optionB" : "序列化转换的是文本文件",
    "type" : "1",
    "optionA" : "序列化是将对象转换为另一种媒介传输的格式过",
    "question" : "关于序列化，下列说法错误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399af",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。",
    "optionC" : "将listview的高度变为machparent这样更为灵活变动",
    "optionAnswer" : "C",
    "answer" : "1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。\n2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。\n3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。 ",
    "optionB" : "给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。",
    "type" : "1",
    "optionA" : "如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。",
    "question" : "ListView的优化方案"
  },
  {
    "ID" : "55bb36a8e4b0809382e3997d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "SOAP 是简单的，可扩展的",
    "optionC" : "SOAP 与平台无关",
    "optionAnswer" : "B",
    "answer" : "下列属于SOAP优点的是 A,SOAP 与编程语言无关。SOAP 可以使用任何语言来完成 B,SOAP 是完全和厂商无关。 C,SOAP 与平台无关  D,SOAP 是简单的，可扩展的。",
    "optionB" : "SOAP 和厂商无关紧密相连的。",
    "type" : "1",
    "optionA" : "SOAP 与编程语言无关。SOAP 可以使用任何语言来完成",
    "question" : "下列不属于SOAP优点的是"
  },
  {
    "ID" : "55bb36a7e4b0809382e39954",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " layout_toLeftOf",
    "optionC" : "layout_alignTop",
    "optionAnswer" : "C",
    "answer" : "指兄弟控件之间的相对位置。该组属性的值是另一个控件的id。\n1. layout_toRightOf 该控件在哪个控件的右侧\n2. layout_toLeftOf 该控件在哪个控件的左侧\n3. layout_above 该控件在哪个控件的上侧\n4. layout_below 该控件在哪个控件的下侧",
    "optionB" : "layout_below",
    "type" : "1",
    "optionA" : "layout_toRightOf",
    "question" : "有关兄弟控件之间的相对位置说法错误的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39920",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "200、230",
    "optionC" : "102、328",
    "optionAnswer" : "B",
    "answer" : "\n当前屏幕横屏宽度：430dp\n第一个子控件未分配权重前所占宽度：300dp \n第二个子控件未分配权重前所占宽度：300dp \n当前屏幕剩余空间总数：430dp-300dp-300dp = -170dp，将当前-170dp按权重分配给两个子控件，子控件一分配到五分之三，子控件二分配到五分之二\n第一个子控件分配权重后宽度：430dp+（（430dp-300dp-300dp）*3）\/5 = 198dp\n第二个子控件分配权重后宽度：430dp+（430dp-300dp-300dp）*2\/5= 232dp",
    "optionB" : "198、232",
    "type" : "1",
    "optionA" : "190、240",
    "question" : "当前屏幕的大小是430，有左右两个空件，未分配权重之前都是300，左控件权重是3，右控件权重是2，请计算左右俩控件的宽度大小是多少？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39917",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "\/data\/data\/Package Name\/Shared_Pref, \/data\/data\/Package Name\/database ，\/data\/data\/Package Name\/files",
    "optionC" : "\/data\/data\/Package Name\/files, \/data\/data\/Package Name\/database ，\/data\/data\/Package Name\/Shared_Pref",
    "optionAnswer" : "B",
    "answer" : "Preference，File， DataBase这三种方式分别对应的目录是\/data\/data\/Package Name\/Shared_Pref,\/data\/data\/Package Name\/files, \/data\/data\/Package Name\/database 。",
    "optionB" : "\/data\/data\/Package Name\/Shared_Pref,\/data\/data\/Package Name\/files, \/data\/data\/Package Name\/database ",
    "type" : "1",
    "optionA" : "\/data\/data\/Package Name\/files,\/data\/data\/Package Name\/Shared_Pref, \/data\/data\/Package Name\/database ",
    "question" : "Preference，File， DataBase这三种存储方式的存储路径分别对应的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3997f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "standard、singleTop、singleTask、singleInstance",
    "optionC" : "singleTask、singleInstance",
    "optionAnswer" : "D",
    "answer" : "Activity的启动模式有四种：1、standard、2、singleTop、3、singleTask、4、singleInstance",
    "optionB" : "singleTop、singleTask",
    "type" : "1",
    "optionA" : "standard、singleTop",
    "question" : "Activty和Task的启动模式有哪些？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39997",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "动态注册不是常驻型广播注册方式，静态注册是常驻型广播方式",
    "optionC" : "动态注册不是常驻型广播注册方式，静态注册是常驻型广播方式",
    "optionAnswer" : "A",
    "answer" : "广播注册有两种方式1.静态注册（在清单文件中声明）添加代码如下：  <receive android:name=\".IncomingSMSReceiver \" > <intent-filter>     <action android:name=\"android.provider.Telephony.SMS_RECEIVED\") <intent-filter> <receiver>静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。  2.动态注册（使用代码进行注册）代码如下: IntentFilter filter =  new  IntentFilter(\"android.provider.Telephony.SMS_RECEIVED\"); IncomingSMSReceiver receiver = new IncomgSMSReceiver(); registerReceiver(receiver.filter); 动态注册不是常驻型广播，也就是说广播跟随程序的生命周期。",
    "optionB" : "动态注册不是常驻型广播注册方式，静态注册是常驻型广播方式",
    "type" : "1",
    "optionA" : "动态注册不是常驻型广播注册方式，静态注册是常驻型广播方式",
    "question" : "下列关于广播注册正确的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3993d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "putString()",
    "optionC" : "commit()",
    "optionAnswer" : "A",
    "answer" : "\/\/实例化SharedPreferences对象（第一步） \nSharedPreferences mySharedPreferences= getSharedPreferences(\"test\", \nActivity.MODE_PRIVATE);  \/\/实例化SharedPreferences.Editor对象（第二步）(android.content.SharedPreferences.Editor\n)\nSharedPreferences.Editor editor = mySharedPreferences.edit();  \/\/用putString的方法保存数据 \neditor.putString(\"name\", \"Karl\"); \neditor.putString(\"habit\", \"sleep\");  \/\/提交当前数据 \neditor.commit(); ",
    "optionB" : "save()",
    "type" : "1",
    "optionA" : "edit()",
    "question" : "对于一个已经存在的SharedPreferences对象setting,想向其中存入一个字符串\"person\",setting应该先调用什么方法( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e39934",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "void",
    "optionC" : "String",
    "optionAnswer" : "A",
    "answer" : "基本数据类型有： byte \nshot\nint \nlong\nfloat\ndouble\nchar \nboolean  ",
    "optionB" : "string",
    "type" : "1",
    "optionA" : "byte",
    "question" : "下面哪些属于java的基本数据类型？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399cd",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "0",
    "optionC" : "1",
    "optionAnswer" : "D",
    "answer" : "i是一个整型静态的变量，没有赋初值，默认为0",
    "optionB" : "null ",
    "type" : "1",
    "optionA" : "有错误，变量i没有初始化。",
    "question" : "于下列程序段的输出结果，说法正确的是：( )\npublic class MyClass{\n　　static int i;\n　　public static void main(Stringargv[]){\n　　    System.out.println(i);\n　　}\n}"
  },
  {
    "ID" : "55bb36a7e4b0809382e3995a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "你可以通过Looper.myQueue()从当前线程中获取MessageQueue。",
    "optionC" : "这是一个包含message列表的底层类。Looper负责分发这些message。Messages并不是直接加到一个MessageQueue中，而是通过MessageQueue.IdleHandler关联到Looper。",
    "optionAnswer" : "B",
    "answer" : "Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象提供额外的两个int域和一个Object域，这可以让你在大多数情况下不用作分配的动作。  尽管Message的构造函数是public的，但是获取Message实例的最好方法是调用 Message.obtain(),或者Handler.obtainMessage()方法，这些方法会从回收对象池中获取一个。这是一个包含message列表的底层类。Looper负责分发这些message。Messages并不是直接加到一个MessageQueue中，而是通过MessageQueue.IdleHandler关联到Looper。 你可以通过Looper.myQueue()从当前线程中获取MessageQueue。",
    "optionB" : " 尽管Message的构造函数是public的，但是获取Message实例的最好方法是调用 Message.obtain(),或者Handler.obtainMessage()方法，这些方法会new一个获取。",
    "type" : "1",
    "optionA" : "Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象提供额外的两个int域和一个Object域，这可以让你在大多数情况下不用作分配的动作。",
    "question" : "有关Message、MessageQueue的说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b0",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "处理一个应用程序整体性的工作 ",
    "optionC" : "可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带",
    "optionAnswer" : "C",
    "answer" : "意图和意图过滤器Intents and Intent Filters一个应用程序的三个核心组件-活动，服务和广播接收器是通过消息即意图（Intents）来激活的。Intent息传送是相同或不同应用中组件运行时晚绑定的一种机制。意图本身，一个意图对象，是一个包含被执行操作抽象描述的被动的数据结构-或者，对于广播而言，是某件已经发生并被声明的事情的描述。存在不同的机制来传送意图到每种组件中：\n? 一个意图对象是传递给Context.startActivity()或者Activity.startActivityForResult()来启动一个活动或者让一个存在的活动去做某些新的事情。\n? 一个意图对象是传递给Context.startService()来发起一个服务或者递交新的指令给运行中的服务。类似的，一个意图能被传递给Context.bindService() 来在调用组件和一个目标服务之间建立连接。作为一个可选项，它可以发起这个服务如果还没运行的话。\n? 传递给任意广播方法(例如Context.sendBroadcast(),Context.sendOrderedBroadcast(), 或者Context.sendStickyBroadcast()）的意图对象被传递给所有感兴趣的广播接收者。许多种广播产生于系统代码。 ",
    "optionB" : "是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失",
    "type" : "1",
    "optionA" : "实现应用程序间的数据共享",
    "question" : "android 中下列属于Intent的作用的是()"
  },
  {
    "ID" : "55bb36a7e4b0809382e39955",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Log.d的输出颜色是黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思，平时使用就是Log.v(\"\",\"\");",
    "optionC" : "Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息",
    "optionAnswer" : "D",
    "answer" : "android.util.Log常用的方法有以下5个：Log.v() Log.d() Log.i() Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG,INFO, WARN，ERROR。\n1、Log.v 的调试颜色为黑色的，任何消息都会输出，这里的v代表verbose啰嗦的意思，平时使用就是Log.v(\"\",\"\");\n2、Log.d的输出颜色是蓝色的，仅输出debug调试的意思，但他会输出上层的信息，过滤起来可以通过DDMS的Logcat标签来选择.\n3、Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息\n4、Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。\n5、Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。",
    "optionB" : "Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。",
    "type" : "1",
    "optionA" : "Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。",
    "question" : "下列关于log打印的说明有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39938",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Sqlite数据库存储",
    "optionC" : "CoreData存储",
    "optionAnswer" : "C",
    "answer" : "1）SQLite数据库存储结构化数据。\n2）文件存储：分为内部存储和外部存储(SD卡)两种存储方式。\n3）SharedPreferences共享参数，键值对形式存储。\n4）网络存储\n5）ContentProvider存储",
    "optionB" : "SharedPreferences共享参数",
    "type" : "1",
    "optionA" : "ContentProvider存储",
    "question" : "下列不属于Android的数据存储方式的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39971",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "绝对布局（AbsoluteLayout）是指一个ViewGroup以绝对方式显示它的子视图（View）元素，即以坐标的方式来定位在屏幕上位置。这种布局方式很好理解，在布局文件中编程设置View的坐标，从而绝对地定位。",
    "optionC" : "TableLayout:表格布局，控件与控件之间处于上下叠加的状态。",
    "optionAnswer" : "C",
    "answer" : "1）RelativeLayout:相对布局，可以根据相对位置来调整控件的位置。推荐使用相对布局，更利于屏幕的自适应。\n2）LinearLayout:线性布局，控件之间的水平排列或者垂直排列。但是如果要想构建复杂布局，要进行多层的LinearLayout布局嵌套，但是这样会运行布局载入效率。\n3）FrameLayout:帧布局，控件与控件之间处于上下叠加的状态。\n4）绝对布局（AbsoluteLayout）是指一个ViewGroup以绝对方式显示它的子视图（View）元素，即以坐标的方式来定位在屏幕上位置。这种布局方式很好理解，在布局文件中编程设置View的坐标，从而绝对地定位。\n5）TableLayout，表格布局采用行列形式管理UI组件，TableLayout不需要明确地声明有多少行和列，而是通过添加TableRow、其它组件来控制表格的行数、列数。 ",
    "optionB" : "LinearLayout:线性布局，控件之间的水平排列或者垂直排列。但是如果要想构建复杂布局，要进行多层的LinearLayout布局嵌套，但是这样会运行布局载入效率。",
    "type" : "1",
    "optionA" : "RelativeLayout:相对布局，可以根据相对位置来调整控件的位置。推荐使用相对布局，更利于屏幕的自适应。",
    "question" : "控件布局的方式说法不正确的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3991b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "1)安装和下载Cygwin下载 Android NDK\n2)将动态链接库复制到java工程在java工程中调用运行java工程即可\n3)使用C\/C++实现本地方法\n4)JNI生成动态链接库.so文件\n5)在ndk项目中JNI接口的设计",
    "optionC" : "1)安装和下载Cygwin下载 Android NDK \n2)使用C\/C++实现本地方法 \n3)在ndk项目中JNI接口的设计 \n4)JNI生成动态链接库.so文件 \n5)将动态链接库复制到java工程在java工程中调用运行java工程即可",
    "optionAnswer" : "A",
    "answer" : "1)安装和下载Cygwin下载 Android NDK \n2)在ndk项目中JNI接口的设计 \n3)使用C\/C++实现本地方法 \n4)JNI生成动态链接库.so文件 \n5)将动态链接库复制到java工程在java工程中调用运行java工程即可 ",
    "optionB" : "1)在ndk项目中JNI接口的设计 \n2)安装和下载Cygwin下载 Android NDK \n3)使用C\/C++实现本地方法 \n4)JNI生成动态链接库.so文件 \n5)将动态链接库复制到java工程在java工程中调用运行java工程即可",
    "type" : "1",
    "optionA" : "1)安装和下载Cygwin下载 Android NDK \n2)在ndk项目中JNI接口的设计 \n3)使用C\/C++实现本地方法 \n4)JNI生成动态链接库.so文件 \n5)将动态链接库复制到java工程在java工程中调用运行java工程即可",
    "question" : "在android中，请简述jni的调用过程"
  },
  {
    "ID" : "55bb36a8e4b0809382e3999b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "放置一些与UI相应的布局文件，都是xml文件",
    "optionC" : "放置字符串，颜色，数组等常量数据",
    "optionAnswer" : "B",
    "answer" : "因为系统在编译的时候不会编译assets下的资源文件，所以我们不能通过R.XXX.ID的方式访问它们。用于存放应用程序中使用的外部资源文件，程序可以通过I\/O流对目录中的文件进行读写，存放在此目录下的文件都会被打包到发布包中。",
    "optionB" : "主要放置多媒体等数据文件",
    "type" : "1",
    "optionA" : "放置应用到的图片资源。",
    "question" : "Android项目工程下面的assets目录的作用是什么"
  },
  {
    "ID" : "55bb36a8e4b0809382e39999",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "其它项不正确",
    "optionC" : "发送短信",
    "optionAnswer" : "B",
    "answer" : "Intent.ACTION_VIEW\nString android.intent.action.VIEW\n用于显示用户的数据。比较通用，会根据用户的数据类型打开相应的Activity。\n比如 tel:13400010001打开拨号程序，http:\/\/www.g.cn则会打开浏览器等。\n代码：\nUri uri = Uri.parse(\"http:\/\/www.google.com\"); \/\/浏览器(网址必须带http) \/\/Uri uri =Uri.parse(\"tel:1232333\");              \/\/拨号程序 \/\/Uri uri=Uri.parse(\"geo:39.899533,116.036476\");  \/\/打开地图定位 Intent it  = new Intent(Intent.ACTION_VIEW,uri);  \/\/Intent.ACTION_VIEW不带引号\nstartActivity(it);",
    "optionB" : "在浏览器浏览这个网址",
    "type" : "1",
    "optionA" : "发送Email",
    "question" : "Intent intent = new Intent(Intent.ACTION.VIEW,Uri.parse(\"http:\/\/mail.google.com\"))这句话作用陈述正确的是( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e3995c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "NDK将是Android平台支持C开发的开端",
    "optionC" : "使用“java+c”的开发方式终于转正，成为官方支持的开发方式",
    "optionAnswer" : "A",
    "answer" : "NDK是一系列工具的集合，NDK提供了一份稳定、功能有限的API头文件声明",
    "optionB" : "NDK提供了一份稳定、功能有限的API",
    "type" : "1",
    "optionA" : "NDK是一系列工具的集合",
    "question" : "下列对android NDK的理解正确的是"
  },
  {
    "ID" : "55bb36a7e4b0809382e3994d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "long double",
    "optionC" : "long float",
    "optionAnswer" : "B",
    "answer" : "整数默认int;带小数的默认是double",
    "optionB" : "int double",
    "type" : "1",
    "optionA" : "int float",
    "question" : "在基本JAVA类型中，如果不明确指定，整数型的默认是什么类型？带小数的默认是什么类型？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3992e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "service：Service是能在后台运行任意时间的组件。",
    "optionC" : "instrumentation：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行",
    "optionAnswer" : "C",
    "answer" : "application：包含package中application级别组件声明的根节点。\nactivity：Activity是用来与用户交互的主要工具。\nreceiver：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行。\nservice：Service是能在后台运行任意时间的组件。",
    "optionB" : "activity：Activity是用来与用户交互的主要工具。",
    "type" : "1",
    "optionA" : "application：包含package中application级别组件声明的根节点。",
    "question" : "Manifest.xml文件中描述信息有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399ae",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Java使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作",
    "optionC" : "finally在异常处理时提供 finally 块来执行任何清除操作。",
    "optionAnswer" : "B ",
    "answer" : "final修饰的方法不能被覆盖\nfinal修饰的字段为常量\nfinal修饰的类不能被继承",
    "optionB" : "如果一个方法被声明为final，可以被覆盖",
    "type" : "1",
    "optionA" : "如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承",
    "question" : "下面有关final, finally, finalize的区别描述错误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3991a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "“标记-清扫”：每当它找到一个存活对象，就会给对象一个标记。这个过程中不会回收任何对象。只有全部标记完成时，没有标记的对象将被释放，不会发生任何复制工作，所以剩下的堆空间是不连续的，然后垃圾回收器重新整理剩余的对象，使它们是连续排列的。",
    "optionC" : "“标记-清扫”：当对象被复制到新堆上时，它们是一个挨着一个的，所以新堆保持紧凑排列（这也是为什么分配对象的时候“堆指针”只管依次往前移动）。然后就可以按前述方法简单、直接地分配内存了。这将导致大量内存复制行为，内存分配是以较大的“块”为单位的。有了块之后，垃圾回收器就可以不往堆里拷贝对象了，直接就可以往废弃的块里拷贝对象了。   ",
    "optionAnswer" : "C",
    "answer" : "  Java有两种方式： 一种是“停止-复制”：理论上是先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全是垃圾。当对象被复制到新堆上时，它们是一个挨着一个的，所以新堆保持紧凑排列（这也是为什么分配对象的时候“堆指针”只管依次往前移动）。然后就可以按前述方法简单、直接地分配内存了。这将导致大量内存复制行为，内存分配是以较大的“块”为单位的。有了块之后，垃圾回收器就可以不往堆里拷贝对象了，直接就可以往废弃的块里拷贝对象了。            另一种是“标记-清扫”：它的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象一个标记。这个过程中不会回收任何对象。只有全部标记完成时，没有标记的对象将被释放，不会发生任何复制工作，所以剩下的堆空间是不连续的，然后垃圾回收器重新整理剩余的对象，使它们是连续排列的。",
    "optionB" : "“标记-清扫”：它的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。",
    "type" : "1",
    "optionA" : "“停止-复制”：理论上是先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全是垃圾。",
    "question" : "Java虚拟机采用一种“自适应”的垃圾回收技术说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a1",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "不是长久驻留在内存，数据不是持久的，事件过后，若没有保存数据，数据就会    消失",
    "optionC" : "整个文档调入内存，浪费时间和空间",
    "optionAnswer" : "B",
    "answer" : "SAX(Simple API for XML)解析器是一种基于事件的解析器，事件驱动的流式解析方式是，从文件的开始顺序解析到文档的结束，不可暂停或倒退。它的核心是事件处理模式，主要是围绕着事件源以及事件处理器来工作的。当事件源产生事件后，调用事件处理器相应的处理方法，一个事件就可以得到处理。在事件源调用事件处理器中特定方法的时候，还要传递给事件处理器相应事件的状态信息，这样事件处理器才能够根据提供的事件信息来决定自己的行为。\nSAX的工作原理：简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。",
    "optionB" : "不用事先调入整个文档，占用资源少",
    "type" : "1",
    "optionA" : "将整个文档树在内存中，便于操作，支持删除，修改，重新排列等多种功能",
    "question" : "下列属于SAX解析xml文件的优点的是（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39910",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " onCreate() -> onStart() -> onResume()–> onFreeze() –> onPause()",
    "optionC" : " onCreate() -> onStart() -> onResume() –> onPause()–> onFreeze()",
    "optionAnswer" : "D",
    "answer" : "设备进入睡眠状态，Activity调用顺序是onCreate() -> onStart() -> onResume()–> onFreeze() –> onPause()",
    "optionB" : " onCreate() -> onStart()–> onFreeze() –> onPause() -> onResume()",
    "type" : "1",
    "optionA" : " onCreate() -> onStart()–> onFreeze() -> onResume() –> onPause()",
    "question" : "设备进入睡眠状态，Activity调用顺序是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3992f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "string",
    "optionC" : "char",
    "optionAnswer" : "A",
    "answer" : "首先说一下，D选项的String应该首字母大写，小写是错的\njava中除了基本数据类型都是引用数据类型\njava中的基本数据类型如下\nbyte \nshot\nint \nlong\nfloat\ndouble\nchar \nboolean\n除此之外都是引用类型",
    "optionB" : "byte",
    "type" : "1",
    "optionA" : "Array",
    "question" : "下面属于java引用类型的有？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39936",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "串行并行多版本不一致\n2.3之前为并行，3.0之后改为串行，但是可以通过executeOnExecutor(Executor)实现并行处理任务。",
    "optionC" : "结果丢失\n在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。\n",
    "optionAnswer" : "D",
    "answer" : "\nAsyncTask使用起来比较轻量，但是其自身也存在一些问题。主要表现在\n\n1.cancel方法实现不是很好.\n如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义\n\n2.内存泄露问题\n还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。\n\n3.结果丢失\n另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。\n\n4.串行并行多版本不一致\n1.6之前为串行，1.6到2.3为并行，3.0之后又改回为串行，但是可以通过executeOnExecutor(Executor)实现并行处理任务。",
    "optionB" : "内存泄露问题\n一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。",
    "type" : "1",
    "optionA" : "cancel方法实现不是很好.\n如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义\n",
    "question" : " asyncTask有不足之处描述不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3996c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Result",
    "optionC" : "Progress",
    "optionAnswer" : "B",
    "answer" : "AsyncTask是抽象类.AsyncTask定义了三种泛型类型 Params，Progress和Result。\nParams 启动任务执行的输入参数，比如HTTP请求的URL。 一般用String类型；\nProgress 后台任务执行的百分比。 一般用Integer类型；\nResult 后台执行任务最终返回的结果，一般用byte[]或者String。",
    "optionB" : "int",
    "type" : "1",
    "optionA" : "Params",
    "question" : "AsyncTask是抽象类.AsyncTask定义了三种泛型类型不包括（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39947",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Hashtable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的 方法实现同步，而 HashMap 就必须为之提供外同步。Hashtable采用的 hash\/rehash 算法而HashMap不是。 ",
    "optionC" : "HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsvalue 和 containsKey。因为 contains 方法容易让人引起误解。 Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。",
    "optionAnswer" : "D",
    "answer" : "HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），他们都完成了 Map 接口，主要区别在于 HashMap 允许空（null）键值（key）,由于非线程安全，效率上可能高于 Hashtable。 HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 \nHashMap 把 Hashtable 的 contains 方法去掉了，改成 containsvalue 和 containsKey。因为 contains 方法容易让人引起误解。 Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 最大的不同是，Hashtable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的 方法实现同步，而 HashMap 就必须为之提供外同步。\nHashtable 和 HashMap 采用的 hash\/rehash 算法都大概一样，所以性能不会有很大的差异。",
    "optionB" : " HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 ",
    "type" : "1",
    "optionA" : "HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），他们都完成了 Map 接口，主要区别在于 HashMap 允许空（null）键值（key）,由于非线程安全，效率上可能高于 Hashtable。",
    "question" : "HashMap 和 Hashtable 的区别不对的是？"
  },
  {
    "answer" : "activiey，service，broadcast和contentprovide",
    "ID" : "55f2e52be4b0152a611433e9",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "android 的四大组件是（）。"
  },
  {
    "ID" : "55bb36a8e4b0809382e3998b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "如果XML文档体积比较大时,将文档读入内存是消耗很少系统资源的.",
    "optionC" : "DOM解析器的API在使用上也相对比较简单.",
    "optionAnswer" : "D",
    "answer" : "优点:\n1.XML树在内存中完整存储,因此可以直接修改其数据和结构. \n2.可以通过该解析器随时访问XML树中的任何一个节点. \n3.DOM解析器的API在使用上也相对比较简单.",
    "optionB" : "可以通过该解析器随时访问XML树中的任何一个节点.",
    "type" : "1",
    "optionA" : "XML树在内存中完整存储,因此可以直接修改其数据和结构.",
    "question" : "DOM解析的优点说法不对的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39935",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "无法计算",
    "optionC" : "int  ",
    "optionAnswer" : "C",
    "answer" : "运算的时候低级像高级自动转换",
    "optionB" : "char ",
    "type" : "1",
    "optionA" : "byte",
    "question" : "一个int类型的常量和一个byte的常量做加法，结果是（ ）类型"
  },
  {
    "ID" : "55bb36a7e4b0809382e39926",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Activity，Service，Broadcast和Content Provider",
    "optionC" : "Activity，Service，Broadcast Provider和Content Receiver",
    "optionAnswer" : "A",
    "answer" : "android 的四大组件是Activiey，Service，Broadcast Receiver和Content Provider",
    "optionB" : "Activity，Service，Broadcast Receiver和Content",
    "type" : "1",
    "optionA" : "Activity，Service，Broadcast Receiver和Content Provider",
    "question" : "android 的四大组件是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3994a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "if( ( keyState | LEFT_PRESSED ) != 0 )",
    "optionC" : "if( ( keyState & LEFT_PRESSED ) != 0 ) ",
    "optionAnswer" : "C",
    "answer" : "它们都是逻辑运算符。 &&(逻辑与) 、 ||(逻辑或) ：\n作用：进行多项比较并将结果组合为单一的布尔值。同时&&(逻辑与) 和 ||(逻辑或) 又是短路操作符，即左边的表达式为假时，将不再执行右边的表达式。\n规律： &&(逻辑与) ，全真才为真 ； ||(逻辑或)，有真则为真。\n &&(逻辑与)：两边必须是boolean，只要左边为假，右边的就不会在继续执行.\n同理砍断 ||(逻辑或)与(&,&&)和或(|,||)的区别 \n1.1使用与操作的时候，要求前后几个表达式的内容都是true,最终结果才是true，如果有一个是false，则最终结果就是false； \n  1.2使用或操作的时候，要求前后几个表达式只要有一个true，则最终结果就是true，如果全都是false，则最终结果才是false; \n\n2.与(&)和短路与(&&)的区别以及或(|)和短路或(||)的区别 \n\n这点在初学者中，疑惑的人会比较多 \n先说与操作：既然与操作要求前后几个表达式的内容都是true的时候最终结果才是true，如果使用短路与，则只要第一个结果是false，则整体结果肯定是false,但是程序在这个时候是不会继续执行下去的，相反，如果不是短路与，即使第一个结果是false，程序依然会执行其他的结果下去，虽然最终结果都是一样",
    "optionB" : "if( ( keyState || LEFT_PRESSED ) != 0 )",
    "type" : "1",
    "optionA" : "if( ( keyState && LEFT_PRESSED ) != 0 )",
    "question" : "下面是获取按键键值并进行判断的程序代码(其它程序代码全部省略),判断语法正确的是（  ）"
  },
  {
    "answer" : "startservice和bindservice",
    "ID" : "55f2e52be4b0152a611433ea",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "android 中service的实现方法是：（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39907",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "5",
    "optionC" : "4",
    "optionAnswer" : "C",
    "answer" : "在android里，有4种activity的启动模式，分别为： \n“standard” (默认) \n“singleTop” \n“singleTask” \n“singleInstance”",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "2",
    "question" : "在android里，有几种activity的启动模式？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3990f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Service的onCreate()和onStartCommand()方法启动成功后",
    "optionC" : "Service的onCreate()方法和onBind()方法执行成功后",
    "optionAnswer" : "B",
    "answer" : "必须是返回非空IBinder对像",
    "optionB" : "bindService()方法执行成功同时onBind()方法返回非空IBinder对象",
    "type" : "1",
    "optionA" : " bindService()方法执行成功后",
    "question" : "关于ServiceConnection接口的onServiceConnected()方法的触发条件描述正确的是"
  },
  {
    "answer" : "1)安装和下载Cygwin，下载 Android NDK\n2)在ndk项目中JNI接口的设计\n3)使用C\/C++实现本地方法\n4)JNI生成动态链接库.so文件\n5)将动态链接库复制到java工程，在java工程中调用，运行java工程即可",
    "ID" : "55f2e52be4b0152a611433ec",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "在android中，请简述jni的调用过程"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a5",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "大大减少代码量",
    "optionC" : "代码重复少",
    "optionAnswer" : "D",
    "answer" : "采用MVC即是分层模式来设计web应用程序，可以清晰发现问题，增强可维护性，而且面向接口的编程使程序的可扩展性增强，通过MVC统一的处理请求，可以减少代码的重复，但是代码量，这个不好说",
    "optionB" : "可扩展性强",
    "type" : "1",
    "optionA" : "可维护行强",
    "question" : "使用mvc模式设计的web应用程序具有以下优点,除了？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3994b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "provider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。",
    "optionC" : "service：Service是能在后台运行任意时间的组件。",
    "optionAnswer" : "A",
    "answer" : "manifest：根节点，描述了package中所有的内容。\nuses-permission：请求你的package正常运作所需赋予的安全许可。\nservice：Service是能在后台运行任意时间的组件。\nprovider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。",
    "optionB" : "uses-permission：请求你的package正常运作所需赋予的安全许可。",
    "type" : "1",
    "optionA" : "instrumentation：根节点，描述了package中所有的内容。",
    "question" : "Manifest.xml文件中描述信息有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c3",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "当自定义显示时长时,比如传入30,程序会抛出异常",
    "optionC" : "传入30时,提示会显示30秒钟",
    "optionAnswer" : "B",
    "answer" : "Toast的默认显示时间有两个，分别为Toast.LENGTH_SHORT和Toast.LENGTH_LONG",
    "optionB" : "可以自定义显示时长",
    "type" : "1",
    "optionA" : "显示时长只有2种设置",
    "question" : "\n使用Toast提示时,关于提示时长,下面说法正确的是( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e3991d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "1.创建一个ServerSocket，用于监听客户端Socket的连接请求\n2.每当接受到客户端Socket的请求，服务器端也对应产生一个Socket\n3.采用循环不断接受来自客户端的请求",
    "optionC" : "1.每当接受到客户端Socket的请求，服务器端也对应产生一个Socket\n2.采用循环不断接受来自客户端的请求\n3.创建一个ServerSocket，用于监听客户端Socket的连接请求",
    "optionAnswer" : "B",
    "answer" : "1.创建一个ServerSocket，用于监听客户端Socket的连接请求\n2.采用循环不断接受来自客户端的请求\n3.每当接受到客户端Socket的请求，服务器端也对应产生一个Socket",
    "optionB" : "1.创建一个ServerSocket，用于监听客户端Socket的连接请求\n2.采用循环不断接受来自客户端的请求\n3.每当接受到客户端Socket的请求，服务器端也对应产生一个Socket",
    "type" : "1",
    "optionA" : "1.采用循环不断接受来自客户端的请求\n2.创建一个ServerSocket，用于监听客户端Socket的连接请求\n3.每当接受到客户端Socket的请求，服务器端也对应产生一个Socket",
    "question" : "Socket通信编程，服务器端编程步骤？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39951",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "JSONException：json中用到的异常 ",
    "optionC" : "JSONArray：它代表一组有序的数值。将其转换为String输出(toString)所表现的形式是用方括号包裹，数值以逗号”,”分隔（例如：     [value1,value2,value3]，大家可以亲自利用简短的代码更加直观的了解其格式）。",
    "optionAnswer" : "B",
    "answer" : "android的json解析部分都在包org.json下，主要有以下几个类： \nJSONObject：可以看作是一个json对象,这是系统中有关JSON定义的基本单元，其包含一对儿(Key\/Value)数值。它对外部(External：   应用toString()方法输出的数值)调用的响应体现为一个标准的字符串（例如：{\"JSON\": \"Hello, World\"}，最外被大括号包裹，其中的Key和Value被冒号\":\"分隔）。其对于内部(Internal)行为的操作格式略微，例如：初始化一个JSONObject实例，引用内部的put()方法添加数值：new JSONObject().put(\"JSON\", \"Hello, World!\")，在Key和Value之间是以逗号\",\"分隔。Value的类型包括：Boolean、JSONArray、JSONObject、Number、String或者默认值JSONObject.NULL object 。\n\nJSONStringer：json文本构建类 ，根据官方的解释，这个类可以帮助快速和便捷的创建JSON text。其最大的优点在于可以减少由于 格式的错误导致程序异常，引用这个类可以自动严格按照JSON语法规则（syntax rules）创建JSON text。每个JSONStringer实体只能对应创建一个JSON text。。其最大的优点在于可以减少由于格式的错误导致程序异常，引用这个类可以自动严格按照JSON语法规则（syntax rules）创建JSON text。每个JSONStringer实体只能对应创建一个JSON text。\n\nJSONArray：它代表一组有序的数值。将其转换为String输出(toString)所表现的形式是用方括号包裹，数值以逗号”,”分隔（例如：     [value1,value2,value3]，大家可以亲自利用简短的代码更加直观的了解其格式）。这个类的内部同样具有查询行为，     get()和opt()两种方法都可以通过index索引返回指定的数值，put()方法用来添加或者替换数值。同样这个类的value类型可以包括：Boolean、JSONArray、JSONObject、Number、String或者默认值JSONObject.NULL object。\n\nJSONTokener：json解析类 \nJSONException：json中用到的异常",
    "optionB" : "JSONStringer：json文本构建类 ，根据官方的解释，这个类可以帮助快速和便捷的创建JSON text。这个类的内部同样具有查询行为，     get()和opt()两种方法都可以通过index索引返回指定的数值，put()方法用来添加或者替换数值。",
    "type" : "1",
    "optionA" : "JSONObject：可以看作是一个json对象,这是系统中有关JSON定义的基本单元，其包含一对儿(Key\/Value)数值。",
    "question" : "下列有关于JSON的解析类描述有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39964",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onCreate() -> onStart() -> onResume()-> onFreeze() -> onPause() -> onStop() -> onRestart() ->onResume() -> onStart()… ",
    "optionC" : "onCreate() -> onStart() -> onResume()-> onFreeze() -> onStop() -> onRestart() -> onPause() -> onStart()->onResume() … ",
    "optionAnswer" : "A ",
    "answer" : "父Activity启动子Activity，子Actvity退出，父Activity调用顺序是onCreate() -> onStart() -> onResume()-> onFreeze() -> onPause() -> onStop() -> onRestart() -> onStart()->onResume() … ",
    "optionB" : "onCreate() -> onStart() -> onResume()-> onFreeze()-> onStop() -> onPause()  -> onRestart() -> onStart()->onResume() … ",
    "type" : "1",
    "optionA" : "onCreate() -> onStart() -> onResume()-> onFreeze() -> onPause() -> onStop() -> onRestart() -> onStart()->onResume() … ",
    "question" : "父Activity启动子Activity，子Actvity退出，父Activity调用顺序是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39982",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " string c = new string(new char[] { 'h', 'e', 'l', 'l', 'o' });\n            string d = new string(new char[] { 'h', 'e', 'l', 'l', 'o' });\n                      Console.WriteLine(c.Equals(d));结果为false",
    "optionC" : "  string c = new string(new char[] { 'h', 'e', 'l', 'l', 'o' });\n            string d = new string(new char[] { 'h', 'e', 'l', 'l', 'o' });\n            Console.WriteLine(c == d);结果为false",
    "optionAnswer" : "B",
    "answer" : "”==“操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是\n否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用“==”操作符；equals 方法是用于比较两个独立对象的内容是否相同",
    "optionB" : "”==“操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是\n否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用“==”操作符；equals 方法是用于比较两个独立对象的内容是否相同",
    "type" : "1",
    "optionA" : "String a=new String(\"foo\");\nString b=new String(\"foo\");结果为true",
    "question" : "有关“==”和equals方法的说法正确的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39958",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Layout.xml",
    "optionC" : "AndroidMainifest.xml",
    "optionAnswer" : "C",
    "answer" : "<activity\n            android:name=\"com.x.x.xActivity\"\n            android:configChanges=\"keyboardHidden|orientation\"\n            android:screenOrientation=\"portrait\"\n            android:theme=\"@style\/x\" \/>",
    "optionB" : "String.xml",
    "type" : "1",
    "optionA" : "Main.xml",
    "question" : "在Android工程中新建了一个Activity 需要在哪个xml文件中声明一下？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3994e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Client端实现IPC接口，Servier端调用IPC接口本地代理。",
    "optionC" : "通过定义AIDL接口文件来定义IPC接口。",
    "optionAnswer" : "D",
    "answer" : "IPC是内部进程通信的简称， 是共享\"命名管道\"的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C\/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。",
    "optionB" : "Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C\/S模式的访问。",
    "type" : "1",
    "optionA" : "IPC是内部进程通信的简称， 是共享\"命名管道\"的资源。",
    "question" : "Android的IPC（进程间通信）机制说法错误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399ac",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "前台进程>可见进程>服务进程>后台进程>空进程",
    "optionC" : "前台进程>可见进程>空进程>服务进程>后台进程",
    "optionAnswer" : "D",
    "answer" : "Android进程重要程度由高到低的是：前台进程>可见进程>服务进程>后台进程>空进程",
    "optionB" : "前台进程>可见进程>后台进程>服务进程>空进程",
    "type" : "1",
    "optionA" : "前台进程>服务进程>可见进程>后台进程>空进程",
    "question" : "Android进程重要程度由高到低的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3991f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "12，-12",
    "optionC" : "12，-11 ",
    "optionAnswer" : "C",
    "answer" : "如果是正数，小数点后一位>=5，则值为整数部分+1，如Math.round(11.6)=12\n                如果是负数，小数点后一位>5，则值为整数部分-1，如Math.round(-11.6)=-12\n                如果是正数，小数点后一位<5，则值为整数部分，如Math.round(11.4)=11\n                如果是负数，小数点后一个<=5，则值为整数部分，如Math.round(-11.4)=-11",
    "optionB" : "11，-12   ",
    "type" : "1",
    "optionA" : "11，-11 ",
    "question" : "Math.round(11.5)和Math.round(-11.5)分别等于多少？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3993b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。",
    "optionC" : "pt: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 ",
    "optionAnswer" : "C",
    "answer" : "dip: device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。 \npx: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 \npt: point，是一个标准的长度单位，1pt＝1\/72英寸，用于印刷业，非常简单易用； \nsp: scaled pixels(放大像素). 主要用于字体显示best for textsize。",
    "optionB" : "px: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 ",
    "type" : "1",
    "optionA" : "dip: device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。",
    "question" : "px、dp、dip、dpi、sp的说法有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c7",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "分页",
    "optionC" : "段页",
    "optionAnswer" : "D",
    "answer" : "嵌入式操作系统包括：页式、段式、段页",
    "optionB" : "段式",
    "type" : "1",
    "optionA" : "页式",
    "question" : "不是嵌入式操作系统内存管理的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e3993a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "DDMS将搭建起IDE与测试终端(Emulator或者connected device)的链接,他们应用各自独立的端口监听调试信息,DDMS可以实时监测到测试终端的连接情况.当有新的测试终端连接后,DDMS将捕捉到终端的ID,并通过adb建立调试器,从而实现发送指令到测试终端的目的;",
    "optionC" : "DDMS是一个程序执行查看器，在里面无法看见线程和堆栈等信息，TraceView是程序性能分析器 。",
    "optionAnswer" : "C",
    "answer" : "DDMS 的全称是Dalvik Debug Monitor Service，是 Android 开发环境中的Dalvik虚拟机调试监控服务。它为我们提供例如：为测试设备截屏，针对特定的进程查看正在运行的线程以及堆信息、Logcat、广播状态信息、模拟电话呼叫、接收SMS、虚拟地理坐标等等。DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。DDMS将搭建起IDE与测试终端(Emulator或者connected device)的链接,他们应用各自独立的端口监听调试信息,DDMS可以实时监测到测试终端的连接情况.当有新的测试终端连接后,DDMS将捕捉到终端的ID,并通过adb建立调试器,从而实现发送指令到测试终端的目的;",
    "optionB" : "DDMS为我们提供例如：为测试设备截屏，针对特定的进程查看正在运行的线程以及堆信息、Logcat、广播状态信息、模拟电话呼叫、接收SMS、虚拟地理坐标等等。",
    "type" : "1",
    "optionA" : "DDMS 的全称是Dalvik Debug Monitor Service，是 Android 开发环境中的Dalvik虚拟机调试监控服务。",
    "question" : "DDMS的说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3997b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "EF就是作存储并和手机通讯用的",
    "optionC" : "sim本身是无法拥有自己的操作系统",
    "optionAnswer" : "C",
    "answer" : "sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的",
    "optionB" : "sim卡主要是为了和手机通讯",
    "type" : "1",
    "optionA" : "sim卡的文件系统有自己规范",
    "question" : "下列有关sim卡的EF文件说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a4",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "不受任何限制的开发商",
    "optionC" : "丰富的硬件选择",
    "optionAnswer" : "B",
    "answer" : "Android系统的五大优势：1、开放性  2、挣脱运营商的束缚  3、丰富的硬件选择  4、不受任何限制的开发商  5、无缝结合的Google应用",
    "optionB" : "安全",
    "type" : "1",
    "optionA" : "开放性",
    "question" : "以下哪个不是Android系统的优势？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39929",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Android的进程处理器现在会尽可能的不kill掉你",
    "optionC" : "会传参数",
    "optionAnswer" : "C",
    "answer" : "IntentService的优点：\n1、Activity的进程，当处理Intent的时候，会产生一个对应的Service \n2、Android的进程处理器现在会尽可能的不kill掉你 \n3、非常容易使用",
    "optionB" : "非常容易使用",
    "type" : "1",
    "optionA" : "Activity的进程，当处理Intent的时候，会产生一个对应的Service",
    "question" : "以下不是IntentService的优点的是？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e3996a",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onResume（）",
    "optionC" : "onCreate（）",
    "optionAnswer" : "B ",
    "answer" : "从star->creat->resume,然后再是用户在页面的操作，若要保存用户操作后的数据的话，就得等用户打开其他activity时，再来保存之前activity里的东西",
    "optionB" : "onPause（）",
    "type" : "1",
    "optionA" : "onStart（）",
    "question" : "对一些资源以及状态的操作保存，最好是保存在Activity生命周期的那个函数中进行？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39995",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法",
    "optionC" : "如果service已经启动，将先后调用onCreate()和onStart()方法",
    "optionAnswer" : "D",
    "answer" : "1、当第一次启动的时候先后调用onCreate()和onStart()方法;2、如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法",
    "optionB" : "当第一次启动的时候只会调用onCreate()方法",
    "type" : "1",
    "optionA" : "当第一次启动的时候只会调用 onStart()方法",
    "question" : "android 关于service生命周期的onCreate()和onStart()说法正确的是"
  },
  {
    "ID" : "55bb36a8e4b0809382e39972",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "res\/anim\/ 用来放置动画\nres\/xml\/ 用来放置data数据\nres\/raw\/ 用来放置style theme等xml定义。",
    "optionC" : "res\/anim\/ 用来放置data数据\nres\/xml\/ 用来放置style theme等xml定义。\nres\/raw\/ 用来放置动画",
    "optionAnswer" : "B",
    "answer" : "res\/anim\/ 用来放置动画\nres\/xml\/ 用来放置style theme等xml定义。\nres\/raw\/ 用来放置data数据",
    "optionB" : "res\/anim\/ 用来放置动画\nres\/xml\/ 用来放置style theme等xml定义。\nres\/raw\/ 用来放置data数据",
    "type" : "1",
    "optionA" : "res\/anim\/ 用来放置style theme等xml定义。\nres\/xml\/ 用来放置动画\nres\/raw\/ 用来放置data数据",
    "question" : "分别介绍res\/anim\/ 、res\/xml\/、 res\/raw\/放置的内容？"
  },
  {
    "answer" : "int maxArea(vector<int>& height) {\n    int water = 0;\n    int i = 0, j = height.size() - 1;\n    while (i < j) {\n        int h = min(height[i], height[j]);\n        water = max(water, (j - i) * h);\n        while (height[i] <= h && i < j) i++;\n        while (height[j] <= h && i < j) j--;\n    }\n    return water;\n}",
    "ID" : "55f2e52be4b0152a611433e7",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "对于非负序列a1、a2、……、an，在数轴上做垂线连接点（i，0）和（i，ai）。选择这样的两条线和x轴可以形成一个容器，我们以面积代表所装的水，求以这种方式构成的容器能装的最大面积。比如选择a2=3、a5=6，则所装的面积为9."
  },
  {
    "ID" : "55bb36a8e4b0809382e399ad",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "空进程是运行着一个对用户不可见的activity（调用过 onStop() 方法)",
    "optionC" : "服务进程运行着一个通过startService() 方法启动的service，这个service不属于上面提到的2种更高重要性的。service所在的进程虽然对用户不是直接可见的，但是他们执行了用 户非常关注的任务（比如播放mp3，从网络下载数据）。只要前台进程和可见进程有足够的内存，系统不会回收他们。",
    "optionAnswer" : "D",
    "answer" : "按照重要性从高到低一共有五个级别： 前台进程   前台进程是用户当前正在使用的进程。只有一些前台进程可以在任何时候都存在。他们是最后一个被结束的，当内存低到根本连他们都不能运行的时候。一般来说， 在这种情况下，设备会进行内存调度，中止一些前台进程来保持对用户交互的响应。 可见进程   可见进程不包含前台的组件但是会在屏幕上显示一个可见的进程是的重要程度很高，除非前台进程需要获取它的资源，不然不会被中止。 服务进程   运行着一个通过startService() 方法启动的service，这个service不属于上面提到的2种更高重要性的。service所在的进程虽然对用户不是直接可见的，但是他们执行了用 户非常关注的任务（比如播放mp3，从网络下载数据）。只要前台进程和可见进程有足够的内存，系统不会回收他们。 后台进程   运行着一个对用户不可见的activity（调用过 onStop() 方法).这些进程对用户体验没有直接的影响，可以在服务进程、可见进程、前台进 程需要内存的时候回收。通常，系统中会有很多不可见进程在运行，他们被保存在LRU (least recently used) 列表中，以便内存不足的时候被第一时间回收。如果一个activity正 确的执行了它的生命周期，关闭这个进程对于用户体验没有太大的影响。 空进程   未运行任何程序组件。运行这些进程的唯一原因是作为一个缓存，缩短下次程序需要重新使用的启动时间。系统经常中止这些进程，这样可以调节程序缓存和系统缓存的平衡。  Android 对进程的重要性评级的时候，选取它最高的级别。另外，当被另外的一个进程依赖的时候，某个进程的级别可能会增高。一个为其他进程服务的进程永远不会比被服 务的进程重要级低。因为服务进程比后台activity进程重要级高，因此一个要进行耗时工作的activity最好启动一个service来做这个工 作，而不是开启一个子进程――特别是这个操作需要的时间比activity存在的时间还要长的时候。例如，在后台播放音乐，向网上上传摄像头拍到的图片， 使用service可以使进程最少获取到“服务进程”级别的重要级，而不用考虑activity目前是什么状态。broadcast receivers做费时的工作的时候，也应该启用一个服务而不是开一个线程。 ",
    "optionB" : "可见进程不包含前台的组件但是会在屏幕上显示一个可见的进程是的重要程度很高，除非前台进程需要获取它的资源，不然不会被中止。",
    "type" : "1",
    "optionA" : "前台进程是用户当前正在使用的进程。只有一些前台进程可以在任何时候都存在。他们是最后一个被结束的，当内存低到根本连他们都不能运行的时候。一般来说， 在这种情况下，设备会进行内存调度，中止一些前台进程来保持对用户交互的响应。",
    "question" : "Android进程说明有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b9",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "它可以属于一个新的线程",
    "optionC" : "它采用栈的方式来组织任务的",
    "optionAnswer" : "A",
    "answer" : "B. 只能在UI线程操作UI组件\nC. 采用队列\nD. 只能属于创建它的线程",
    "optionB" : "它避免了新线程操作 UI 组件",
    "type" : "1",
    "optionA" : "它实现不同线程间通信的一种机制",
    "question" : "关于 Handler 的说话正确的是(）"
  },
  {
    "ID" : "55bb36a8e4b0809382e3999d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。",
    "optionC" : "在Android中不能直接打开res raw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。",
    "optionAnswer" : "B",
    "answer" : "在Android中不能直接打开res raw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。\n复制的基本方法是使用getResources().openRawResource方法获得res raw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。",
    "optionB" : "复制的基本方法是使用getResources().openRawResource方法new一个InputStream对象，然后获得res raw目录中的资源 ，然后将该InputStream对象中的数据写入其他的目录中相应文件中。",
    "type" : "1",
    "optionA" : "复制的基本方法是使用getResources().openRawResource方法获得res raw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。",
    "question" : "下列有关打开res raw目录中的数据库文件手法不正确的是?"
  },
  {
    "ID" : "55bb36a8e4b0809382e39978",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "setView",
    "optionC" : "setLayout",
    "optionAnswer" : "D ",
    "answer" : "通过setView将视图对象添加到当前对话框",
    "optionB" : "setXML",
    "type" : "1",
    "optionA" : "setIcon ",
    "question" : "自定义对话框时，将视图对象添加到当前对话框的方法是（  ）"
  },
  {
    "ID" : "55bb36a8e4b0809382e39993",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "一个类可以实现一个接口，但只能继承一个抽象类。",
    "optionC" : "抽象类中不可以包含静态方法，接口中可以包含静态方法",
    "optionAnswer" : "A",
    "answer" : "A，抽象类可以有非抽象方法和普通成员，因此可以有构造方法，接口只能有抽象方法和final类型的成员变量，不能定义构造方法\nB，接口中有final类型的成员变量\nC，抽象类也可以有静态方法\nD，通过接口可以实现类似多继承的机制",
    "optionB" : "抽象类中可以有普通成员变量，接口中没有普通成员变量",
    "type" : "1",
    "optionA" : "抽象类可以有构造方法，接口中不能有构造方法",
    "question" : "abstract class和interface有什么区别。"
  },
  {
    "ID" : "55bb36a8e4b0809382e3998c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "同类机型用户减少",
    "optionC" : "丰富的硬件选择",
    "optionAnswer" : "C",
    "answer" : "Android系统的五大不足：\n1、安全与隐私  \n2、首先开卖Android手机的不是最大的运营商  \n3、运营商任然能够影响到Android手机  \n4、同类机型用户减少  \n5、过分依赖开发商缺少标准配置",
    "optionB" : "首先开卖Android手机的不是最大的运营商",
    "type" : "1",
    "optionA" : "安全和隐私",
    "question" : "以下哪个不是Android的不足？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39916",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : ".java",
    "optionC" : ".apk ",
    "optionAnswer" : "B",
    "answer" : "AndroidManifest.xml",
    "optionB" : ".xml ",
    "type" : "1",
    "optionA" : ".jar  ",
    "question" : "Android manifest的文件扩展名是（ ）"
  },
  {
    "ID" : "55bb36a8e4b0809382e3997e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "AndroidManifest.xml 功能清单文件\n这个文件列出了应用程序所提供的功能，在这个文件中，你可以指定应用程序使用到的服务(如电话服务、互联网服务、短信服务、GPS服务等等)。另外当你新添加一个Activity的时候，也需要在这个文件中进行相应配置，只有配置好后，才能调用此Activity。",
    "optionC" : "res\/ 资源(Resource)目录。专门存放xml界面文件，xml界面文件和HTML文件一样，主要用于显示用户操作界面。",
    "optionAnswer" : "C",
    "answer" : "src\/ java原代码存放目录\ngen\/ 自动生成目录\ngen 目录中存放所有由Android开发工具自动生成的文件。目录中最重要的就是R.java文件。 这个文件由Android开发工具自动产生的。Android开发工具会自动根据你放入res目录的xml界面文件、图标与常量，同步更新修改 R.java文件。正因为R.java文件是由开发工具自动生成的，所以我们应避免手工修改R.java。R.java在应用中起到了字典的作用，它包含了界面、图标、常量等各种资源的id，通过R.java，应用可以很方便地找到对应资源。另外编绎器也会检查R.java列表中的资源是否被使用到，没有被使用到的资源不会编绎进软件中，这样可以减少应用在手机占用的空间。\nres\/ 资源(Resource)目录\n在这个目录中我们可以存放应用使用到的各种资源，如xml界面文件，图片或数据。\nAndroidManifest.xml 功能清单文件\n这个文件列出了应用程序所提供的功能，在这个文件中，你可以指定应用程序使用到的服务(如电话服务、互联网服务、短信服务、GPS服务等等)。另外当你新添加一个Activity的时候，也需要在这个文件中进行相应配置，只有配置好后，才能调用此Activity。\ndefault.properties 项目环境信息，一般是不需要修改此文件\n",
    "optionB" : "gen 目录中存放所有由Android开发工具自动生成的文件。目录中最重要的就是R.java文件。 这个文件由Android开发工具自动产生的",
    "type" : "1",
    "optionA" : "src\/ java原代码存放目录",
    "question" : "Android应用程序架构（目录）说明有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39915",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "(a~z) ( _ . )",
    "optionC" : "(a~z) (0~9)",
    "optionAnswer" : "A",
    "answer" : "_可以，所以排除BC\n数字可以，排除D",
    "optionB" : "(a~z)(0~9)(| > <)",
    "type" : "1",
    "optionA" : "(a~z) (0~9) ( _ . )",
    "question" : "layout中创建的.xml 起名范围只能是"
  },
  {
    "answer" : "framlayout，linenarlayout，relativelayout和tablelayout",
    "ID" : "55f2e52be4b0152a611433e8",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "android中常用的四个布局是（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e3999f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "静态：广播跟随程序的生命周期；   动态：当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动执行",
    "optionC" : "类不用继承BroadcastReceiver",
    "optionAnswer" : "C",
    "answer" : "类要继承BroadcastReceiver",
    "optionB" : "广播分为静态和动态",
    "type" : "1",
    "optionA" : "广播的注册：在清单文件中声明，添加<receive android:name=\"IncomingSMSReceiver\">   <intent-filter>   <action android:name=\"android.provider.Telephony.SMS_RECEIVED\"<intent-filter> <receiver>",
    "question" : "有关广播的说法错误的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39961",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "getType( ) 返回数据给调用者",
    "optionC" : "update( ) 更新 ContentProvider 已经存在的数据",
    "optionAnswer" : "D",
    "answer" : "ContentProvider 类中六个抽象方法的说明：\n1、onCreate( )  初始化 provider\n2、query( )     返回数据给调用者\n3、insert( )    插入新数据到 ContentProvider\n4、update( )    更新 ContentProvider 已经存在的数据\n5、delete( )    从 ContentProvider 中删除数据\n6、getType( )   返回 ContentProvider 数据的 Mime 类型",
    "optionB" : "insert( ) 插入新数据到 ContentProvider",
    "type" : "1",
    "optionA" : "onCreate( ) 初始化 provider",
    "question" : "ContentProvider 类中六个抽象方法的说明错误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399d2",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " 在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。",
    "optionC" : " 在编码难度方面，JSON有丰富的编码工具，比如Dom4j、JDom等，也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。",
    "optionAnswer" : "C ",
    "answer" : "1.       在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。\n\n2.       在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。\n\n3.       在编码难度方面，XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。\n\n4.       在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。\n",
    "optionB" : "在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。",
    "type" : "1",
    "optionA" : "在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。\n",
    "question" : "JSON 和 XML 优缺点的比较说法有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a0",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "finish关闭Activity",
    "optionC" : "递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。",
    "optionAnswer" : "D",
    "answer" : "已调用多个Activity的Application的安全退出：1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。  2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。  3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。",
    "optionB" : "发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。",
    "type" : "1",
    "optionA" : "记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。",
    "question" : "以下哪个不是已调用多个Activity的Application的安全退出？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e39998",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "寄存器",
    "optionC" : "字符串常量区",
    "optionAnswer" : "C",
    "answer" : "用new创建的对象在堆区\n函数中的临时变量在栈去\njava中的字符串在字符串常量区",
    "optionB" : "栈",
    "type" : "1",
    "optionA" : "堆",
    "question" : "String str1 = “abc”，“abc”分配在内存哪个区域？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3994f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "图片优化",
    "optionC" : "循环使用",
    "optionAnswer" : "B",
    "answer" : "Android代码优化技术：\n1、Java内存控制  \n2、循环使用  \n3、图片优化       \n静态变量引起内存泄露",
    "optionB" : "不恰当引用静态变量 ",
    "type" : "1",
    "optionA" : "Java内存控制",
    "question" : "以下哪项不是Android代码优化技术？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e39977",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "IntentService适合多线程处理异步请求。而Service则适合处理需要排队的请求。",
    "optionC" : "Service可以通过startService()或者bindService()方法来启动，而IntentService则是通过startService()方法来启动。",
    "optionAnswer" : "D",
    "answer" : "IntentService是Service的子类\n1）Service如果要处理异步请求(如耗时操作)的话，需要自己启动一个worker thread,如果启动多个worker thread来处理相关事务的话，各线程之间无法很好的控制。而IntentService可以将多个异步请求的Intent放入队列中，封装了一个开启worker thread的onHandleIntent()方法，来依次处理放入队列中的Intent，只有一个worker thread在运行，同一时刻只有一个Intent被处理，当一个Intent处理完了之后才会处理另外一个Intent。\n2）Service可以通过startService()或者bindService()方法来启动，而IntentService则是通过startService()方法来启动。\nService适合多线程处理异步请求。而IntentService则适合处理需要排队的请求。",
    "optionB" : "IntentService可以将多个异步请求的Intent放入队列中，封装了一个开启worker thread的onHandleIntent()方法，来依次处理放入队列中的Intent，只有一个worker thread在运行，同一时刻只有一个Intent被处理，当一个Intent处理完了之后才会处理另外一个Intent。",
    "type" : "1",
    "optionA" : "Service如果要处理异步请求(如耗时操作)的话，需要自己启动一个worker thread,如果启动多个worker thread来处理相关事务的话，各线程之间无法很好的控制。",
    "question" : "IntentService与Service区别说法不对的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399cc",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "以上说法都不对",
    "optionC" : "抽象类和接口都不能被实例化。",
    "optionAnswer" : "A",
    "answer" : "抽象类可以有抽象方法和实现方法，避免了在子类中重复实现实现这些方法，在一定程度上提升代码的重用性。而接口只能有抽象方法，不能有实现方法。",
    "optionB" : "抽象类可以被声明使用，接口不可以被声明使用",
    "type" : "1",
    "optionA" : "优先选用接口，尽量少用抽象类",
    "question" : "关于抽象类与接口，下列说法正确的有？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c8",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "当有超过一个线程在等待获得一个对象的锁定时，那么就无法确定notify()方法将通知哪个线程",
    "optionC" : "方法notifyAll()在类Thread中被定义的",
    "optionAnswer" : "D",
    "answer" : "被锁定的对象可以调用wait( )方法，这将导致当前线程被阻塞并放弃该对象的互斥锁，即解除了wait( )方法的当前对象的锁定状态，其他的线程就有机会访问该对象。 notify使等待队列上的一个线程离开阻塞状态 notifyAll使等待队列上的所有线程离开阻塞状态",
    "optionB" : "方法notify()是同步的",
    "type" : "1",
    "optionA" : "一个到方法notify()的调用将唤醒当前拥有对象锁定的线程",
    "question" : "关于方法notify()和notifyAll（）哪些说法是正确的"
  },
  {
    "ID" : "55bb36a8e4b0809382e39994",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "负责从消息队列中循环的取出消息然后把消息交给目标处理",
    "optionC" : "确定在将来的某个时间点执行一个或者一些Message和Runnable对象。",
    "optionAnswer" : "C",
    "answer" : "Handler有两个主要的用途：（1）确定在将来的某个时间点执行一个或者一些Message和Runnable对象。（2）在其他线程（不是Handler绑定线程）中排入一些要执行的动作。",
    "optionB" : "代表一个行为（what）或者一串动作（Runnable）",
    "type" : "1",
    "optionA" : "存放了大量的消息（Message）",
    "question" : "下列属于Handler作用的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399d4",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "旋转应用程序所使用的图片资源",
    "optionC" : "放置一些与UI响应的布局文件，都是XML",
    "optionAnswer" : "A",
    "answer" : "用于存放应用程序中使用的外部资源文件，程序可以通过I\/O流对目录中的文件进行读写，存放在此目录下的文件都会被打包到发布包中。主要放置多媒体等数据文件",
    "optionB" : "放置字符串、颜色、数组等常量数据",
    "type" : "1",
    "optionA" : "主要放置多媒体等数据文件",
    "question" : "Android项目工程下面的assets目录的作用是什么？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39949",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " ListWrapperAdapter",
    "optionC" : "ResourceCursorAdapter",
    "optionAnswer" : "D",
    "answer" : "Adapter是连接后端数据和前端显示的适配器接口。常见的Adapter有ArrayAdapter, BaseAdapter, CursorAdapter,  HeaderViewListAdapter,  ListAdapter,  ResourceCursorAdapter,  SimpleAdapter,SimpleCursorAdapter, SpinnerAdapter, WrapperListAdapter等",
    "optionB" : "SimpleCursorAdapter",
    "type" : "1",
    "optionA" : "HeaderViewListAdapter",
    "question" : "下列不属于Adapter的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39911",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "SQLite引擎不是个程序与之通信的独立进程，而是连接到程序中成为它的一个主要部分",
    "optionC" : "SQLITE默认就是关闭事务的。",
    "optionAnswer" : "C",
    "answer" : " SQLite作为轻量级的数据库，比MySQL还小，但支持SQL语句查询，提高性能可以考虑通过优化的SQL查询语句方式处理。SQLITE默认就是打开事务的。",
    "optionB" : "支持SQL语句查询，提高性能可以考虑通过优化的SQL查询语句方式处理。",
    "type" : "1",
    "optionA" : " SQLite作为轻量级的数据库，比MySQL还小",
    "question" : "有关于SQLite说法不对的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39950",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "JSONObject、JSONStringer、JSONArray、JSONTokener、JSONNumber",
    "optionC" : "JSONObject、JSONStringer、JSONNumber、JSONTokener、JSONException",
    "optionAnswer" : "B",
    "answer" : "JSON解析类有JSONObject、JSONStringer、JSONArray、JSONTokener、JSONException",
    "optionB" : "JSONObject、JSONStringer、JSONArray、JSONTokener、JSONException",
    "type" : "1",
    "optionA" : "JSONObject、JSONNumber、JSONArray、JSONTokener、JSONException",
    "question" : "JSON解析类有哪些？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b7",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能",
    "optionC" : "如果要正式发布一个Android程序，可以使用集成开发工具生成的调试证书来发布",
    "optionAnswer" : "C",
    "answer" : "必须要使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布",
    "optionB" : "Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证",
    "type" : "1",
    "optionA" : "所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序",
    "question" : "下列关于 Android 数字签名描述错误的是："
  },
  {
    "ID" : "55bb36a7e4b0809382e3992c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "android:text",
    "optionC" : " \nandroid:singleLine",
    "optionAnswer" : "B",
    "answer" : "A:android:capitalize为设置英文字母大写类型。设置如下值： sentences 仅第一个字母大写；\nwords 每一个单词首字母大小，用空格区分单词\n； characters 每一个英文字母都大写。",
    "optionB" : " \nandroid:hint ",
    "type" : "1",
    "optionA" : "android:capitalize",
    "question" : "在一个布局文件中,对一个EditText进行设置,以下哪项设置能实现输入框默认提示内容的效果( )."
  },
  {
    "ID" : "55bb36a7e4b0809382e3991c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "1、创建客户端套接字(指定服务器端IP地址与端口号)\n2、连接(Android 创建Socket时会自动连接)\n3、关闭套接字\n4、与服务器端进行通信",
    "optionC" : "1、创建客户端套接字(指定服务器端IP地址与端口号)\n2、关闭套接字\n3、与服务器端进行通信\n4、连接(Android 创建Socket时会自动连接)",
    "optionAnswer" : "A",
    "answer" : "1、创建客户端套接字(指定服务器端IP地址与端口号)\n2、连接(Android 创建Socket时会自动连接)\n3、与服务器端进行通信\n4、关闭套接字",
    "optionB" : "1、创建客户端套接字(指定服务器端IP地址与端口号)\n2、与服务器端进行通信 \n3、连接(Android 创建Socket时会自动连接)\n4、关闭套接字",
    "type" : "1",
    "optionA" : "1、 创建客户端套接字(指定服务器端IP地址与端口号)\n2、 连接(Android 创建Socket时会自动连接)\n3、 与服务器端进行通信\n4、 关闭套接字",
    "question" : "Socket通信编程，客户端编程步骤？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39952",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "JSON的速度要远远快于XML。",
    "optionC" : " JSON对数据的描述性比XML较差。",
    "optionAnswer" : "A",
    "answer" : "1.JSON相对于XML来讲，数据的体积小。\n2.JSON与JavaScript的交互更加方便。\n3.JSON对数据的描述性比XML较差。\n4.JSON的速度要远远快于XML。",
    "optionB" : " JSON与JavaScript的交互更加方便。",
    "type" : "1",
    "optionA" : "JSON相对于XML来讲，数据的体积大。",
    "question" : "JSON 和 XML 优缺点的比较说法有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3990e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "\/data\/data\/Package Name\/Shared_Pref",
    "optionC" : "\/data\/data\/Package Name\/",
    "optionAnswer" : "D",
    "answer" : "Preference所在的目录是\/data\/data\/Package Name\/Shared_Pref",
    "optionB" : "\/data\/data\/Package Name\/database",
    "type" : "1",
    "optionA" : " \/data\/data\/Package Name\/files",
    "question" : "下列是Preference所在目录的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39942",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "FLAG_ACTIVITY_SINGLE_TOP \n??如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的。这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。",
    "optionC" : "FLAG_ACTIVITY_RESET_TASK_IF_NEEDED \n    如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。",
    "optionAnswer" : "D",
    "answer" : "FLAG_ACTIVITY_NEW_TASK \n  如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的          Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。 \nFLAG_ACTIVITY_CLEAR_TOP \n??如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。  \n??这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。 \nFLAG_ACTIVITY_RESET_TASK_IF_NEEDED \n    如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。\nFLAG_ACTIVITY_SINGLE_TOP \n??如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的",
    "optionB" : "FLAG_ACTIVITY_CLEAR_TOP \n??如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。",
    "type" : "1",
    "optionA" : "FLAG_ACTIVITY_NEW_TASK \n  如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的          Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序",
    "question" : "下列对于跟activity和Task 有关的 Intent启动方式说法有误的一项是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399d1",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "JSON的速度要远远快于XML。",
    "optionC" : " JSON对数据的描述性比XML较差。",
    "optionAnswer" : "B",
    "answer" : "1.       在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。\n\n2.       在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。\n3.       JSON对数据的描述性比XML较差。\n\n4.   JSON的速度要远远快于XML。",
    "optionB" : " 在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，有些XML能扩展，JSON不能的。",
    "type" : "1",
    "optionA" : "在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。",
    "question" : "JSON 和 XML 优缺点的比较说法有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3990d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "XML与JavaScript的交互更加方便。",
    "optionC" : "JSON相对于XML来讲，数据的体积小。",
    "optionAnswer" : "D",
    "answer" : "1.       在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous Javascript and JSON)了。\n\n2.       JSON和XML同样拥有丰富的解析手段。\n\n3.       JSON相对于XML来讲，数据的体积小。\n\n4.       JSON与JavaScript的交互更加方便。\n\n",
    "optionB" : " JSON和XML同样拥有丰富的解析手段。",
    "type" : "1",
    "optionA" : "  在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous Javascript and JSON)了。",
    "question" : "JSON 和 XML 优缺点的比较说法有误的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3999c",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "实现",
    "optionC" : "多态",
    "optionAnswer" : "D",
    "answer" : "面向对象的特征有：封装、继承、多态",
    "optionB" : "继承",
    "type" : "1",
    "optionA" : "封装",
    "question" : "以下不是面向对象的特征的是？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399ba",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "内边框、外边框",
    "optionC" : "外边框、内边框",
    "optionAnswer" : "C",
    "answer" : "margin 是外边框，padding是内边框",
    "optionB" : "内边框、内边框",
    "type" : "1",
    "optionA" : "外边框、外边框",
    "question" : "margin跟padding控制的属性分别是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39933",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "ImageView是显示图片的组件，可以通过设置显示局部图片",
    "optionC" : "EditText是编辑文本的组件，可以使用EditText输入特定的字符",
    "optionAnswer" : "D",
    "answer" : "只是显示不能设置",
    "optionB" : "TextView是显示文本的组件，TextView是EditText的父类",
    "type" : "1",
    "optionA" : "Button是普通按钮组件，除此外还有其他的按钮组件",
    "question" : "下列说法错误的是()?"
  },
  {
    "ID" : "55bb36a8e4b0809382e399ce",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "利用 Intent 传值时，它的 key 值可以是对象",
    "optionC" : "利用 Intent 传值时，可以传递一部分值类型",
    "optionAnswer" : "D",
    "answer" : "利用 Intent 传值时，它的 key 值不可以是对象",
    "optionB" : "Intent 对象可以把值传递给广播或 Activity",
    "type" : "1",
    "optionA" : "在 android 中，Intent对象是用来传递信息的",
    "question" : "关于Intent 对象说法错误的是（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39918",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "任意路径 指定扩展名",
    "optionC" : "\/mnt\/sdcard\/指定文件夹 指定扩展名",
    "optionAnswer" : "B",
    "answer" : " data\/data\/包名\/shared_prefs",
    "optionB" : " \/data\/data\/package name\/shared_prefs\/ *.xml",
    "type" : "1",
    "optionA" : "\/data\/data\/shared_prefs\/ *.txt",
    "question" : "SharedPreferences保存文件的路径和扩展名是"
  },
  {
    "ID" : "55bb36a8e4b0809382e399ab",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。",
    "optionC" : "直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。",
    "optionAnswer" : "C",
    "answer" : "对于多个activity，\n1、抛异常强制退出：\n该方法通过抛异常，使程序Force Close。\n验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。\n2、记录打开的Activity：\n每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。\n3、发送特定广播：\n在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。\n4、递归退出\n在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。\n除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。",
    "optionB" : "记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。",
    "type" : "1",
    "optionA" : "抛异常强制退出：该方法通过抛异常，使程序Force Close。验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。",
    "question" : "不属于安全退出已调用多个Activity的Application方法的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c9",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "抽象中可以包含静态方法。接口中不能包含静态方法",
    "optionC" : "抽象类中可以有普通成员变量，接口中没有普通成员变量",
    "optionAnswer" : "A",
    "answer" : "1、一个类可以试想多个接口，只能继承一个抽象类；2、抽象类可以有构造方法，接口中不能有构造方法 3、抽象类中可以有普通成员变量，接口中没有普通成员变量 4、抽象中可以包含静态方法。接口中不能包含静态方法",
    "optionB" : "抽象类可以有构造方法，接口中不能有构造方法",
    "type" : "1",
    "optionA" : "一个类可以试想多个接口，也可以继承多个抽象类",
    "question" : "以下关于接口和抽象说法不正确的是？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e3998f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.",
    "optionC" : "interface，class，array等java引用数据类型",
    "optionAnswer" : "C",
    "answer" : "全称是：Android Interface Define Language。    下面是些AIDL支持的数据类型:\n1. 不需要import声明的简单Java编程语言类型(int,boolean等)\n2. String, CharSequence不需要特殊声明\n3. List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.\n在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。\nAIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.\nAIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.\nAIDL的创建方法:\nAIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.",
    "optionB" : " String, CharSequence不需要特殊声明",
    "type" : "1",
    "optionA" : "不需要import声明的简单Java编程语言类型(int,boolean等)",
    "question" : "不属于AIDL支持的数据类型的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39980",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "TEXT",
    "optionC" : "NEXT_TAGD",
    "optionAnswer" : "C",
    "answer" : "下列属于PULL解析XML中字段的是 A, START_TAGB, START_DOCUMENTC,NEXT_TAGD, TEXT",
    "optionB" : "START_DOCUMENTC",
    "type" : "1",
    "optionA" : "START_TAGB",
    "question" : "下列不属于PULL解析XML中字段的是"
  },
  {
    "ID" : "55bb36a8e4b0809382e399aa",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "以上都不对",
    "optionC" : "在某些情况下可以",
    "optionAnswer" : "A",
    "answer" : "会显示在logcat中",
    "optionB" : "不能",
    "type" : "1",
    "optionA" : "能",
    "question" : "Android中可以使用System.out.println(“”);在控制台中显示你想要显示的字符吗？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39923",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "adb",
    "optionC" : "aidl",
    "optionAnswer" : "B",
    "answer" : "platform-tools目录下常用的工具有：\n\naapt、adb、dx、aidl",
    "optionB" : "ddms",
    "type" : "1",
    "optionA" : "aapt",
    "question" : "下列不属于platform-tools目录常用的工具的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b6",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : " 双缓冲技术可以使动画平滑。",
    "optionC" : "将离屏图像一次绘至屏幕上，比直接在屏幕上绘制要有效得多。\n",
    "optionAnswer" : "B",
    "answer" : "创建一幅后台图像，将每一帧画入图像，然后调用drawImage()方法将整个后台图像一次画到屏幕上去。\n\n优点：双缓冲技术的优点在于大部分绘制是离屏的。\n\n            将离屏图像一次绘至屏幕上，比直接在屏幕上绘制要有效得多。\n\n            双缓冲技术可以使动画平滑。\n\n缺点：要分配一个后台图像的缓冲，如果图像相当大，这将占用很大一块内存。",
    "optionB" : "要分配一个后台图像的缓冲，如果图像相当大，这将占用很大一块内存。",
    "type" : "1",
    "optionA" : "双缓冲技术的优点在于大部分绘制是离屏的。\n",
    "question" : "属于双缓冲技术原理的优点的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39946",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "setPosition",
    "optionC" : "paint",
    "optionAnswer" : "B",
    "answer" : "根据单词的意思可得知",
    "optionB" : "setVisible",
    "type" : "1",
    "optionA" : "getX",
    "question" : "在MIDPv2.0中,layer设置图层是否可见的方法是(   )"
  },
  {
    "ID" : "55bb36a7e4b0809382e3990b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "3",
    "optionC" : "4",
    "optionAnswer" : "C",
    "answer" : "android的系统架构和其操作系统一样，采用了分层的架构。从架构图看，android分为四个层，从高层到低层分别是应用程序层、应用程序框架层、系统运行库层和linux核心层。",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "5",
    "question" : "从架构图看，android分为几个层?"
  },
  {
    "ID" : "55bb36a8e4b0809382e3998d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏会重新调用各个生命周期，不会执行onConfigurationChanged方法",
    "optionC" : "设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法",
    "optionAnswer" : "D",
    "answer" : "1)不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；\n2)设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；\n设置Activity的android:configChanges=\"orientation|keyboardHidden\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法",
    "optionB" : "设置Activity的android:configChanges=\"orientation\"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；",
    "type" : "1",
    "optionA" : "不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；",
    "question" : "activity在屏幕旋转时的生命周期说法有误的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39925",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Intents",
    "optionC" : "Content",
    "optionAnswer" : "A",
    "answer" : "M是逻辑模型\nV是视图模型，对应于android里面的View\nc是控制器，android中的activity实现了这个职责",
    "optionB" : "Services",
    "type" : "1",
    "optionA" : "Activity",
    "question" : "Android中MVC模式 C层指的是？"
  },
  {
    "answer" : "最常见的方式是通过handler的消息传递机制来完成的，其次还可以通过广播机制，以及第三方库EventBus去完成UI与耗时操作的通信。 \n 1.Handler方式：这种方式是Android中最重要的消息传递机制，通过Handler，Looper，MessageQueue三者的协作完成消息的传递，\n 实现简单原理：Handler发送通过sendmessage()发送消息，及把消息插入到messagequeue中，Looper不断的通过loop()方法轮询\n 消息队列，如果里面有消息，就将消息取出并通过msg.targer.dispatchMessage()&nbsp;去分发消息。然后Handler在UI线程中\n 通过handlerMessage()去处理消息\n 优点：使用范围广，可追踪方便调试，通信的载体是消息，而消息可以包括各\n 种数据类型，还可以传递对象 \n 缺点：原理较复杂 \n 2.广播机制：通过系统广播或者自定义的广播去\n 实现UI线程与耗时操作线程之间的通信 \n 优点：实现简单 \n 缺点：不利于调试，且消息传递不够灵活，会存在安全问题 \n 3.EventBus：EventBus是一个Android端优化的publish\/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。\n 比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现 \n 优点：针对一个进程，解耦\n 缺点：大量使用会不利于调式 ",
    "ID" : "55f2e52ae4b0152a611433e6",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "简述Andriod如何处理UI与耗时操作的通信，有哪些方式及各自的优缺点。"
  },
  {
    "ID" : "55bb36a8e4b0809382e399b2",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "接收者声明的优先级别在<intent-filter>的android:priority属性中声明，数值越大优先级别越高",
    "optionC" : "对有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者",
    "optionAnswer" : "B",
    "answer" : "广播接收者（BroadcastReceiver）用于异步接收广播Intent，广播Intent的发送是通过调用Context.sendBroadcast()、Context.sendOrderedBroadcast()或者Context.sendStickyBroadcast()来实现的。通常一个广播Intent可以被订阅了此Intent的多个广播接收者所接收，广播接收者和JMS中的Topic消息接收者很相似。",
    "optionB" : "一个广播Intent只能被一个订阅了此广播的BroadcastReceiver所接收",
    "type" : "1",
    "optionA" : "是用来接收广播Intent的",
    "question" : "关于BroadcastReceiver的说法不正确的是（  )"
  },
  {
    "ID" : "55bb36a8e4b0809382e399c1",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "整型",
    "optionC" : "接口",
    "optionAnswer" : "C",
    "answer" : "复合数据类型包括:  \n-记录\n-表\n-嵌套表\n-数组",
    "optionB" : "联合类型",
    "type" : "1",
    "optionA" : "无符号整数类型",
    "question" : "下列（ ）属于Andriod开发语言的复合数据类型"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a3",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "框架布局",
    "optionC" : "线性布局",
    "optionAnswer" : "C ",
    "answer" : "根据单词的意思可得知",
    "optionB" : "相对布局",
    "type" : "1",
    "optionA" : "绝对布局",
    "question" : "LinearLayout 是什么布局？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3996b",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "main()",
    "optionC" : "run() ",
    "optionAnswer" : "A",
    "answer" : "canvas没有方法run()\nsetFont()不是抽象方法，不用重写\ncanvas必须重写 paint 方法\nrepaint（）不用重写",
    "optionB" : "keyPressed() ",
    "type" : "1",
    "optionA" : "paint()",
    "question" : "继承了Canvas类必须实现的方法是（  )"
  },
  {
    "ID" : "55bb36a8e4b0809382e39992",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "接口不能定义变量",
    "optionC" : "普通类可以在实现多个接口的同时继承一个抽象类",
    "optionAnswer" : "D",
    "answer" : "抽象类可以有抽象方法而普通类则不能有抽象方法；抽象类的方法可以有部分实现而接口不能实现其方法；普通类可以在实现多个接口的同时继承一个抽象类",
    "optionB" : "抽象类的方法可以有部分实现而接口不能实现其方法",
    "type" : "1",
    "optionA" : "抽象类可以有抽象方法而普通类则不能有抽象方法",
    "question" : "关于接口、抽象类和普通类，下列说法错误的是(  )"
  },
  {
    "ID" : "55bb36a8e4b0809382e399ca",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "List，Map和Parcelables，这些类型内所包含的数据成员也只能是简单数据类型，String等其他比支持的类型。 ",
    "optionC" : "String，CharSequence不需要特殊声明",
    "optionAnswer" : "A",
    "answer" : "AIDL能处理的数据类型：1、不需要import声明的简单Java编程语言类型（int、boolean等）  2、String，CharSequence不需要特殊声明  3、List，Map和Parcelables，这些类型内所包含的数据成员也只能是简单数据类型，String等其他比支持的类型。 ",
    "optionB" : "不需要import声明的简单Java编程语言类型（int、boolean等）",
    "type" : "1",
    "optionA" : "引用类型",
    "question" : "以下哪个是AIDL不能处理的类型数据？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399cf",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "在<activity>中配置：android：theme=\"@android：Theme.Dialog\"",
    "optionC" : "在<activity>中配置：android：theme=\"@android：style\/Theme\"",
    "optionAnswer" : "A",
    "answer" : "在<activity>中配置：android：theme=\"@android：style\/Theme.Dialog\"设置Activity的窗口样式",
    "optionB" : "在Activity中用代码实现",
    "type" : "1",
    "optionA" : "在<activity>中配置：android：theme=\"@android：style\/Theme.Dialog\"",
    "question" : "哪个是将一个Activity设置成窗口样式？（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399d6",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "如果子类有无参构造方法，而父类的无参构造方法则被覆盖",
    "optionC" : "如果子类没有构造方法，则父类无参构造方法作为自已的构造方法 ",
    "optionAnswer" : "D",
    "answer" : "不会被覆盖",
    "optionB" : "子类可以引用父类中的有参构造方法，使用super关键字",
    "type" : "1",
    "optionA" : "子类无条件的继承父类的无参构造方法    ",
    "question" : "在继承中，关于构造方法的说明，下列说法错误的是(  )"
  },
  {
    "ID" : "55bb36a7e4b0809382e3993f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "var3&",
    "optionC" : "_var2",
    "optionAnswer" : "C",
    "answer" : "标示符 由字母数字下划线组成，不以数字开头。应该大多数的语言都遵循这个规范。A.final 是关键字\nB.不能以数字做首写\nC.首写字母可以为下划线\nD.不能与&相组合来命名",
    "optionB" : "1var1",
    "type" : "1",
    "optionA" : "final",
    "question" : "下面属于java合法变量定义的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39941",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "FLAG_ACTIVITY_NEW_TASK ",
    "optionC" : "FLAG_ACTIVITY_SINGLE_TOP",
    "optionAnswer" : "B",
    "answer" : "核心的Intent Flag有： \nFLAG_ACTIVITY_NEW_TASK \nFLAG_ACTIVITY_CLEAR_TOP \nFLAG_ACTIVITY_RESET_TASK_IF_NEEDED \nFLAG_ACTIVITY_SINGLE_TOP",
    "optionB" : "FLAG_ACTIVITY_RESET_TASK_NEEDED",
    "type" : "1",
    "optionA" : "FLAG_ACTIVITY_NEW_TASK",
    "question" : "跟activity和Task 有关的 Intent启动方式有哪些？"
  },
  {
    "ID" : "55bb36a7e4b0809382e3995f",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "onStart",
    "optionC" : "onStop",
    "optionAnswer" : "C",
    "answer" : "service的生命周期，从它被创建开始，到它被销毁为止，可以有两条不同的路径：\n\nA started service\n　　被开启的service通过其他组件调用 startService()被创建。\n\n　　这种service可以无限地运行下去，必须调用stopSelf()方法或者其他组件调用stopService()方法来停止它。\n\n　　当service被停止时，系统会销毁它。\n\n \n\nA bound service\n　　被绑定的service是当其他组件（一个客户）调用bindService()来创建的。\n\n　　客户可以通过一个IBinder接口和service进行通信。\n\n　　客户可以通过 unbindService()方法来关闭这种连接。\n\n　　一个service可以同时和多个客户绑定，当多个客户都解除绑定之后，系统会销毁service。\n\n ",
    "optionB" : "onDestroy ",
    "type" : "1",
    "optionA" : "onCreate",
    "question" : "下列不属于service生命周期的方法是 （   )"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a8",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "进入”Dead”状态的线程将被垃圾回收器回收",
    "optionC" : "垃圾回收机制保证了JAVA程序不会出现 内存溢出",
    "optionAnswer" : "D",
    "answer" : "A ：java中的垃圾回收线程基本是所有线程中优先级最低的\nB： 这个由JVM决定\nC：垃圾回收与内存溢出是不同的概念，垃圾回收释放不用的内存，不能保证内存不会溢出",
    "optionB" : "垃圾收集允许程序开发者明确指定释放 哪一个对象",
    "type" : "1",
    "optionA" : "垃圾回收线程的优先级很高，以保证不再 使用的内存将被及时回收",
    "question" : "以下哪项陈述是正确的？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39940",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "return",
    "optionC" : "System.exit()",
    "optionAnswer" : "D",
    "answer" : "对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。",
    "optionB" : "killProcess()",
    "type" : "1",
    "optionA" : "finish()",
    "question" : "下列不属于退出单一Activity应用的是？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39945",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "getClass()",
    "optionC" : "getAbleDatabase()",
    "optionAnswer" : "A",
    "answer" : "通过getWriteableDatabase()和个体ReadableDatebase()方法",
    "optionB" : "getDatabase()",
    "type" : "1",
    "optionA" : "getWriteableDatabase() 或 getReadableDatabase()",
    "question" : "在android中使用SQLiteOpenHelper这个辅助类时，可以生成一个数据库，并可以对数 据库版本进行管理的方法可以是()"
  },
  {
    "answer" : "在AndroidManifest.xml 中定义Activity的地方一句话android:theme=\"@android:style\/Theme.Dialog\"或android:theme=\"@android:style\/Theme.Translucent\"就变成半透明的",
    "ID" : "55f2e52be4b0152a611433ee",
    "typeID" : "549936a8e4b06783458bdb1c",
    "type" : "2",
    "question" : "如何将一个Activity设置成窗口的样式。"
  },
  {
    "ID" : "55bb36a8e4b0809382e3999e",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "装饰者模式",
    "optionC" : "策略模式",
    "optionAnswer" : "A",
    "answer" : "与Swing一样，事件通知，数据变化时使用的普遍方法是利用观察者模式",
    "optionB" : "代理模式",
    "type" : "1",
    "optionA" : "观察者模式",
    "question" : "Android UI体系中，事件通知实现的基本思想来源于()"
  },
  {
    "ID" : "55bb36a7e4b0809382e39944",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "TableLayout",
    "optionC" : "BorderLayout",
    "optionAnswer" : "C",
    "answer" : "B选项的LinearLayout是线性布局，是最常用的布局。五种基本布局里，A选项的FrameLayout是帧布局，D选项的TableLayout是表格布局，还有一种AbsoluteLayout（绝对布局）、RelativeLayou（相对布局）。C选项的BorderLayout是java中使用的边界布局",
    "optionB" : "LinearLayout",
    "type" : "1",
    "optionA" : "FrameLayout",
    "question" : "下列不属于android布局的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e39991",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "内存回收程序可以在指定的时间释放内存对象",
    "optionC" : "内存回收程序允许程序员直接释放内存   ",
    "optionAnswer" : "B",
    "answer" : "Android 之所以采用特殊的资源管理机制，原因在于其设计之初就是面向移动终端，所有可用的内存仅限于系统 RAM，必须针对这种限制设计相应的优化方案。\n\n当 Android 应用程序退出时，并不清理其所占用的内存，Linux 内核进程也相应的继续存在，所谓“退出但不关闭”。从而使得用户调用程序时能够在第一时间得到响应。\n\n当系统内存不足时，系统将激活内存回收过程。",
    "optionB" : "内存回收程序负责释放无用内存",
    "type" : "1",
    "optionA" : "程序员必须创建一个线程来释放内存     ",
    "question" : "下列哪些语句关于内存回收的说明是正确的?"
  },
  {
    "ID" : "55bb36a7e4b0809382e39957",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "Message Queue(消息队列):用来存放线程放入的消息。  ",
    "optionC" : "线程：UI thread 通常就是子 thread，而Android启动程序时会替它建立一个Message Queue。 ",
    "optionAnswer" : "C ",
    "answer" : "1、Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。\n2、Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。\n3、Message Queue(消息队列):用来存放线程放入的消息。\n4、 线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。",
    "optionB" : "Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。 ",
    "type" : "1",
    "optionA" : "Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。",
    "question" : "有关handler机制的原理说法错误的是？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e3992d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "draw9patch",
    "optionC" : "aidl",
    "optionAnswer" : "C",
    "answer" : "tools目录下常用的工具有：\n\nandroid、apkbuilder、ddms、draw9patch、emulator、mksdcard、sqlite3",
    "optionB" : "android",
    "type" : "1",
    "optionA" : "apkbuilder",
    "question" : "下列不属于tools目录常用的工具的是？"
  },
  {
    "ID" : "55bb36a8e4b0809382e3996d",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "File stream",
    "optionC" : "Filter stream",
    "optionAnswer" : "C",
    "answer" : "读取内容进行处理后在输出用Filter stream",
    "optionB" : "Random stream",
    "type" : "1",
    "optionA" : "Pipe stream",
    "question" : "java.io包中定义了多个流类型来实现输入和输出功能,如果为读取的内容进行处理后再输出，需要使用下列哪种流？（）"
  },
  {
    "ID" : "55bb36a7e4b0809382e39922",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "11个字节",
    "optionC" : "10个字节",
    "optionAnswer" : "A",
    "answer" : "汉字占两个字节，所以6个",
    "optionB" : "7个字节",
    "type" : "1",
    "optionA" : "6个字节",
    "question" : "Java语言中字符串“学Java”所占的内存空间是（）"
  },
  {
    "ID" : "55bb36a8e4b0809382e399a6",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "可以将dictionary.db文件复制到res aw目录中",
    "optionC" : "所有在res aw目录中的文件会被压缩，这样会更减少资源的占用。",
    "optionAnswer" : "C",
    "answer" : "可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中",
    "optionB" : "所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。",
    "type" : "1",
    "optionA" : "可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。",
    "question" : "将SQLite数据库(dictionary.db文件)与apk文件一起发布说法有误的是?"
  },
  {
    "ID" : "55bb36a7e4b0809382e39908",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "2.22",
    "optionC" : "1.12",
    "optionAnswer" : "D",
    "answer" : "pt: point，是一个标准的长度单位，1pt＝1\/72英寸，用于印刷业，非常简单易用；\n\nsp: scaled pixels(放大像素). 主要用于字体显示best for textsize。在 Android 中，  1pt 大概等于 2.22sp",
    "optionB" : "1.22",
    "type" : "1",
    "optionA" : "2.12",
    "question" : "在Android中，1PT大概等于多少SP？"
  },
  {
    "ID" : "55bb36a7e4b0809382e39919",
    "typeID" : "549936a8e4b06783458bdb1c",
    "optionD" : "“standard”对于没一个启动Intent都会生成一个activity的新实例； \n“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 \n比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 \n如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D \n如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。\n“singleInstance”是其所在栈的唯一activity，它会每次都被重用。\n“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。\n当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。",
    "optionC" : "“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。",
    "optionAnswer" : "B",
    "answer" : "在android里，有4种activity的启动模式，分别为： \n“standard” (默认) \n“singleTop” \n“singleTask” \n“singleInstance”\n它们主要有如下不同：\n1. 如何决定所属task \n“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。 \n如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。 \n“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。\n2. 是否允许多个实例 \n“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例； \n“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。\n3. 是否允许其它activity存在于本task内 \n“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。 \n而另外三种模式，则可以和其它activity共存。\n4. 是否每次都生成新实例 \n“standard”对于没一个启动Intent都会生成一个activity的新实例； \n“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 \n比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 \n如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D \n如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。\n“singleInstance”是其所在栈的唯一activity，它会每次都被重用。\n“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。\n当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。",
    "optionB" : "“standard”和”singleTop”可以被实例化多次，并且存在于相同的task中，且一个task可以包括一个activity的多个实例； \n“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。",
    "type" : "1",
    "optionA" : "“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。 \n如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。 \n“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。",
    "question" : "关于Activity的启动模式不同点说法错误的是？"
  }
]}