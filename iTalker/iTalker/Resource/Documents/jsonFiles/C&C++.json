{"success":1,"total":114,"result":[{
    "ID" : "55b6edfce4b0ef2b5755eb13",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : " ‘T’或’F’",
    "optionC" : "1",
    "optionAnswer" : "B",
    "answer" : "逻辑表达式是指运算符为或||、与&&、非！的表达式。返回值为0或1，0表示false，非0表示true。关系表达式是指运算符为<,<=,>,>=,==,!=的表达式。返回值同样为0或1。",
    "optionB" : "0或1",
    "type" : "1",
    "optionA" : "0",
    "question" : "C语言中，关系表达式和逻辑表达式的值是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb11",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "1",
    "optionC" : "0",
    "optionAnswer" : "A",
    "answer" : "a<b?a:b的意思是，如果a<b为true结果为a；如果a<b为false结果为b。本题中a<b为true，因此结果为3。",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "3",
    "question" : "如果int a=3,b=4；则条件表达式\"a<b? a:b\"的值是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb20",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "a>=10‖a<=0",
    "optionC" : "a>=10 &&a<=0",
    "optionAnswer" : "D",
    "answer" : "逻辑运算符“||”表示或的意思。",
    "optionB" : "a>=0|a<=10",
    "type" : "1",
    "optionA" : " a>=10 or a<=0",
    "question" : "能正确表示逻辑关系：“a≥=10或a≤0”的C语言表达式是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb2b",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "9次",
    "optionC" : "10次",
    "optionAnswer" : "A",
    "answer" : "while(a<10) x++; a++; 这句话里while语句是不包含a++的 只循环x。",
    "optionB" : "不确定次",
    "type" : "1",
    "optionA" : "无限次",
    "question" : "若有“int a=1,x=1;”,则循环语句“while(a<10) x++; a++;”的循环执行"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb23",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "if(a==0) s1; else s2;",
    "optionC" : "if(a!=0) s1; else s2;",
    "optionAnswer" : "D",
    "answer" : "答案A if(a) S1; else S2   ，假设a==0，那么if语句条件为假，执行S2，假设a！=0，执行S1；答案B if(a==0) S2; else S1;，假设a==0，那么if语句条件为真，执行S2，假设a！=0，执行S1；答案C if(a!=0) S1; else S2，假设a==0，那么if语句条件为假，执行S2，假设a！=0，执行S1；答案D if(a==0) S1; else S2;，假设a==0，那么if语句条件为真，执行S1，假设a！=0，执行S2",
    "optionB" : "if (a= =0)  s2;  else  s1;",
    "type" : "1",
    "optionA" : "if (a)   s1 ;  else  s2; ",
    "question" : "在下面的条件语句中（其中s1和s2表示是C语言的语句），只有一个在功能上与其它三个语句不等价，它是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb10",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "3",
    "optionC" : "1",
    "optionAnswer" : "C",
    "answer" : "%指的是取余数，5除以2的余数为1。",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "2.5",
    "question" : "在C语言程序中，表达式5%2的结果是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb30",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "4",
    "optionC" : "死循环",
    "optionAnswer" : "A",
    "answer" : "首先，i=1，进入for循环，执行sum+=i后sum的值为3；执行i+=2，i的值变为3，此时仍然满足i<=3的循环条件，继续执行for循环，sum的值变为6；再次执行i+=2后i的值变为5，不满足循环条件，退出循环，因此sum的值为6。",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "6",
    "question" : "有如下程序\nmain(){\n    int i,sum=2;\n    for(i=1;i<=3;i+=2){\n        sum+=i;printf(“%d\\n”,sum);\n    }\n}\n该程序的执行结果是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb29",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "a=50 b=30 c=50",
    "optionC" : "a=50 b=30 c=10    ",
    "optionAnswer" : "B",
    "answer" : "if（a>b） a=b；条件不成立，此语句不执行；b=c；直接赋值语句，b直接等于c=30；c=a；c直接等于a。",
    "optionB" : "a=10 b=30 c=10",
    "type" : "1",
    "optionA" : "a=10 b=50 c=10  ",
    "question" : "以下程序段的输出结果是( )\nint a=10,b=50,c=30;\nif(a>b) a=b;\nb=c;\nc=a;\nprintf(\"a=%2d b=%2d c=%2d\\n\",a,b,c);"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb15",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "(int)(11.0\/3+0.5)",
    "optionC" : "(float)11\/3",
    "optionAnswer" : "D",
    "answer" : "A.整数的运算结果仍然为整数，结果为3；B.由于11.0是float型，因此计算结果也为float型，值为3.0；C.结果强制类型转换为float类型，值为3.0；D.11.0\/3+0.5=4.1，强制类型转换为整型，结果为4。",
    "optionB" : "11.0\/3",
    "type" : "1",
    "optionA" : "11\/3",
    "question" : "下面(    )表达式的值为4."
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb1b",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "4.6",
    "optionC" : "4.333333",
    "optionAnswer" : "A",
    "answer" : "13.8取整之后等于13，13对3求余是1，选A。",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "1",
    "question" : "若“int n; float f=13.8;”,则执行“n=(int)f%3”后，n的值是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb26",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "有语法错误，无输出结果",
    "optionC" : "＃＃＃＃&&&&",
    "optionAnswer" : "A",
    "answer" : "k的值为-3，满足if语句中的条件k<=0，因此输出结果为A。",
    "optionB" : "&&&&",
    "type" : "1",
    "optionA" : "＃＃＃＃",
    "question" : "若k是int型变量，且有下面的程序段：\nint k;\nk= -3;\nif  (k<=0)\n    printf(“####”);\nelse\n    printf(“&&&&”);\n上面程序段的输出结果是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb32",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "char a[3]={‘a’,’b’,’c’}",
    "optionC" : "int k=5,a[k];",
    "optionAnswer" : "D",
    "answer" : "A应为方括号[]；B中没有定义数组大小；C方括号内必须是常量；D正确。",
    "optionB" : "int a[];",
    "type" : "1",
    "optionA" : "char a(10);",
    "question" : "以下对一维数组a的正确说明是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb19",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "以上结果都不对",
    "optionC" : "3",
    "optionAnswer" : "C",
    "answer" : "m=(w<x)?w:x;将w和x中的较小值赋给m，即m=11；m=(m<y)?m:y;将m和y中的较小值赋给m，即m=3",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "question" : "有：int w=11,x=12,y=3,m; 执行下面语句后m的结果是(  ) m=(w<x)?w:x; m=(m<y)?m:y;"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb0c",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "double",
    "optionC" : "int",
    "optionAnswer" : "C",
    "answer" : "当操作数的类型不同，而且不属于基本数据类型时，经常需要强制类型转换，将操作数转化为所需要的类型。显式强制类型转换需要使用强制类型转换运算符，格式如下：type（<expression>）或（type）<expression>其中，type为类型描述符，如int，float等。<expression>为表达式。经强制类型转换运算符运算后，返回一个具有type类型的数值，这种强制类型转换操作并不改变操作数本身，运算后操作数本身未改变。",
    "optionB" : "char",
    "type" : "1",
    "optionA" : "float",
    "question" : "若有以下类型说明语句：char w;int x;float y;double z;则表达式w-x*y\/z的结果为( D  )类型,表达式(int)(x+y-z*w)的结果为(   )类型。"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb17",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "d'",
    "optionC" : "错误",
    "optionAnswer" : "B",
    "answer" : "c2 的ASCII码为十进制数68，因为c2字符型的所以应该是D。",
    "optionB" : "‘D’",
    "type" : "1",
    "optionA" : "68",
    "question" : "已知字母A的ASCII码为十进制数65，且c2为字符型，则执行语句c2='A'+'6'-'3';后，c2中的值为"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb22",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "10",
    "optionC" : "11",
    "optionAnswer" : "A",
    "answer" : "由于case中缺少break语句，因此在case 10之后程序会一直执行，因此结果为13。",
    "optionB" : "12",
    "type" : "1",
    "optionA" : "13",
    "question" : "若int i=10; 执行下列程序后，变量i的正确结果是\nswitch ( i ) {\n    case   9:  i+=1;\n    case  10:  i+=1;\n    case  11:  i+=1;\n    default :  i+=1;\n}"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb2f",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "1",
    "optionC" : "4",
    "optionAnswer" : "C",
    "answer" : "在j=3时仍然满足循环条件，因此j仍然会执行一次j++的操作，此时j=4，不满足j<=3的条件，退出循环。",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "0",
    "question" : "执行语句{for(j=0;j<=3;j++) a=1;}后变量j的值是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb0e",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "0",
    "optionC" : "3",
    "optionAnswer" : "B",
    "answer" : "c语言中整数的运算结果仍然为整数。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "1.6",
    "question" : "在C语言程序中，表达式8\/5的结果是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb1e",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "非0的数",
    "optionC" : "非0整数",
    "optionAnswer" : "D",
    "answer" : "C语言中，0是假值，其他的都是真值。",
    "optionB" : "大于0的数",
    "type" : "1",
    "optionA" : "true",
    "question" : "在C语言中，认为(        )为逻辑\"真\" "
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb1a",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "b=1\/(a*1.0)",
    "optionC" : "b=1\/(float)a ",
    "optionAnswer" : "B",
    "answer" : "B中整数与整数的运算结果仍然为整数，所以1\/a的值为0，强制转化为float型后结果为0.0。",
    "optionB" : "b=(float)(1\/a) ",
    "type" : "1",
    "optionA" : "b=1.0\/a ",
    "question" : "设整型变量 a=2，则执行下列语句后，浮点型变量b的值不为0.5的是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb1f",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "(x<=y)&(y<=z)",
    "optionC" : "(x<=y<=z) ",
    "optionAnswer" : "A",
    "answer" : "题中X<=Y<=Z的意思为X<=Y并且Y<=Z，在c语言中，要表示“且”的关系，应用“与”逻辑运算符，即“＆＆”，故选择A选项。",
    "optionB" : "(x<=y)AND(y<=z)",
    "type" : "1",
    "optionA" : "(x<=y)&&(y<=z)",
    "question" : "表示关系x<=y<=z的c语言表达式为"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb24",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "0",
    "optionC" : "9",
    "optionAnswer" : "A",
    "answer" : "if（a=0）y—；\/\/a=0是先给a赋值为0再判断,这里的a为0了if(a)就是假的,不成立；else if （a>0）\/\/继续判断 a>0  上面已经能 a赋值为0,这里也不成立；y++；else y+=y；\/\/做这一步了,y=y+y=20，所以a的值是0,y的值是20",
    "optionB" : "11",
    "type" : "1",
    "optionA" : "20",
    "question" : "假定所有变量均已正确定义，则下列程序段运行后y的值是（ ）\nint a=0,y=10;\nif(a=0)\n    y--;\nelse if(a>0)\n    y++;\nelse\n    y+=y;"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb2d",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "有语法错误",
    "optionC" : "循环执行二次",
    "optionAnswer" : "A",
    "answer" : "进入do循环后x的值变为1，满足while(x>0)的条件，因此会一直执行do while，造成死循环。",
    "optionB" : "循环执行一次",
    "type" : "1",
    "optionA" : "是死循环",
    "question" : "以下程序段( )\nx=-1;\ndo {\n    x=x*x; \n}while(x>0);"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb27",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "a=2,b=2",
    "optionC" : "a=1,b=0",
    "optionAnswer" : "D",
    "answer" : "case后面跟的必须是整型常量表达式。进入case后，如果没有遇到break语句就会一直往下执行，后面其他case或default分支的语句也会被执行到，直到遇到break，或者执行到整个switch语句块的末尾。题目中给出了三个case语句：case 0、case 1、case 2。当x为0时，从case 1语句开始执行，因为没有break语句，将一直执行到函数末尾结束，即执行case 1、case 2两条语句。执行完case 1时，a=1，b=1；执行完case 2时，a=2，b=2。",
    "optionB" : "a=1,b=1",
    "type" : "1",
    "optionA" : "a=2,b=1",
    "question" : "main(){\n    int x=0, a=0, b=0;\n    switch(x){\n        case 0:\n            b++;\n        case 1:\n            a++;\n        case 2:\n            a++;\n        b++;\n    }\n    printf(“a=%d,b=%d\\n”,a,b);\n}该程序的输出结果是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb2a",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "y==1",
    "optionC" : "y=!0",
    "optionAnswer" : "A",
    "answer" : "y == 0 !y就是非0 真；y!=1 y 可以等于 2,3,!y 是假；y!=0 y 是1时 y!=0 是真 ,!y是假；y==1 y是1时 是真,!y 是假",
    "optionB" : "y!=1",
    "type" : "1",
    "optionA" : "y==0",
    "question" : "语句while（！y）；中的表达式！y等价于"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb31",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "5",
    "optionC" : "4",
    "optionAnswer" : "C",
    "answer" : "当i=3时不满足条件退出循环，但是“i++”使i再加1，就变成了4",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "2",
    "question" : "执行下列语句后，变量i的值为（）\nfor ( i=0;  i++<3 ;   ) ;"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb2e",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "9次",
    "optionC" : "10次",
    "optionAnswer" : "A",
    "answer" : "i被赋值为10与x>0是永真的。一开始i=0只是给i附了一个初值。所以程序会执行无数次。",
    "optionB" : "不确定次",
    "type" : "1",
    "optionA" : "无限次",
    "question" : "循环“for(i=0,x=1;i=10&&x>0;i++);”的循环执行"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb18",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "同一个运算符号在不同的场合可以有不同的含义",
    "optionC" : "在赋值表达式中等号(=)左边的变量和右边的值可以是不同类型",
    "optionAnswer" : "A",
    "answer" : "C语言中，大小写代表不同的两个标识符。A错误。",
    "optionB" : "不同类型的变量可以在一个表达式中",
    "type" : "1",
    "optionA" : "大写字母和小写字母的意义相同",
    "question" : "下列关于C语言的叙述错误的是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb14",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "!((a<b)&&!c||1)",
    "optionC" : "a||b+c&&b-c  ",
    "optionAnswer" : "D",
    "answer" : "||和&&的优先级高于+和-，||和&&的优先级相等，且是左结合的，就是从左边开始结合到右边。",
    "optionB" : "a<=b",
    "type" : "1",
    "optionA" : "’a’&&’b’",
    "question" : "设a,b和c都是int型变量，且a=3,b=4,c=5,则下面表达式中，值为0的表达式是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb0d",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "〈=",
    "optionC" : "=",
    "optionAnswer" : "A",
    "answer" : "%=是取模运算，也就是求余数的运算，只有整数才能取模。",
    "optionB" : "\/",
    "type" : "1",
    "optionA" : "%=",
    "question" : "C语言中运算对象必须是整型的运算符是(      )"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb28",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "3",
    "optionC" : "2",
    "optionAnswer" : "C",
    "answer" : "x值为-10，y值为1，在第一个if判断中满足条件，进入第二层if判断，由于y>0，执行else语句，z=z+1=2，所以结果为C。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "以下程序的输出结果是:( )\nmain(){\n    int x = -10,y = 1,z = 1;\n    if(x<y)\n        if(y<0)\n            z=0;\n        else\n            z = z+1;\n    printf(“%d\\n”,z);\n}"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb1d",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "（int）x+y 和（int）（x+y）是完全等价的表达式",
    "optionC" : "强制类型转换时，类型说明符必须加括号",
    "optionAnswer" : "C",
    "answer" : "A.表达式正确；B.C语言允许类型混合运算；C正确；D.(int)x+y先将x转换为整型，再与y进行加法运算，(int)(x+y)先将x与y相加，结果再转换为整型，两个式子是不同的。",
    "optionB" : "C语言不允许类型的混合运算",
    "type" : "1",
    "optionA" : "'x'+5是一个错误的表达式",
    "question" : "以下说法正确的是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb12",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "1",
    "optionC" : "2",
    "optionAnswer" : "B",
    "answer" : "a<b?a:b的意思是，如果a<b为true结果为a；如果a<b为false结果为b。本题中x<z为true，结果为y的值3。",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "4",
    "question" : "若int x=2,y=3,z=4 则表达式x<z?y:z的结果是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb0f",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "30",
    "optionC" : "40",
    "optionAnswer" : "B",
    "answer" : "例如式子a+=b，即把a+b的值再赋值给a。对于本题来说，x+=x即把x+x的值赋给x，x最后为20。",
    "optionB" : "20",
    "type" : "1",
    "optionA" : "10",
    "question" : "设x为int型变量,则执行以下语句后,x的值为"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb21",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "c1>=’A’ && c1<=’Z’",
    "optionC" : "（’A’<=c1）AND (‘Z’>=c1）",
    "optionAnswer" : "D",
    "answer" : "C语言规定，字符常量在程序中要用单引号括起来。判断c1是否为大写字母的充要条件c1＞='A'，和c1='Z'，用逻辑与(&&)来表示。所以选项D)正确",
    "optionB" : "(c1>=’A’) & (c1<=’Z’)",
    "type" : "1",
    "optionA" : "’A’<=c1<=’Z’ ",
    "question" : "判断char型变量c1是否为大写字母的表达式为"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb1c",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "puts(x)",
    "optionC" : "putchar(x)",
    "optionAnswer" : "C",
    "answer" : "输出函数是putchar和printf，putchar只能输出字符常量和字符型变量。getchar和putchar是一对，针对字符及字符变量进行操作，getchar()可以接受各种字符，包括空格回车，相应的putchar可以输出一个字符。",
    "optionB" : "fputc(x)",
    "type" : "1",
    "optionA" : "getchar(x)",
    "question" : "在C语言的库函数中,可以输出char型变量x值的语句是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb25",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "3",
    "optionC" : "35",
    "optionAnswer" : "B",
    "answer" : "程序是一步一步往下执行的, 对于if语句，只有为真的时候才会执行其后面的语句if(!a)会执行后面的语句，因为非零即为真，执行到这步后，x=34,但是程序继续往下，if(c)后面的语句不执行，就执行了else后的语句，所以x=4。",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "34",
    "question" : "假定所有变量均已正确定义，则下列程序段运行后x的值是（）。\na=b=c=0;\nx=35;\nif(!a) \n    x--;\nelse\n    if(b);\nif(c)\n    x=3;\nelse\n    x=4;"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb2c",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : " do x++ while(x==10);",
    "optionC" : "do 2;while(x==b)",
    "optionAnswer" : "D",
    "answer" : "D选项中x++是一条语句，后面要加;。",
    "optionB" : "while(0);",
    "type" : "1",
    "optionA" : "while(x=y) 5；",
    "question" : "下列循环语句中有语法错误的是"
  },
  {
    "ID" : "55b6edfce4b0ef2b5755eb16",
    "typeID" : "54993f49e4b06783458c3a94",
    "optionD" : "6",
    "optionC" : "5",
    "optionAnswer" : "C",
    "answer" : "x=x%(y+z)，x=5%(5+5)=5，结果为5。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "已知int x=5,y=5,z=5；执行语句x%=y+z；后，x的值是"
  },
  {
    "ID" : "55f2e4fee4b0152a61143232",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "未知",
    "optionC" : "111111",
    "optionAnswer" : "B",
    "answer" : "当*p = 5时，会再调用add(p)，然后先输出*p = 6，然后进行判断，直接跳出程序。所以从1一直到6",
    "optionB" : "123456",
    "type" : "1",
    "optionA" : "12345",
    "question" : "下面程序运行的结果是（）。#include<stdio.h>\nvoid add(int *p)\n{\n    (*p)++;\n    printf(\"%d\",*p);\n    if (*p>5)\n    {\n        return;\n    }\n    add(p);\n}\nint main()\n{\n    int i=0;\n    add(&i);\n    return 0;\n}"
  },
  {
    "answer" : "如果只有一条鳄鱼，怪物显然是危险的；\n两条鳄鱼的时候，先下手的鳄鱼会成为另外一条鳄鱼的食物，所以怪物显然很安全；\n三条鳄鱼的时候，把先下手的鳄鱼当做怪物，就会回到两条鳄鱼的状态，此时先下手的鳄鱼非常安全，也就是说怪物显然很危险；\n四条鳄鱼的时候，先下手的鳄鱼会面临三条鳄鱼的状态，此时也就没有鳄鱼准备先下手，所以怪物很安全；\n我们很容易发现，吞吃过怪物的鳄鱼会成为下一个怪物，成为N-1条鳄鱼的猎物，也就是说，如果N-1的时候安全，则N的时候危险；\n综上所述，奇数条鳄鱼怪物不安全，偶数条鳄鱼怪物安全。",
    "ID" : "55f2e51de4b0152a6114336e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "某怪物被海水冲上一个孤岛。醒来时他发现自己处于险境。周围有N条鳄鱼都虎视眈眈的盯着他。每条鳄鱼看上去都饿得足以把他吞下去。不过，事情也未必真的那么糟糕。鳄鱼吞下他是要花费体力的。这些鳄鱼现在的体力都相当，由于猎食需要花费体力，所以吞下怪物的鳄鱼会由于体力下降而可能被周围的某条鳄鱼吞了。类似的，吞鳄鱼的这条鳄鱼也可能被其他鳄鱼吞了。因此，虽然有食物可猎，但他们自己并不想成为其他鳄鱼的猎食对象。正所谓，螳螂捕蝉，黄雀在后。所以鳄鱼们在确保自己生命安全的情况下才会发动进攻。那么，怪物到底安全么？为什么？"
  },
  {
    "ID" : "55f2e4fde4b0152a611431e9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "栈，只读存储区",
    "optionC" : "堆，只读存储区",
    "optionAnswer" : "D",
    "answer" : "有以下程序\n\n#include <stdio.h>\nint fun( char s[ ] )\n{\n    char *p = s ;\n    while ( *p ! = 0 ) p+ +;\n    return ( p - s) ;\n}\nmain()\n{\n    printf ( \"% d\\n \", fun ( \"OABCDEF\" ) ) ;\n}\n程序运行后的输出结果是?",
    "optionB" : "栈，栈",
    "type" : "1",
    "optionA" : "栈，堆",
    "question" : " int main()\n{\n    char *p = \"hello,world\";\n    return 0;\n}\np和\"hello,world\"存储在内存哪个区域？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de80d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "无限",
    "optionAnswer" : "A",
    "answer" : "判断语句  i = j = 0;  执行后，i = 0，此时判断i的值为假，\n一次都不执行",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "下列for循环的循环体执行次数为\nfor(int i=10, j=1; i=j=0; i++, j--)"
  },
  {
    "ID" : "55f2e46ae4b0152a6114314b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "重载错误",
    "optionC" : "选项A）和选项B）都可能",
    "optionAnswer" : "D",
    "answer" : "友元函数重载时,参数列表为1,说明是1元,为2说明是2元\n成员函数重载时,参数列表为空,是一元,参数列表是1,为2元",
    "optionB" : "二元运算符",
    "type" : "1",
    "optionA" : "一元运算符",
    "question" : "如果友元函数重载一个运算符时，其参数表中没有任何参数则说明该运算符是："
  },
  {
    "answer" : "设计一个链式的队列，由于队列频繁的有人来和走（插入和删除），所以链式队列的效率最好，队列中存放的元素是一个对象和队长，这个对象包括了 Person、location属性，Person是排队的用户，而location是用户的位置，当有用户进来的时候，只能从队尾进入，此时将他的 Person对象加入，其location等于队长加1，并且队长加1；如果有用户退出（任何位置），找到退出的用户的前一个用户，删除退出用户的结点， 并且其后的其他用户的location-1，队长也-1.\n为了更快的找到退出的用户，可以考虑用HashMap存储用户的key：Hash值，val：链表结点的位置。",
    "ID" : "55f2e51de4b0152a61143371",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请设计一个排队系统，能够让每个进入队伍的用户都能看到自己在队列中所处的位置和变化，队伍可能随时有人加入和退出；当有人退出影响到用户的位置排名时需要及时反馈到用户"
  },
  {
    "answer" : "#include\"iostream\"\n#include\"string\"\n#define MAX 100\nusing namespace std;\nbool check(string str1,string str2)\n{\n    bool flag = true;\n    for(int i=0; i<str1.length(); i++)\n    {\n        if(str1[i]!=str2[str1.length()-1-i])\n        {\n            flag = false;\n            return flag;\n        }\n    }\n    return flag;\n}\nint main(int argc, char* argv[])\n{\n    string str[MAX];\n    int n,a[MAX];\n    bool flag[MAX];\n    cin>>n;\n    for(int i=0; i<n; i++)\n    {\n        cin>>str[i];\n        a[i] = str[i].length();\n        flag[i] = true;\n    }\n    int num = 0;\n    for(int i=0; i<n; i++)\n    {\n        int len = a[i];\n        if(flag[i]==true)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(flag[j]==true&&len==a[j])\n                {\n                    if(check(str[i],str[j]))\n                    {\n                        num++;\n                        flag[i] = false;\n                        flag[j] = false;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i=0; i<n; i++)\n        cout<<str[i]<<'\\t';\n    cout<<endl;\n    cout<<\"The Number of Matched String Is: \"<<num<<endl;\n    getchar();\n    getchar();\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a61143375",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "编程题：给定一个文件每一行是字符串，找出所有的逆序对，比如abc和cba是逆序的对。"
  },
  {
    "answer" : "2xx 4xx 5xx\nHTTP 1.1中的状态码被分为五大类： \n100-199 用于指定客户端应相应的某些动作。 \n200-299 用于表示请求成功。 \n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 \n400-499 用于指出客户端的错误。 \n500-599 用于支持服务器错误",
    "ID" : "55f2e51ce4b0152a6114332b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "http状态码中，()表示访问成功，()表示坏请求，()表示服务不可用"
  },
  {
    "answer" : "\/\/筛选法，再利用bitmap位标示整数\n#include <vector>\nusing namespace std;\n \nclass Solution {\npublic:\n    \/**\n     * 获取n个素数\n     * n: 素数个数\n     * 返回：最小的N个素数\n     *\/\n    vector<int> getPrimes(int n) {\n        vector<int> ret;\n        if(n<=1) return ret;\n        long i,j;\n        unsigned char arr[1<<13]={0};\n        for(i=2;i<(1<<16);++i){\n            for(j=i+i;j<(1<<16);j=j+i){\n                arr[j\/8]=arr[j\/8]|(1<<(j%8));\n            }\n        }\n        for(i=2;i<(1<<16)&&n>0;++i){\n            if(!(arr[i\/8]&(1<<(i%8)))){\n                ret.push_back(i);\n                --n;\n            }\n        }\n        return ret;\n    }\n};",
    "ID" : "55f2e51de4b0152a61143384",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "写函数，输出前N个素数。不需要考虑整数溢出问题，也不需要使用大数处理算法。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143203",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "数组X的长度小于数组Y的长度",
    "optionC" : "数组X的长度大于数组Y的长度",
    "optionAnswer" : "C",
    "answer" : "char x[]=\"abcdefg\";中会隐式的在末尾添加空字符，而char y[]={'a','b','c','d','e','f','g'};则不会添加，空字符的出现取决于系统中空字符的出现，这种定义下不是一个字符串。",
    "optionB" : "数组X和数组Y长度相同",
    "type" : "1",
    "optionA" : "数组X和数组Y等价",
    "question" : "给出以下定义, 则正确的叙述为\nchar x[]=\"abcdefg\";\nchar y[]={'a','b','c','d','e','f','g'};"
  },
  {
    "ID" : "55f2e469e4b0152a6114312d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "66",
    "optionC" : "35",
    "optionAnswer" : "A",
    "answer" : "本题重点考查逻辑运算符和关系运算符的相关知识,已知变量x为整型变量,并赋值为35,变量z为字符型变量,并赋值为'B'。语句B =((x)&&(z <'b'));中,(x)的值为1,'B'的asscii码小于'b'的asscii码,所以(z <'b')的值也为1,1&&1结果为1。因此A选项正确。",
    "optionB" : "0",
    "type" : "1",
    "optionA" : "1",
    "question" : "有以下程序\n\n#include <stdio. h>\nmain(){\n    int x =35,B;\n    char z ='B';\n    B =((x)&&(z <'b'));\n    printf(\"%d\\n\",B);\n}\n程序运行后的输出结果是"
  },
  {
    "answer" : "翻手算法：\n设置有个函数为倒序排列：void Rorder(char *pF,char *pE);\n\nvoid Rorder(char *pF, char *pE)\n{\n    char temp;\n    while (pF <= pE)\n    {\n        temp = *pF;\n        *pF = *pE;\n        *pE = temp;\n    }\n}\n \nvoid *pszStringRotate(char *pszString, int nCharsRotate)\n{\n    char *pR = pszString;\n    int n = 0;\n    while (pszString + n++ ！ = ‘\\n’); \/\/得到字符串长度\n    if (n < nCharsRotate) return pR; \/\/入口参数检测\n \n    Rorder(pszString, pszString + nCharsRotate ); \/\/C B A\n    pszString = pR;\/\/归位\n    Rorder( pszString + nCharsRotate, pszString + n - 1); \/\/GFED\n    pszString = pR;\n    Rorder(pszString, pszString + n - 1); \/\/DEFGABC\n    return pR;\n}\n大致过程如下：\nABCDEFG\n第一步：局部翻转\nABC DEFG == = 》 CBA GFED\n第二步：整体翻转\nCBA GFED    == = 》 DEFGABC",
    "ID" : "55f2e51de4b0152a61143369",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "字符串左移:\nvoid *pszStringRotate(char *pszString, intnCharsRotate)\n比如ABCDEFG，移3位变DEFGABC，要求空间复杂度O（1），时间复杂度O（n）。"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c7c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8／2和6.0／2.0",
    "optionC" : "7.0／2和7／2",
    "optionAnswer" : "A",
    "answer" : "小数默认的类型为double类型，整数除以整数结果是取整的结果。A、B、C和D项的第一项\n分别是double、double、double和int类型的,第二项分别是double、int、int和double类型，所\n以选择A项。",
    "optionB" : "5／2.0和5／2",
    "type" : "1",
    "optionA" : "7.0／2.0和7.0／2",
    "question" : "在下列成对的表达式中，运算结果类型相同的一对是（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "k=3 a=14",
    "optionC" : "k=6 a=11",
    "optionAnswer" : "B",
    "answer" : "当k=0时,执行while一次,得到k=1,a为2;当k=1时,执行while一次,得到k=2,a为4;当k=2时,执行while一次,得到k=3,a=7;当k=3时,执行while一次,得到k=4,a为12;所以答案为B选项。",
    "optionB" : "k=4 a=12",
    "type" : "1",
    "optionA" : "k=5 a=15",
    "question" : "#include<stdio. h>\nmain()\n{ \n    char *s=\"12134\";\n    int k=0, a=0;\n    while(s[k+1])\n    { \n       k++;\n       if(k%2= =0)\n       {\n            a=a+(s[k]-'0'+1);\n            continue;    \n       }\n       a=a+(s[k]-'0');\n    }\n    printf(\"k=%d a=%d\\n\",k,a);\n}\n程序运行后的输出结果是?"
  },
  {
    "answer" : "<span style=\"font-family: monospace;font-size: 13.0px;line-height: 19.0px;\">\/* 基数排序  *\/\n#include <iostream>\n#include <stdlib.h>\n#include <ctime>\n#include <algorithm>\n#include <cassert>\n#include \"windows.h\"\nusing namespace std;\n#define MAXN 100000000 #define MAXM 1000\nvoid find_max_data0( int dest[], int m, int src[], int n )\n{\n    fill( dest, dest + n, -INT_MAX );\n    for ( int i = 0; i < n; i++ )\n    {\n        for ( int j = 0; j < m; j++ )\n        {\n            if ( src[i] > dest[j] )\n            {\n                dest[j] = src[i];\n                break;\n            }\n        }\n    }\n}\nvoid find_max_data1( int dest[], int m, int src[], int n )\n{\n    make_heap( src, src + n );\n    for( int i = 0; i < m; i++ )\n    {\n        dest[i] = src[0];\n        pop_heap( src, src + n-- );\n    }\n}\nvoid radix_sort( int *src, int n )\n{\n    int *tmp = new int[MAXN];  int cnt[256];\n    for( int i = 0; i < 4; i++ ) {\n        memset( cnt, 0, sizeof(cnt) );\n        for( int j = 0; j < MAXN; j++ )\n        {\n            cnt[ ( src[j] >> (8 * i) ) & 0xff ]++;\n        }\n        for ( int j = 1; j < 256; j++ )\n        {\n            cnt[j] = cnt[j - 1] + cnt[j];\n        }\n        for( int j = MAXN - 1; j >= 0; j-- )\n        {\n            tmp[ -- cnt[ ( src[j] >> (8 * i) ) & 0xff ] ] = src[j]; swap( src, tmp );\n        }\n    }\n    delete [] tmp;\n}\nvoid find_max_data2( int dest[], int m, int src[], int n )\n{\n    radix_sort( src, n );\n    int j = 0;\n    for( int i = n - 1; i >= n - m; i-- )\n    {\n        dest[j++] = src[i];\n    }\n}\nint src[MAXN];\nint main()\n{\n    ( (unsigned int) time( NULL ) );\n    src[i] = abs( i * 6516187 );\n    DWORD t1, t2;\n    t1  = GetTickCount();\n    find_max_data2( dest2, MAXM, src, MAXN );  \n    t2 = GetTickCount();\n    printf( \"find_max_data2 time cost:%dn\", t2 - t1 );\n    for( int i = 0; i < MAXM; i++ )\n    {\n        printf( \"n\" );  return 0;\n    }\n} <\/span>",
    "ID" : "55f2e51de4b0152a6114338a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "一亿个数找最大的1000个数，要求效率高占用内存少。函数原型为：find_max_data(int* source_data, int* max_data)，其中source_data是存放一亿个数的数组，max_data用于存放其中最大的1000个数。"
  },
  {
    "answer" : "1.生存周期不同 全局变量:全局区（静态区）（static）：全局变量和静态变量是存储在一起的，初始化过的全局变量和静态变量在同一块区域，未初始化的全局变量和静态变量存放在一块相邻的区域内。此区域由系统在程序结束后释放 局部变量： 放在堆栈中。由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈\n2.作用范围不同 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回",
    "ID" : "55f2e51ee4b0152a611433cf",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c12",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数的功能",
    "optionC" : "函数参数类型",
    "optionAnswer" : "D",
    "answer" : "函数的声明，说明函数的参数、返回类型以及函数名，函数体即实现部分决定功能。所以\n函数的原型不能决定函数的功能。",
    "optionB" : "函数参数的个数",
    "type" : "1",
    "optionA" : "函数的返回类型",
    "question" : "在C++中，函数原型不能标识（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de80c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int i=0;printf(“%d%d\\n”,i++ i--)",
    "optionC" : "char *p=”hello”;char ch=*p++",
    "optionAnswer" : "C",
    "answer" : "C修改的是指针的值 没有修改指针指向常量的值 是正确的！ABD 行为结果是不可预测的 环境不同结果也不定 固都是未定义的",
    "optionB" : "char *p=”hello”;p[1]=’E’",
    "type" : "1",
    "optionA" : "int i=0;i=(i++);",
    "question" : "下列 C 代码中，不属于未定义行为的有：______。"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c80",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "派生类中一般数据成员的初始化",
    "optionC" : "派生类对象的初始化",
    "optionAnswer" : "C",
    "answer" : "派生类的构造函数的成员初始化，包括基类成员、基类对象成员和派生类成员。因\n为本身就是初始化定义的对象，在构造函数中再进行该类对象的初始化产生了循环定义，或者类\n中不能包括本身类的成员对象。所以选择C项。",
    "optionB" : "基类的对象初始化",
    "type" : "1",
    "optionA" : "基类的构造函数",
    "question" : "派生类的构造函数的成员初始化列表中，不能包含（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c82",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "3",
    "optionC" : "2",
    "optionAnswer" : "B",
    "answer" : "析构函数(destructor)?与构造函数相反，当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后”?的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。?以C++语言为例，析构函数名也应与类名相同，只是在函数名前面加一个波浪符~，例如~stud(?)，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数，它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "对于任意一个类，析构函数的个数最多为?(???)??"
  },
  {
    "ID" : "55f2e4fee4b0152a6114322d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "_group_6",
    "optionC" : "age+3",
    "optionAnswer" : "D",
    "answer" : "在C语言中,标识符的命名规则是:由字母(大、小写皆可)、数字及下划线组成，且第一个字符必须是字母或者下划线，长度为8位。在C语言中，大写字母和小写字母是有区别的，即作为不同的字母来看待，应引起注意。\nA以数字开头 \nB中有非法符号～ C中有非法符号+\nD正确",
    "optionB" : "group～6",
    "type" : "1",
    "optionA" : "6_group",
    "question" : "下列选项中，正确的C++标识符是"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143253",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int k, *p;  *p= &k;   scanf（“%d”,p）;",
    "optionC" : "int k, *p=&k;  scanf（\"%d\",p）;",
    "optionAnswer" : "C",
    "answer" : "A不对 P是指针型,scanf中&p应为整型变量空间的地址,而不是整型指针变量空间的地址\nB不对 scanf中&P是整型变量空间的地址,但P没有初值,P的值是不确定的 \nC正确\nD不对 *p=&k 是把k的地址赋值给*p，*p相当于p所指向的变量。这里p没有被赋初值，也就没有指向任何变量，所以使用*p时出错。",
    "optionB" : "int *p;  scanf（“%d”,p）;",
    "type" : "1",
    "optionA" : "int *p;  scanf（\"%d\",＆p）;",
    "question" : "以下程序段完全正确的是"
  },
  {
    "ID" : "55f2e4fee4b0152a61143244",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "非静态成员的生存期决定于该类的生存期，而静态成员则不存在生存期的概念",
    "optionC" : "静态成员能访问非静态的成员",
    "optionAnswer" : "C",
    "answer" : "因为静态成员存在于内存，非静态成员需要实例化才会分配内存，所以静态成员函数不能访问非静态的成员。因为静态成员存在于内存，所以非静态成员函数可以直接访问类中静态的成员",
    "optionB" : "非静态成员可以直接访问类中静态的成员",
    "type" : "1",
    "optionA" : "静态成员存在于内存，非静态成员需要实例化才会分配内存",
    "question" : "下面有关类的静态成员和非静态成员，说法错误的是？?"
  },
  {
    "answer" : "硬件方面：\n1、增加带宽，多机房部署，购买CDN。\n2、增加服务器，增加服务器的硬件资源。\n软件方面：\n1、首先为了防止因为大量用户下载APP，带宽占用过高导致网站原有的功能瘫痪或者体验严重下降，需要将APP下载的地址和网站服务分开部署。\n2、动静态分离，使用CACHE。\n2、NGINX反响代理，多点集群",
    "ID" : "55f2e51ce4b0152a61143330",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "A公司打算搭建一个Andriod App下载的Web站点，计划将目前常见的手机APP都放到这个网站上提供下载。因为业务开展初期下载量很小，技术部门就用了1台服务器，给服务器配置了一个公网IP对外进行服务。随着销售部门的推广到位，用户量和下载量呈指数级上载，要求技术部门马上进行改造。如果你是技术部门经理，你会怎么改造这个站点，以满足高负载的需求。\n提示：短时间修改网站的代码不现实，其他方面的各种改造建议都可以，建议越多越好。"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c1f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "实现运行时多态性的机制称为动态多态性",
    "optionC" : "运行时的多态性可通过模板和虚函数实现",
    "optionAnswer" : "C",
    "answer" : "多态性分为静态的和动态的。静态通过函数的重载来实现，动态是通过基类指针或\n基类引用和虚函数来实现的。所以错误的是C项。",
    "optionB" : "编译时的多态性可通过函数重载实现",
    "type" : "1",
    "optionA" : "C++语言的多态性分为编译时的多态性和运行时的多态性",
    "question" : "有关多态性说法不正确的是（）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c0e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "对象之间的信息传递是通过消息进行的",
    "optionC" : "对象是类的一个变量",
    "optionAnswer" : "A",
    "answer" : "A对象在C＋＋中才有，包括数据和操作两项，而C中的变量只有数据，没有操作。所\n以A项错误。",
    "optionB" : "对象代表着正在创建的系统中的一个实体",
    "type" : "1",
    "optionA" : "对象就是C语言中的结构变量",
    "question" : "关于对象概念的描述中，说法错误的是（）"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143252",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "出错",
    "optionC" : "9",
    "optionAnswer" : "",
    "answer" : "注意括号中逗号运算符返回值是最后的表达式的值，题中第一个参数为c+a=4, 后一个参数为e=5,\n所以结果为9",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "15",
    "question" : "以下程序的输出结果为\n\n#include \"stdio.h\"\nint func(int x, int y)\n{\n    return (x + y);\n}\nint main()\n{\n    int a = 1, b = 2, c = 3, d = 4, e = 5;\n    printf(\" % d\\n\", func((a + b, b + c, c + a), (d, e)));\n     \n    return 0;\n}"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7fc",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "fastcall",
    "optionC" : "pascal",
    "optionAnswer" : "A",
    "answer" : "可变参数函数需要由调用者清栈，因为当前函数并不知道要有多少参数被传入，所以必须用cdcel",
    "optionB" : "stdcall",
    "type" : "1",
    "optionA" : "cdecl",
    "question" : "Which of the following calling convention(s) support(s) support variable-length parameter(e.g. printf)?"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c70",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "抽象类",
    "optionC" : "虚函数",
    "optionAnswer" : "B",
    "answer" : "类族即同一个类派生出来的类，各个类是兄弟或父子关系。",
    "optionB" : "类的继承",
    "type" : "1",
    "optionA" : "类的嵌套",
    "question" : "C++语言建立类族是通过（）"
  },
  {
    "answer" : "char、int、byte、short、long、long long、double、float\nstruct\n对象类型\nlong、int占多少字节，得看计算机cpu是多少位的。16位机器上，int2字节，long4字节，32位机器上二者都是4字节，64位机器上，int4字节，long8字节\nint是最基本的类型，一般要和cpu的自宽保持一致，保证效率。",
    "ID" : "55f2e51de4b0152a61143373",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "C++有哪些数据类型?为什么long和int都是4字节?"
  },
  {
    "answer" : "FILLUserInfo函数的问题：\n因为结构体USERINFO的成员szName最多容纳20个字节，如果拷贝的名字超过20字节，就超越了数组的边界，引起段错误。\nmain()函数的问题：\narUserInfos有100个元素，如果在输入的用户个数超过100，那么也会引起该数组的边界越界，同样是段错误",
    "ID" : "55f2e51ee4b0152a611433bd",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "从程序健壮性进行分析,下面的 FillUserInfo 函数和 main 函数分别存在什么问题?\n#define MAX_NAME_LEN 20\nstruct USERINFO\n{\n    int nAge;\n    char szName[MAX_NAME_LEN];\n};\nvoid FillUserInfo(USERINFO *parUserInfo)\n{\n    stu::cout << \"请输入用户的个数:\";\n    int nCount = 0;\n    std::cin >> nCount;\n    for (int i = 0; i < nCount; i++)\n    {\n        std::cout << \"请输入年龄:\";\n        std::cin >> parUserInfo[i]->nAge;\n        std::string strName;\n        std::cout << \"请输入姓名:\";\n        std::cin >> strName;\n        strcpy(parUserInfo[i].szName, strName.c_str());\n    }\n}\nint main(int argc, char *argv[])\n{\n    USERINFO arUserInfos[100] = {0};\n    FillUserInfo(arUserInfos);\n    printf(\"The first name is:\");\n    printf(arUserInfos[0].szName);\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "answer" : "解答：数据库中的锁是网络数据库中的一个非常重要的概念，它主要用于多用户环境下保证数据库完整性和一致性。各种大型数据库所采用的锁的基本理论是一致的，但在具体实现上各有差别。目前，大多数数据库管理系统都或多或少具有自我调节、自我管理的功能，因此很多用户实际上不 清楚锁的理论和所用数据库中锁的具体实现。在数据库中加锁时，除了可以对不同的资源加锁，还可以使用不同程度的加锁方式，即锁有多种模式，SQL Server中锁模式包括：\n1）共享锁 SQL Server中，共享锁用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。默认情况下，数据被读取后，SQL Server立即释放共享锁。例如，执行查询“SELECT * FROM my_table”时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。但是，事务 隔离级别连接选项设置和SELECT语句中的锁定设置都可以改变SQL Server的这种默认设置。例如，“ SELECT * FROM my_table HOLDLOCK”就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。\n\n2）修改锁 修 改锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。因为使用共享锁时，修改数据的操作分为两步，首先获得一 个共享锁，读取数据，然后将共享锁升级为独占锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些 事务都要将共享锁升级为独占锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请修改锁，在数据修 改的时候再升级为独占锁，就可以避免死锁。修改锁与共享锁是兼容的，也就是说一个资源用共享锁锁定后，允许再用修改锁锁定。\n\n3）独占锁 独占锁是为修改数据而保留的。它所锁定的资源，其他事务不能读取也不能修改。独占锁不能和其他锁兼容。\n\n4）结构锁 结构锁分为结构修改锁（Sch-M）和结构稳定锁（Sch-S）。执行表定义语言操作时，SQL Server采用Sch-M锁，编译查询时，SQL Server采用Sch-S锁。\n\n5）意向锁 意 向锁说明SQL Server有在资源的低层获得共享锁或独占锁的意向。例如，表级的共享意向锁说明事务意图将独占锁释放到表中的页或者行。意向锁又可以分为共享意向锁、 独占意向锁和共享式独占意向锁。共享意向锁说明事务意图在共享意向锁所锁定的低层资源上放置共享锁来读取数据。独占意向锁说明事务意图在共享意向锁所锁定 的低层资源上放置独占锁来修改数据。共享式独占锁说明事务允许其他事务使用共享锁来读取顶层资源，并意图在该资源低层上放置独占锁。\n\n6）批量修改锁 批量复制数据时使用批量修改锁。可以通过表的TabLock提示或者使用系统存储过程sp_tableoption的“table lock on bulk load”选项设定批量修改锁。",
    "ID" : "55f2e51ee4b0152a611433a8",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "列出数据库中常用的锁及其应用场景"
  },
  {
    "ID" : "55f2e4fee4b0152a6114323e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "const int *a; \/\/ a 是常指针",
    "optionC" : "int const *a; \/\/ a 指向常数的指针",
    "optionAnswer" : "D",
    "answer" : "const只对它左边的东西起作用 ，  唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。 根据这个规则来判断就很容易了",
    "optionB" : "int const a; \/\/ a 是常数",
    "type" : "1",
    "optionA" : "const int a; \/\/ a 是常数",
    "question" : "下面说法哪个错误："
  },
  {
    "ID" : "55f2e46ae4b0152a6114315a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "213",
    "optionC" : "321",
    "optionAnswer" : "D",
    "answer" : "当派生类中不含对象成员时\n· 在创建派生类对象时,构造函数的执行顺序是：基类的构造函数→派生类的构造函数；\n· 在撤消派生类对象时,析构函数的执行顺序是：派生类的构造函数→基类的构造函数。\n当派生类中含有对象成员时\n· 在定义派生类对象时，构造函数的执行顺序：基类的构造函数→对象成员的构造函数→派生类的构造函数；\n· 在撤消派生类对象时，析构函数的执行顺序：派生类的构造函数→对象成员的构造函数→基类的构造函数。",
    "optionB" : "231",
    "type" : "1",
    "optionA" : "123",
    "question" : "对于派生类的构造函数，在定义对象时构造函数的执行顺序为？\n1：成员对象的构造函数\n2：基类的构造函数\n3：派生类本身的构造函数"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c7e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "基类的公有成员一定能被派生类的对象访问",
    "optionC" : "派生类对象除了能访问自己的成员以外，不能访问基类中的所有成员",
    "optionAnswer" : "C",
    "answer" : "构造函数和析构函数不能被派生类继承，A项错误。派生类是基类的扩展，B项错。\n派生类可以访问基类公有和保护类型的成员，不能访问基类私有成员。D项基类是公有的成员\n，若采用私有继承，派生类对象不能直接访问。选择C项。",
    "optionB" : "派生类是基类的组合",
    "type" : "1",
    "optionA" : "构造函数和析构函数都能被继承",
    "question" : "以下有关继承的叙述正确的是 （）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c6f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "\/",
    "optionC" : "：：",
    "optionAnswer" : "C",
    "answer" : "除了类属关系运算符\".\"、成员指针运算符\".*\"、作用域运算符\"::\"、sizeof运算\n符和三目运算符\"?:\"以外，C++中的所有运算符都可以重载。",
    "optionB" : ">=",
    "type" : "1",
    "optionA" : "*",
    "question" : "下列运算符中，在C++语言中不能重载的是（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c71",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "防止不同模块之间数据的非法访问",
    "optionC" : "避免数据丢失",
    "optionAnswer" : "D",
    "answer" : "封装是指把对象属性和操作结合在一起，构成独立的单元，它的内部信息对外界是\n隐蔽的，不允许外界直接存取对象的属性，只能通过有限的接口与对象发生联系。类是数据封装\n的工具，对象是封装的实现。类的访问控制机制体现在类的成员中可以有公有成员、私有成员和\n保护成员。对于外界而言，只需要知道对象所表现的外部行为，而不必了解内部实现细节。封装\n体现了面向对象方法的“信息隐蔽和局部化原则”。",
    "optionB" : "便于数据转换",
    "type" : "1",
    "optionA" : "数据的规范化",
    "question" : "在C++语言中，数据封装要解决的问题是（）"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143255",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "feof( fp ) == 0",
    "optionC" : "feof(fp)",
    "optionAnswer" : "C",
    "answer" : "本题考查文件的定位,feof函数的用法是从输入流读取数据,如果到达文件末尾(遇文件结束符),eof 函数值为非零值,否则为0,while判定条件应是如果没有到达文件末尾,所以选项C不能得到正确的结果。",
    "optionB" : "! feof( fp )",
    "type" : "1",
    "optionA" : "feof( fp )= =NULL",
    "question" : "以下程序用来统计文件中字符的个数(函数fopen用以检查文件是否结束,结束是返回非零)\n#include<stdio.h>\nmain()\n{ \n    FILE *fp; \n    long num=0;\n    fp=fopen(\"fname.dat\", \"r\" );\n    while (________) \n    { \n        fgetc( fp );\n        num++ ;\n    }\n    printf( \" num= % d\\n\",num);\n    fclose( fp );\n}\n下面选项中,填入横线处不能得到正确结果的是?"
  },
  {
    "answer" : "比赛7场就可以。\n\n（1）先进行5场比赛定出每组最快的马。\n（2）每组最快的马进行一场比赛，这样就可以找到第一名。顺便把这5匹马中最后两名淘汰，因为他们永远不可能进入前3。\n（3）分别用第一名所属组的第2,3名马和第2名所属组的第1，2名马和第3名组的第1名马进行1场比赛，定出2,3名马\n至此比赛完毕",
    "ID" : "55f2e51de4b0152a61143378",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "逻辑题：25匹马，5条赛道，一匹马一个赛道，比赛只能得到5匹马之间的快慢程度，而不是速度，求决胜1，2，3名至少多少场。"
  },
  {
    "answer" : "256",
    "ID" : "55f2e51de4b0152a61143358",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "符号-、*、$分别代表减法、乘法和指数运算，且\na)三个运算符优先级顺序为：-最高，*其次，$最低；\nb)运算符运算时为左结合\n则5-3*2$2*4-3$2的结果为 "
  },
  {
    "answer" : "根据题目的条件，每个人握手的数目最大是8次，然后除了smith夫妇外8个人每个人的次数又不一样，所以他们的次数为1到8   \n握手8次的人肯定与除了自己和配偶之外的8个人每人握一次（包括了smith夫妇）\n 握手1次的人只可能是与握手8次的人握 \n 同理握手7次的人是握手8次人的配偶，与其余除了只握手一次的那个人都握一次，其中也包括了smith夫妇 \n握手2次的人除了跟握手7次的人和握手8次的人，其余的人就没再握过手  \n然后握手6次的人也会跟smith夫妇各握一次手，握5次的人也跟smith夫妇各握一次手\n所以史密斯夫妇分别握了4次手",
    "ID" : "55f2e51de4b0152a6114338d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "Smith夫妇召开宴会，并邀请其他4对夫妇参加宴会。在宴会上，他们彼此握手， 并且满足没有一个人同自己握手，没有两个人握手一次以上，并且夫妻之间不握手。 然后Mr. Smith问其它客人握手的次数，每个人的答案是不一样的。 求Mrs Smith握手的次数"
  },
  {
    "answer" : "1、CreateRemoteThread + LoadLibraryA\/W\n2、SetWindowsHook\/SetWindowsHookEx\n3、QueueUserAPC + LoadLibraryA\n",
    "ID" : "55f2e51de4b0152a6114334d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "列举两种应用层中简单的跨进程<span>DLL<\/span>注入的方法。"
  },
  {
    "ID" : "55f2e4fee4b0152a6114324d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1a",
    "optionC" : "19",
    "optionAnswer" : "D",
    "answer" : "<span class=\"pln\" style=\"color: rgb(0,0,0);\">printf<span class=\"pun\" style=\"color: rgb(102,102,0);\">(“%<span class=\"pln\" style=\"color: rgb(0,0,0);\">x\\n<span class=\"pun\" style=\"color: rgb(102,102,0);\">”,++*<span class=\"pln\" style=\"color: rgb(0,0,0);\">x<span class=\"pun\" style=\"color: rgb(102,102,0);\">); 先把x的值加上1再16进制输出。<\/span><\/span><\/span><\/span><\/span><\/span>\n",
    "optionB" : "26",
    "type" : "1",
    "optionA" : "25",
    "question" : "已有变量定义和函数调用语句，\n\nint a=25;\nprint_value(&a);\n则下面函数的正确输出结果是______。\n\nvoid print_value(int* x)\n{\n    printf(“%x\\n”,++*x);\n}\n"
  },
  {
    "answer" : "两两比赛，分成500组剩下一人，类似于归并排序的方式，比出冠军后，让冠军之间再比，主要是要想想多余的那一个选手如何处理，必然要在第一次决出冠军后加入比赛组。",
    "ID" : "55f2e51de4b0152a61143366",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "公司里面有1001个员工，现在要在公司里面找到最好的羽毛球选手，也就是第一名，每个人都必须参赛，问至少要比赛多少次才能够找到最好的羽毛球员工。"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c09",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "保证基类公有成员在子类中可以被访问",
    "optionC" : "保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码",
    "optionAnswer" : "C",
    "answer" : "C++要求函数在被调用之前，应当让编译器知道该函数的原型，以便编译器利用函数\n原型提供的信息去检查调用的合法性，强制参数转换成为适当类型，保证参数的正确传递。对于\n标准库函数，其声明在头文件中，可以用#include宏命令包含这些原型文件；对于用户自定义函\n数，先定义、后调用的函数可以不用声明，但后定义、先调用的函数必须声明。一般为增加程序\n的可理解性，常将主函数放在程序开头，这样需要在主函数前对其所调用的函数一一进行声明\n，以消除函数所在位置的影响。所以选择C项。",
    "optionB" : "保证基类保护成员在子类中可以被访问",
    "type" : "1",
    "optionA" : "保证基类私有成员在子类中可以被访问",
    "question" : "this指针存在的目的是（）"
  },
  {
    "ID" : "55f2e469e4b0152a61143143",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "func_a 和func_b 分配的内存会自动初始化0",
    "optionC" : "func_b 存在内存泄露",
    "optionAnswer" : "B",
    "answer" : "栈上的数据是一个随机值，一般是0xcccccccc,而堆上的内存如果不调用相应的构造函数或者显示初始化它是不会被初始化的",
    "optionB" : "func_b 使用了太多的栈，程序可能会在运行时候崩溃。",
    "type" : "1",
    "optionA" : "func_a 获得临时内存的方式效率通常更高。",
    "question" : "请阅读下面代码片段并且回答问题：\n\n#define SIZE_20M (20*1024*1024)\nvoid func_a()\n{\n    char *tmp = malloc(SIZE_20M)\n    return;\n}\nvoid func_b()\n{\n    char temp[SIZE_20M];\n    \/\/...do something using temp\n    return;\n}\n\n关于这段代码，下列说法正确的是"
  },
  {
    "ID" : "55f2e469e4b0152a6114313e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "a=4,b=8,c=4",
    "optionC" : "a=4,b=7,c=4",
    "optionAnswer" : "",
    "answer" : "首先int肯定是4不用说了，a＝4\n第二个str［］代表char型数据，整个数组存‘Tencent\\0’，所以长度为8，b＝8\n第三个，32位机跟64位机的变量的差别主要在指针大小上，32位机指针长度为4，64位机指针长度为8，c＝4",
    "optionB" : "a=4,b=4,c=4",
    "type" : "1",
    "optionA" : "a=1,b=1,c=1",
    "question" : "win32系统里，下面几个sizeof的运行结果是（）\n\nint intValue=1024;\nchar str[]=\"Tencent\";\nconst char* ch=str;\nsizeof(intValue)=__a___;\nsizeof(str)=__b____;\nsizeof(ch)=____c___;"
  },
  {
    "ID" : "55f2e46ae4b0152a61143163",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "9",
    "optionC" : "4",
    "optionAnswer" : "B",
    "answer" : "答案解析：MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "2",
    "question" : "如果MyClass为一个类，执行”MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是()"
  },
  {
    "answer" : "Ptr=(int?*)&value;",
    "ID" : "55f2e51ee4b0152a611433dc",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请问 c 语言中怎么去除 const 修饰？ 比如：\nconst double value=0.2f； double *ptr；\nptr 怎么样获取 value 的值？"
  },
  {
    "answer" : "具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。  默认时，网站的所有 Cookies 都一起被存储在客户端，并且所有 Cookies 连同网站的任何请求一起被发送到服务器。换句话说，网站中的每个页面都能够为网站获取所有的 Cookies。但是，你能够通过两个方式来设置 Cookies 的作用范围：        把 Cookies 的作用范围限制到服务器的目录，从而允许你把 Cookies 限制到网站的某个应用程序。 设置域的作用范围，能够允许你指定域中的哪些子域能够访问 Cookie。 把 Cookies 限制到目录或应用程序 要把 Cookies 限制到服务器的目录，请设置 Cookie 的 Path 属性\n1.超时问题；\n2.jsessionid问题；\n3.单点退出时有时子系统未能正常退出；\n4.有些请求路径不需要单点登录过滤器拦截；\n5.不同应用服务实现可能要求SSO客户端做适应性改造。",
    "ID" : "55f2e51de4b0152a61143351",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "百度是一个大型网站，内部含有多个产品线，比如广为人知的贴吧、知道、空间等应用。然而设计这些应用的统一登录平台却是一件非常艰巨的挑战。需要考虑到通用性和安全性。\n1)     对于一个Web应用程序，主要的身份验证和凭证保持的方法主要有cookie和session两种。他们又是如何起作用的？各有哪些优缺点？\n2)     影响到cookie值作用范围的因素有哪些？请一一说明。\n3)     从安全角度来考虑，一个大型网站的单点登录可能会引入哪些安全问题？如何设计安全的在线单点登录系统？ "
  },
  {
    "ID" : "55e6d85ae4b0152a610de7ef",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "10",
    "optionC" : "9",
    "optionAnswer" : "B",
    "answer" : "解题思路：输出a的值是在for之后，所以我们要先分析程序跳出for的情况。由代码可知，程序跳出for循环的情况有两种：\nb大于或等于20，执行break语句，跳出for循环；\na大于100，不满足循环条件，跳出循环；\n如果是第二种情况的话，显然a等于101，ABCD都不是，所以程序是第一种情况跳出for。接下来就是分析在第一种情况下跳出for后，a的值。我们知道在第一种情况下，b最后的值肯定是大于20，所以前面所有b的值都应该在20以内，且都是模3余1的被除数，因为b初值为1，模3余1，接下来又每次都加3，所以按顺序应该是1,4,7,10,13,16,19。最后b+=3,b=21，跳出循环，此时a=8。\n执行代码，结果“8”。",
    "optionB" : "8",
    "type" : "1",
    "optionA" : "7",
    "question" : "#include\nint main() {\n    int a, b;\n    for (a = 1, b = 1; a <= 100; a++) { if (b >= 20)\n            break;\n        if (b % 3 == 1) {\n            b += 3;\n            continue;\n        }\n        b -= 5;\n    }\n    printf(\"%d\\n\", a);\n    return 0;\n}\n上面的输出结果为()"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bff",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "4和1",
    "optionC" : "4和0",
    "optionAnswer" : "A",
    "answer" : "带默认的构造函数，对应实参没有值时就采用形参值。调用构造函数时，i=1,不采\n用默认值，而只有一个参数，j采用默认值0即j=0,因此a=1,b=0,选择A项。",
    "optionB" : "1和4",
    "type" : "1",
    "optionA" : "1和0",
    "question" : "假定一个类的构造函数为“A(int i=4, int j=0) {a=i;b=j;}”, 则执行“A x (1);”语\n句后，x.a和x.b的值分别为（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c6e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "20和5",
    "optionC" : "4和24",
    "optionAnswer" : "C",
    "answer" : "执行构造函数将数据成员进行赋值，aa++是后加，先赋值a＝4，++bb,bb变量值先自\n加为6，再与a相乘，所以b＝24。",
    "optionB" : "4和20",
    "type" : "1",
    "optionA" : "4和5",
    "question" : "假定一个类的构造函数为\nA(int aa,int bb){\n    a=aa++;b=a*++bb;\n}\n则执行A x(4,5);语句后，x.a和x.b的值分别为（）"
  },
  {
    "ID" : "55f2e469e4b0152a6114313c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "std::bitset不是一个STL容器",
    "optionC" : "std::sort是稳定排序",
    "optionAnswer" : "C",
    "answer" : "A：“很多程序员希望STL实现是完全线程安全的“。所以不安全。\nB：vector的存在可以使开发者不必关心内存的申请和释放。但是，vector的一个缺点就是它的内存分配是按照2的倍数分配内存的。\nC：错误。要知道 std::sort 不是稳定的排序算法，它不保证“相等”元素的相对位置，使用 std::stable_sort 来保证这一点\nD：STL的容器可以分为以下几个大类: \n一：序列容器，　有vector, list, deque, string.\n二 : 关联容器,     有set, multiset, map, mulmap, hash_set, hash_map, hash_multiset, hash_multimap\n三: 其他的杂项： stack, queue, valarray, bitset",
    "optionB" : "当容量不够时，vector内部内存扩展方式是翻倍",
    "type" : "1",
    "optionA" : "STL容器是线程不安全的",
    "question" : "以下关于STL的描述中，____是错的。"
  },
  {
    "ID" : "55e6d85be4b0152a610de827",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "派生类的对象的地址可以赋给指向基类的指针",
    "optionC" : "派生类的对象可以直接访问基类中的成员",
    "optionAnswer" : "C",
    "answer" : "A，B和D说法是相同的，都是说可以用派生类对象初试化基类对象或者指针，是正确的\nC，派生类对象只有在基类成员未被派生类覆盖的情况下才能访问基类中的成员",
    "optionB" : "派生类的对象可以初始化基类的引用",
    "type" : "1",
    "optionA" : "派生类的对象可以赋给基类的对象",
    "question" : "在公有派生情况下，有关派生类对象和基类对象的关系，下列叙述不正确的是(????)?"
  },
  {
    "ID" : "55f2e4fee4b0152a6114322c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "I、II和III",
    "optionC" : "仅 II 、III",
    "optionAnswer" : "B",
    "answer" : "用户态切换到内核态的  3  种方式\na.  系统调用\nb.  异常\nc.  外围设备的中断 \n\nI. 异常 \nIII. 系统调用 ",
    "optionB" : "仅 I、III",
    "type" : "1",
    "optionA" : "仅 I、II",
    "question" : "下列选项中，会导致用户进程从用户态切换到内核的操作是?\nI. 整数除以零 \nII. sin( )函数调用   \nIII. read系统调用"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f6",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上说法都不正确",
    "optionC" : "不合法",
    "optionAnswer" : "B",
    "answer" : "1、int(*p)[4];------ptr为指向含4个元素的一维整形数组的指针变量（是指针）\n2、int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）\n3、int(*)[4];--------实际上可以看作是一种数据类型。也就是第一个（int(*p)[4];）",
    "optionB" : "一个指向元素个数为3的int数组的指针",
    "type" : "1",
    "optionA" : "一个指向int元素大小为3的指针数组",
    "question" : "int (*p)[3] p的含义是什么?"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c60",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "都不是虚函数",
    "optionC" : "只有被重新说明为virtual时才是虚函数",
    "optionAnswer" : "A",
    "answer" : "在基类声明为virtual的函数为虚函数，在派生类中只要有相同的函数（函数名相\n同、返回值相同、形参类型和个数相同）即使不用virtual说明，也都是虚函数。",
    "optionB" : "只有被重新说明时才是虚函数",
    "type" : "1",
    "optionA" : "都是虚函数",
    "question" : "当一个类的某个函数被说明为virtual时，该函数在该类的所有派生类中（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114323f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数重载返回值类型必须相同",
    "optionC" : "构造函数和析构函数都可以是虚函数",
    "optionAnswer" : "B",
    "answer" : "A 不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。  \n不能重载 ?: ，因为这个运算符对于类对象来说没有实际意义，相反还会引起歧义 \n还有：：\nC 构造函数 不能是虚函数。 \nD 函数重载只跟 参数类型 和参数个数 有关。",
    "optionB" : "const对象只能调用const类型成员函数",
    "type" : "1",
    "optionA" : "C++已有的任何运算符都可以重载",
    "question" : "下面说法正确的是（）"
  },
  {
    "ID" : "55f2e46ae4b0152a61143152",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上答案都不正确",
    "optionC" : "程序不正确",
    "optionAnswer" : "B",
    "answer" : "基类A 的f()没有声明为虚函数，所以没有B覆盖。",
    "optionB" : "不符合预期的输出A",
    "type" : "1",
    "optionA" : "没有问题，输出B",
    "question" : "下面这段代码运行时会出现什么问题？\n\nclass A\n{\npublic:\n    void f()\n    {\n        printf(\"A\\n\");\n    }\n};\n \nclass B: public A\n{\npublic:\n    virtual void f()\n    {\n        printf(\"B\\n\");\n    }\n};\n \nint main()\n{\n    A *a = new B;\n    a->f();\n    delete a;\n    return 0;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a61143227",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "a[i] a[i] a[i]",
    "optionC" : "0 a[j] a[j]",
    "optionAnswer" : "B",
    "answer" : "第一步：找出最小值和最大值，将他们保存在a[0]和a[1]中\n第二步：在剩余的数中找出最小值和最大值，保存在a[2]和a[3]中",
    "optionB" : "a[i] a[j] a[j]",
    "type" : "1",
    "optionA" : "0 a[i] a[i]",
    "question" : "下列给定程序中，函数fun的功能是：把形参a所指数组中的最小值放在元素a[0]中，接着把a所指数组中的最大值放在a[1]元素中;再把a所指数组元素中的次小值放在a[2]中，把a索取数组元素中的次大值放在a[3]，以此类推。 \n例如:若a所指数组中的数据最初排列为：9,1,4,2,3,6,5,8,7;按规则移动后，数据排列为:1,9,2,8,3,7,4,6,5。形参n中存放a所指数组中数据的个数。\n规定fun函数中的max存放的当前所找的最大值,px存放当前所找最大值得下标。 请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。 \n试题程序。\n\n#include<stdio.h>\n#define N 9\nvoid fun(int a[ ], int n)\n{\n    int i, j, max, min, px, pn, t;\n    for (i = 0; i < n - 1; i += 2)\n    {\n \n        max = min = __;\n        px = pn = i;\n        for (j = i + 1; j < n; j++)\n        {\n \n            if (max <  __)\n            {\n                max = a[j];\n                px = j;\n            }\n \n            if (min > __ )\n            {\n                min = a[j];\n                pn = j;\n            }\n        }\n        if (pn != i)\n        {\n            t = a[i];\n            a[i] = min;\n            a[pn] = t;\n            if (px == i)\n                px = pn;\n        }\n        if (px != i + 1)\n        {\n            t = a[i + 1];\n            a[i + 1] = max;\n            a[px] = t;\n        }\n    }\n}\nint main( )\n{\n    int b[N] = {9, 1, 4, 2, 3, 6, 5, 8, 7};\n    printf(\"\\nThe original data:\\n\");\n    for (int i = 0; i < N; i++)\n        printf(\"% 4d\", b[i]);\n    printf(\"\\n\");\n    fun(b, N);\n    printf(\"\\nThe data after mocinng \\n\");\n    for (int i = 0; i < N; i++)\n        printf(\"% 4d\", b[i]);\n    printf(\"\\n\");\n}"
  },
  {
    "answer" : "N = 4\nM = 5\nl = []\nfor i in xrange(1, 1 + N*M):\n l.append(i)\n \nm = [[None]*M for i in xrange(N)]\nstep = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nd = 0\ns = (0, 0)\n \nfor num in l:\n m[s[0]][s[1]] = num\n ns = (step[d][0] + s[0], step[d][1] + s[1])\n if ns[0] >= N or ns[1] >= M or m[ns[0]][ns[1]] is not None:\n d = (d + 1) % 4\n ns = (step[d][0] + s[0], step[d][1] + s[1])\n s = ns\n \nfor i in m:\n print i",
    "ID" : "55f2e51de4b0152a6114335e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "反螺旋矩阵：随机给定N*M个数（无重复），先将这N*M个数排序，然后升序放置到螺旋矩阵当中：\n如，给定3*5共15个数1-15，则螺旋矩阵输出如下：\n1   2  3  4  5\n14 15 16 17 6\n13 20 19 18 7\n12 11 10 9 8"
  },
  {
    "answer" : "这个问题可以转换成一个动态规划问题：\n比如我们想求Sn(Sn表示从求从第一个segment开始，总共有n个元素的子问题，求这个子问题的最大重合线段。)，首先我们要证明这是一个动态规划问题：\n我们要求Sn问题的最大重合线段，那么它只有可能有两种来源：\n（1）Sn-1问题的最大重合线段，即Sn的最大重合线段出自前n-1个线段；\n（2）第n个线段Segment[n-1](注意：我是从0开始计数的，所以下标为n-1的就是第n个线段)和前n-1个线段的重合线段中最长的那一个。\n所以，问题的解法如下：\n（1）首先按照所有线段的end值对所有线段进行排序；\n（2）递归的从后往前求解，比如求Sn的最大重合线段，先通过递归求出Sn-1的最大重合线段(tmpMaxSeg)，再求出Segment[n-1]和前n-1个线段的重合线段中最长的那一个(currMaxSeg)，比较tmpMaxSeg和currMaxSeg的长度，选出最长的作为Sn的返回值。\n（3）注意：递归出口：size==2时，只有两个线段，通过简单比较就可以得出最大覆盖线段；\n至于这块儿：是为了应对原本传入的线段数组的大小小于等于1的情况，算是边界条件处理了，不是递归的出口。\n假如传入数组大小为3，递归执行到数组大小为2时就可以返回了。\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\nconst int LEN = 3;\nusing namespace std;\nstruct segment\n{\n    int start;\n    int end;\n};\n\/\/ assume a.end < b.end\nsegment commonSeg(const segment & a, const segment & b)\n{\n    segment CommonSeg;\n    if(a.end < b.start)\n    {\n        CommonSeg.end = 0;\n        CommonSeg.start = 0;\n    }\n    else\n    {\n        CommonSeg.end = a.end;\n        CommonSeg.start = b.start;\n    }\n    return CommonSeg;\n}\nint findMaxSegment(int size, segment * Segment, segment & maxSeg)\n{\n    if(NULL == Segment)\n    {\n        cerr << \"the segment array is NULL\" << endl;\n        return -1;\n    }\n    else if(1 == size)\n    {\n        maxSeg = Segment[0];\n        return maxSeg.end-maxSeg.start;\n    }\n    else if(2 == size)\n    {\n        if(Segment[0].end <= Segment[1].start)\n        {\n            maxSeg.start = 0;\n            maxSeg.end = 0;\n            return maxSeg.end-maxSeg.start;\n        }\n        else\n        {\n            maxSeg.end = Segment[0].end;\n            maxSeg.start = Segment[1].start;\n            return maxSeg.end-maxSeg.start;\n        }\n    }\n    else\n    {\n        segment tmpMaxSeg, tmpSeg,currMaxSeg;\n        int currMaxLen = 0;\n        findMaxSegment(size-1, Segment, tmpMaxSeg);\n        for(int i=0; i<size-1; i++)\n        {\n            tmpSeg=commonSeg(Segment[i], Segment[size-1]);\n            if(tmpSeg.end - tmpSeg.start > currMaxLen)\n            {\n                currMaxLen = tmpSe",
    "ID" : "55f2e51ee4b0152a611433dd",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "在一维坐标轴上存在许多条线段， 用最简单的算法找出重合长度最长得两条线段。 比如线段 A（1,5）、B（2,8）、C（3,9），则 B 和 C 的重合长度最长，为 5。"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7fe",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "char b[10]=\"HELLO!\";",
    "optionC" : "char b[10];strcpy(b，\"HELLO!\");",
    "optionAnswer" : "B",
    "answer" : "B 选项是错误的，连编译都不会通过，因为数组名属于常性指针，现在要改变这个常性指针的指向，这是不会编译通过的，再说B 选项的本意是将Hello 拷贝到b指向的空间中，但实际却是将b指向了在常量区的Hellow 字符串（虽然编译不会通过）。",
    "optionB" : "char b[10];b=\"HELLO!\";",
    "type" : "1",
    "optionA" : "char b[10]={'H'，'E'，'L'，'L'，'O'，'!'，'\\0'};",
    "question" : "不能把字符串\"HELLO!\"赋给数组b的语句是（）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c05",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "T add(T x,T y)",
    "optionC" : "T add(T x,y)",
    "optionAnswer" : "D",
    "answer" : "实现两个相同类型数加法结果应该和操作数具有相同类型。进行加法运算后结果也\n是和参数具有相同类型，需要返回值。A无返回值时要用void,B形参无类型，C形参y没有类型\n，所以选择D项。",
    "optionB" : "T add(x,y)",
    "type" : "1",
    "optionA" : "add(T x,T y)",
    "question" : "实现两个相同类型数加法的函数模板的声明是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114321c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "包含3个字符",
    "optionC" : "包含2个字符",
    "optionAnswer" : "B",
    "answer" : "char a ='\\82',定义字符量a,char型变量值为1个字节长度,并从右侧开始运算,所以a的值应为'2',因此B选项正确。",
    "optionB" : "包含1个字符",
    "type" : "1",
    "optionA" : "说明不合法",
    "question" : "若有定义语句： char a ='\\82'; 则变量a"
  },
  {
    "answer" : "下拉时触发：onPause（），onStop（）\n弹出dialog：onPause（）",
    "ID" : "55f2e51de4b0152a61143398",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "（Android开发选做）关于Activity的生命周期，下拉statusbar时，桌面Activity会触发哪几个生命周期？系统关机时，弹出关机Dialog之后，此时，桌面Activity会触发哪几个生命周期？"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143262",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "1",
    "optionAnswer" : "B",
    "answer" : "A a1; \/\/调用A默认构造函数\na1=10; \/\/类型不匹配，调用构造函数A(int)进行隐式转化，之后将引用传给operator=（）",
    "optionB" : "12",
    "type" : "1",
    "optionA" : "2",
    "question" : "有如下程序段：\n\nclass A\n{\n    public:\n        A()\n        {\n            printf(“0”);\n        }\n        A(int a)\n        {\n            printf(“1”);\n        }\n        A& operator=(const A& a)\n        {\n            printf(“2”);\n            return*this;\n        }\n}\nint main()\n{\n    A al;\n    al=10;\n}\n则程序输出是："
  },
  {
    "ID" : "55e6d85ae4b0152a610de812",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "suieneG",
    "optionC" : "run-time error",
    "optionAnswer" : "A",
    "answer" : "A.主要有两个知识点，一个是递归，相当于栈是FILO，另一个考察点是print(++s)，指针先移动然后调用函数。",
    "optionB" : "neius",
    "type" : "1",
    "optionA" : "suiene",
    "question" : "下列代码的输出是？（注：print已经声明过）main(){     \n    char str[]=\"Geneius\";\n    print (str);\n} \nprint(char *s){\n  if(*s){\n       print(++s);\n       printf(\"%c\",*s); \n}\n}"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c66",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "相同类模板的不同实例一般没有联系，而派生类各种类之间有兄弟父子等关系",
    "optionC" : "从动态性能看， 继承类系比模板类系具有更多的动态特性",
    "optionAnswer" : "D",
    "answer" : "类是相同类型事物的抽象，具有不同的操作。而模板是不同类型的事物，具体相同\n的操作的抽象。类模板的实例化后，各个对象没有任何关系。而类对象是通过派生、继承等关系\n的关系。",
    "optionB" : "从类系的成员看，模板类系的成员比继承类系的成员较为稳定",
    "type" : "1",
    "optionA" : "模板和继承都可以派生出一个类系",
    "question" : "下列有关模板和继承的叙述正确的是 （）"
  },
  {
    "answer" : "TCP\/IP协议\n从上往下依次为：应用层，传输层，网络层，网络接口层",
    "ID" : "55f2e51ee4b0152a611433d5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "Internet采用哪种网络协议？该协议的主要层次结构？"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c6d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类A的成员函数不得访问类B的成员",
    "optionC" : "类A的成员即类B的成员",
    "optionAnswer" : "A",
    "answer" : "友元关系不能被继承，友元关系是单向的，友元关系不具有传递性。但是友元函数\n不是类的成员，所以选择A项。",
    "optionB" : "类B的成员即类A的成员",
    "type" : "1",
    "optionA" : "类B不一定是类A的友元",
    "question" : "如果类A被说明成类B的友元，则（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114320b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "while循环的条件必须是一个布尔类型的表达式，表达式应该为n!=0.",
    "optionC" : "*p++使得p在解引用之前增大，因为自增运算符的优先级比取址运算符优先级高。",
    "optionAnswer" : "C",
    "answer" : "A同级运算符，自右向左，*p++相当于*(p++),正确的应该是(*p)++",
    "optionB" : "数组的值是一个不能改变的值，所以p不能直接被修改。应该使用一个和p相关联的指针来完成这个操作。",
    "type" : "1",
    "optionA" : "*p++使得p在解引用之前增大，因为*和++两个运算符有相同的优先级并按自右向左的方式结合。",
    "question" : "函数作用：将整型数组p中n个数据增大\n\nvoid increment_ints (int p [ ], int n)\n{\n  assert(p != NULL);  \/* 确保p不为空指针 *\/\n  assert(n >= 0);  \/* 确保n不为负数 *\/\n  while (n)  \/* 循环n次. *\/\n  {\n    *p++;          \/* 增大p*\/\n    p++, n--;      \/* p指向下一位，n减1 *\/\n  }\n}\n以上代码的实现有错误，下面哪句话的表述是正确的？"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c03",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "MyA(MyA)",
    "optionC" : "MyA(MyA&)",
    "optionAnswer" : "C",
    "answer" : "复制即拷贝构造函数使用对象的引用作形参，防止临时产生一个对象，A无参构造函\n数，B是指针作为形参，D项是对象，所以选择C项。",
    "optionB" : "MyA(MyA*)",
    "type" : "1",
    "optionA" : "MyA()",
    "question" : "类MyA的拷贝初始化构造函数是 （）"
  },
  {
    "answer" : "二叉树t中具有非空的左、右两个儿子的结点个数N2；只有非空左儿子的个数NL；只有非空右儿子的结点个数NR和叶子结点个数N0。N2，NL,NR、N0都是全局量，且在调用count(t)之前都置为0。",
    "ID" : "55f2e51de4b0152a61143370",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "设t是给定的一棵二叉树，下面的递归程序count(t)用于求得：\ntypedef struct node\n{\n    int data;\n    struct node *lchild,*rchild;\n}node;\n \nint N2,NL,NR,N0;\nvoid count(node *t)\n {\n     if (t->lchild!=NULL)\n         if (t->rchild!=NULL) N2++;\n         else NL++;\n     else if (t->rchild!=NULL) NR++;\n     else N0++;\n     if(t->lchild!=NULL) count(t->lchild);\n     if(t->rchild!=NULL) count(t->rchild);\n }\/* call form :if(t!=NULL) count(t);*\/"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7ee",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "-1",
    "optionC" : "1",
    "optionAnswer" : "D",
    "answer" : "本题考查位运算中按位取反,0按位取反就是－1,所以选项D正确。",
    "optionB" : "0",
    "type" : "1",
    "optionA" : "8",
    "question" : "#include <stdio.h>\nmain(){\n    int i=0;\n    i=～i;\n    printf(\"%d\\n\",i);\n｝\n程序运行后的输出结果是?"
  },
  {
    "answer" : "三个基本元素：\n封装\n继承\n多态\n五个基本原则：\n单一职责原则（Single-Resposibility Principle）:一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。\n开放封闭原则（Open-Closed principle）:软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。\nLiskov替换原则（Liskov-Substituion Principle）:子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。\n依赖倒置原则（Dependecy-Inversion Principle）:依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n接口隔离原则（Interface-Segregation Principle）:使用多个小的专门的接口，而不要使用一个大的总接口。",
    "ID" : "55f2e51de4b0152a61143365",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "面向对象的三个基本元素，五个基本原则"
  },
  {
    "ID" : "55f2e4fee4b0152a6114321f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "t=2 y=3",
    "optionC" : "t=2 y=2",
    "optionAnswer" : "A",
    "answer" : "||前面的为真时其后的就不会再执行了，直接返回1.",
    "optionB" : "t=1 y=3",
    "type" : "1",
    "optionA" : "t=1 y=2",
    "question" : "设x、y、t均为int型变量，则执行语句：t=3; x=y=2; t=x++||++y;?后，变量t和y的值分别为____"
  },
  {
    "ID" : "55f2e4fee4b0152a61143218",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上全都不正确",
    "optionC" : "Hell",
    "optionAnswer" : "A",
    "answer" : "buffer是数组，sizeof（buffer）=6，所以循环执行5次。s是指向char类型的指针，s+i表示将s指向首元素后第i个位置，*（s+i）就是s[i]。所以buffer为hello。",
    "optionB" : "Hello World!",
    "type" : "1",
    "optionA" : "Hello",
    "question" : "如下代码输出结果是什么？#include<stdio.h>\nchar buffer[6] = {0};\nchar *mystring(){  \n    char *s = \"Hello world\";\n    for(int i = 0;i<(sizeof(buffer) - 1);i++){\n    buffer[i] = *(s+i);\n    }\n    return buffer;\n}\nint main(int args,char**argv){\n    printf(\"%s\\n\",mystring());\n    return 0;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a611431fb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "多继承类",
    "optionC" : "含有纯虚函数",
    "optionAnswer" : "C",
    "answer" : "【解析】抽象基类是指含有纯虚函数，不能够实例化的基类。",
    "optionB" : "派生类",
    "type" : "1",
    "optionA" : "嵌套类",
    "question" : "抽象基类是指（ ）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c11",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数代码多、不常调用",
    "optionC" : "函数代码少、频繁调用",
    "optionAnswer" : "C",
    "answer" : "内联函数具有程序代码少、频繁调用和执行效率高的特征，所以选择C项。",
    "optionB" : "函数体含有递归语句",
    "type" : "1",
    "optionA" : "函数体含有循环语句",
    "question" : "适宜采用inline定义函数情况是（）"
  },
  {
    "answer" : "使用递归方法，可以使用前序遍历，首先分别计算左右子树各自的子树和，然后记录目前最大的；\n再加入当前的父节点，再计算父节点开头的子树是否最大；该层递归上去即可。\npublic class MaxSumSubTree {\n    class TreeNode{\n        TreeNode left,right;\n        int tag;\n        TreeNode(int tag){\n            this.tag = tag;\n        }\n    }\n\n    private TreeNode maxRoot = new TreeNode(0);\n    public int find(TreeNode root){\n        if(root==null){\n            return 0;\n        } else{\n            int lSum = find(root.left);\n            int rSum = find(root.right);\n            if(maxRoot.tag<lSum)\n                maxRoot = root.left;\n            if(maxRoot.tag<rSum)\n                maxRoot = root.right;\n            return root.tag+lSum+rSum;\n        }\n    }\n}\n",
    "ID" : "55f2e51de4b0152a61143355",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一个二叉树， 节点全部为整数，如何找到一个子树，它所有节点的和最大？要求编程序实现。"
  },
  {
    "answer" : "#include<sdio.h>\n#include<string.h>\nchar *FindNuber(char* out,char*in)\n{\nchar *max=NULL,*p=NULL,*q=NULL;\nint i=0,j=0;\np=in;\nwhile(*p){\np++;\nif((*p)>=0&&(*p)<=9)\n{\nq=p;\nwhile((*p)>=0&&(*p)<=9)\n{\ni++;\np++;\n}\n}\nif(i>j){\nstrncpy(max,q,i);\nj=i;\ni=0;\n}\n}\nout=max;\nreturn out;\n}",
    "ID" : "55f2e51ee4b0152a611433ca",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "求出一字符串中最长的数字串。比如as123cdf1234f，返回1234，char* FindNumber(char * out,char *in)。"
  },
  {
    "answer" : "满足a[j]-a[i] <= L && a[j+1]-a[i] > L这两个条件的j与i中间的所有点个数中的最大值，即j-i+1最大，方法很简单：直接从左到右扫描，两个指针i和j，i从位置0开始，j从位置1开始，如果a[j] - a[i] <= L则j++并记录中间经过的点个数，如果a[j] - a[i] > L则j--回退，覆盖点个数-1回到刚好满足条件的时候，将满足条件的最大值与所求最大值比较，然后i++,j++直到求出最大的点个数。\n有两点需要注意：\n（1）这里可能没有i和j使得a[j] - a[i]刚好等于L的，所以判断条件不能为a[j] - a[i] = L。\n（2）可能存在不同的覆盖点但覆盖的长度相同，此时只选第一次覆盖的点。\n\/\/ 求最大覆盖点  \n#include <stdio.h>\nint maxCover(int a[], int n, int L){\n    int count = 2, maxCount = 1, start;\n    int i = 0, j = 1;\n    while(i < n && j < n){\n        while((j < n) && (a[j] - a[i] <= L))\n        {\n            j++;\n            count++;\n        }\n        \/\/ 退回到满足条件的j\n        j--;\n        count--;\n        if(maxCount < count)\n        {\n            start = i;\n            maxCount = count;\n        }\n        i++;\n        j++;    \n    }\n    printf(\"covered point: \");\n    for(i = start; i < start + maxCount; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\"); return maxCount;\n}\nint main()\n{\n    \/\/ test  \n    int a[] = {1, 3, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18, 21};\n    printf(\"max count: %d\\n\\n\", maxCover(a, 13, 8)); int b[] = {1,2,3,4,5,100,1000};\n    printf(\"max count: %d\\n\", maxCover(b, 7, 8)); return 0;\n}",
    "ID" : "55f2e51ee4b0152a611433ab",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "数轴上从左到右有 n 个点 a[0],a[1],??,a[n-1],给定一根长度为 L 的绳子,求绳子最多能 覆盖其中的几个点。"
  },
  {
    "ID" : "55f2e469e4b0152a61143129",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "exponential",
    "optionC" : "quadratic",
    "optionAnswer" : "A",
    "answer" : "因为e是不断地除以2，所以调用次数应该是以2为底的对数！",
    "optionB" : "linear",
    "type" : "1",
    "optionA" : "logarithmic",
    "question" : "Consider the following definition of a recursive function, power, that will perform exponentiation.\n\nint power(int b, int e) {\n    if (e == 0)\n        return 1;\n    if (e %2 == 0)\n        return power (b * b, e \/ 2);\n    return b * power(b * b, e \/ 2);\n}\nAsymptotically (渐进地) in terms of the exponent e, the number of calls to power that occur as a result of the call power(b, e) is"
  },
  {
    "ID" : "55f2e4fee4b0152a6114322b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "指向字符串的常量指针；",
    "optionC" : "指向字符串常量的指针；",
    "optionAnswer" : "C",
    "answer" : "这里主要是考察const的知识。\nconst修饰紧跟在它之后的内容，\n在这里，就是修饰的char，所以这里const char作为一个整体，ptr是指向字符串常量的指针",
    "optionB" : "指向字符的常量指针；",
    "type" : "1",
    "optionA" : "指向字符常量的指针；",
    "question" : "下列说明中 const char *ptr；ptr应该是（）"
  },
  {
    "answer" : "int maxArea(vector<int>& height) {\n    int water = 0;\n    int i = 0, j = height.size() - 1;\n    while (i < j) {\n        int h = min(height[i], height[j]);\n        water = max(water, (j - i) * h);\n        while (height[i] <= h && i < j) i++;\n        while (height[j] <= h && i < j) j--;\n    }\n    return water;\n}",
    "ID" : "55f2e51ce4b0152a6114332e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "对于非负序列a1、a2、……、an，在数轴上做垂线连接点（i，0）和（i，ai）。选择这样的两条线和x轴可以形成一个容器，我们以面积代表所装的水，求以这种方式构成的容器能装的最大面积。比如选择a2=3、a5=6，则所装的面积为9."
  },
  {
    "answer" : "关键是数据结构：尾结点的next指针指向头结点的单链表——循环链表，然后是定义在这个链表上的删除操作。查找输出按用户输入进行就OK了",
    "ID" : "55f2e51ee4b0152a611433d8",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "用户输入 M,N 值,从 1 至 N 开始顺序循环数数,每数到 M 输出该数值,直至全部输出。写出 C 程序。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143238",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "数组只能通过值参数和地址参数两种方式传递给函数",
    "optionC" : "数组的大小必须在编译时确定",
    "optionAnswer" : "C",
    "answer" : "? 数组可以也动态实现，int n; cin>>n,int *p=new int[n]; 指针传递也是传地址",
    "optionB" : "长度为n的数组，下标的范围是0-n-1",
    "type" : "1",
    "optionA" : "在C++语言中数组的名字就是指向该数组第一个元素的指针",
    "question" : "下面关于数组的描述错误的是（）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c07",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Y,X；Y,X",
    "optionC" : "Y,X；X,Y",
    "optionAnswer" : "A",
    "answer" : "派生类构造函数必须对这三类成员进行初始化，其执行顺序：调用基类构造函数\n；调用子对象的构造函数；派生类的构造函数体。析构函数在执行过程中也要对基类和成员对象\n进行操作，但它的执行过程与构造函数正好相反，即对派生类新增普通成员进行清理；调用成员\n对象析构函数，对派生类新增的成员对象进行清理；调用基类析构函数，对基类进行清理，所以\n选择A项。",
    "optionB" : "X,Y；X,Y",
    "type" : "1",
    "optionA" : "X,Y；Y,X",
    "question" : "假设ClassY:publicX，即类Y是类X的派生类，则说明一个Y类的对象时和删除Y类对象时\n，调用构造函数和析构函数的次序分别为（）"
  },
  {
    "answer" : "很明显的卡特兰数 \nh(n)=C(2n,n)\/(n+1)\np = h(n) \/ c(2n,n) = 1\/（n+1）",
    "ID" : "55f2e51ee4b0152a611433ba",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "一景区需要门票5元，售票员没有零钱，假设这一天会来2N个人，其中N个人会给5元钱，N个人给10元，问所有人都不需要等待的概率是多少？"
  },
  {
    "answer" : "3:01",
    "ID" : "55f2e51ee4b0152a611433b7",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "一堆硬币，一个机器人，如果是反的就翻正，如果是正的就抛掷一次，无穷多次后，求正反的比例。"
  },
  {
    "answer" : "程序中的主线程向各个子线程发送一个退出消息信号，各个线程收到这个消息信号后退出线程函数，则可以安全有效的推出所有的线程。",
    "ID" : "55f2e51ee4b0152a611433bc",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "假设你在编写一个使用多线程技术的程序,当程序中止运行时,需要怎样一 个机制来安全有效的中止所有的线程?请描述其具体流程."
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c72",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "析构函数",
    "optionC" : "构造函数",
    "optionAnswer" : "C",
    "answer" : "定义构造函数作用就是初始化对象，而析构函数释放对象空间。虚函数用于完成多\n态性，友元增加访问方便性。",
    "optionB" : "虚函数",
    "type" : "1",
    "optionA" : "友元函数",
    "question" : "在类的定义中，用于为对象分配内存空间，对类的数据成员进行初始化并执行其他内部管理操作的函数是（）"
  },
  {
    "answer" : "内存断点通过将目标地址所在页属性改为PAGE_NOACCESS，当你尝试执行到目标地址时就会产生异常，调试器就会中断下来或者将目标地址内存改为0xCC (INT 3)指令，当执行到该地址时候会产生一个中断，调试器就会暂停下来。",
    "ID" : "55f2e51de4b0152a6114334a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请解释下常见利用内存断点调试的原理?"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "1",
    "optionAnswer" : "B",
    "answer" : "A a1; \/\/调用A默认构造函数\na1=10; \/\/类型不匹配，调用构造函数A(int)进行隐式转化，之后将引用传给operator=（）",
    "optionB" : "12",
    "type" : "1",
    "optionA" : "2",
    "question" : "class A\n{\n    public:\n        A()\n        {\n            printf(“0”);\n        }\n        A(int a)\n        {\n            printf(“1”);\n        }\n        A& operator=(const A& a)\n        {\n            printf(“2”);\n            return*this;\n        }\n}\nint main()\n{\n    A al;\n    al=10;\n}\n则程序输出是："
  },
  {
    "ID" : "55f2e469e4b0152a6114312e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "m%n m\/=n",
    "optionC" : "m%n m%=n",
    "optionAnswer" : "D",
    "answer" : "分解质因数是将一个数差分成为几个质数相乘，首先找到一个n可以被m整除，整除就是余数为零才能跳出循环，而如果只是做除法 只有当m<n的时候才会出现等于0.这与if的条件判断相互冲突。",
    "optionB" : "m\/n   m%=n",
    "type" : "1",
    "optionA" : "m\/n   m\/=n",
    "question" : "以下prim函数的功能是分解质因数。括号内的内容应该为？\n\nvoid prim(int m, int n)\n {\n     if (m >= n)\n     {\n         while (        ) n++;\n         (     );\n         prim(m, n);\n         cout << n << endl;\n     }\n }"
  },
  {
    "answer" : "除了整型，枚举类型，字符型，其他的都不行。譬如：字符串，浮点型这些都不可以作为switch的参数类型。",
    "ID" : "55f2e51ee4b0152a611433d7",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "不能做switch()的参数类型是："
  },
  {
    "ID" : "55e429cfe4b0152a610c833b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "BSS segment",
    "optionC" : "global variable",
    "optionAnswer" : "A",
    "answer" : "选A",
    "optionB" : "static variable",
    "type" : "1",
    "optionA" : "code segment",
    "question" : "When a dll is loaded into memory, which part(s) can be shared between processes"
  },
  {
    "ID" : "55e429cfe4b0152a610c833f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "385",
    "optionC" : "390",
    "optionAnswer" : "D",
    "answer" : "度为2的节点 = 度为0的节点 - 1\n度为0的节点就是叶子节点\n总结点数 = 度为0节点 + 度为1节点 + 度为2节点\n完全二叉树度为1的节点有1个\n所以：总结点数 = 度为0节点 + 1 + 度为0节点 - 1\n所以：总结点数 = 叶子 * 2\n叶子 = 770\/2 = 385",
    "optionB" : "375",
    "type" : "1",
    "optionA" : "380",
    "question" : "一个完全二叉树有770个节点，那么其叶子的个数为?"
  },
  {
    "ID" : "55f2e46ae4b0152a61143157",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "test(0.5)",
    "optionC" : "test(2+’d’)",
    "optionAnswer" : "D",
    "answer" : "0.5类型模糊，既匹配int类型也匹配float类型",
    "optionB" : "test(‘c’);",
    "type" : "1",
    "optionA" : "test(1);",
    "question" : "有函数定义： \nvoid test(int a){} \nvoid test(float a){} \n则以下调用错误的是："
  },
  {
    "ID" : "55f2e4fee4b0152a611431f3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上说法都不正确",
    "optionC" : "不合法",
    "optionAnswer" : "B",
    "answer" : "1、int(*p)[4];------ptr为指向含4个元素的一维整形数组的指针变量（是指针）\n2、int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）\n3、int(*)[4];--------实际上可以看作是一种数据类型。也就是第一个（int(*p)[4];）",
    "optionB" : "一个指向元素个数为3的int数组的指针",
    "type" : "1",
    "optionA" : "一个指向int元素大小为3的指针数组",
    "question" : "int (*p)[3] p的含义是什么?"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c0d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "不受保护",
    "optionC" : "受保护",
    "optionAnswer" : "B",
    "answer" : "继承方式的不同派生类成员的权限也不同，采用公有继承，除了私有无法访问外\n，公有、保护在派生类中保持不变，所以选择B项。",
    "optionB" : "保持不变",
    "type" : "1",
    "optionA" : "受限制",
    "question" : "在公有继承的情况下，基类的公有或保护成员在派生类中的访问权限（）"
  },
  {
    "answer" : "对这个问题，我提供三种解题思路：首先不妨设第i个加油站与之后加油站距离为g[i]\/w，这样相当于每公里消耗1升油，这里的假设和量纲缩放并不影响实际结果，只是简化计算。\n\n方法一：从左往右遍历，记住油量和最少的位置，从其下一个位置出发。\n\nint selectGasStation_1(const vector<int> &a, const vector<int> &g, const int n) {\n    int res = 0, min = N[0] - g[0], sum = min;\n    for (int i = 1; i < n; ++i)\n    {\n        sum += N[i] - g[i];\n        if (sum < min) {\n            min = sum;\n            res = i;\n        }\n    }\n    return sum >= 0 ? (res + 1) % n : -1;\n}\n\n方法二：开辟一个长度为N的数组v，记录N[i]-g[i]。从后往前遍历数组v。如果v[i]小于零，将其与v[i-1]合并，因为此时i不可能作为起点。如果v[i]不小于零，记入sum，并记录该位置pos（有可能作为起点）。最后，如果v[0]大于等于零，说明整个路段已经没有负的v[i]。返回0即可。如果v[0]+sum>=0，有满足条件的加油站，返回pos。否则，返回-1。\n\nint selectGasStation_2(const vector<int> &a, const vector<int> &g, const int n) {\n    int v[n];\n    for (int i = 0; i < n; ++i)\n        v[i] = N[i] - g[i];\n    int sum = 0, pos = -1;\n    for (int i = n-1; i > 0; --i)\n    {\n        if (v[i] >= 0) {\n            sum += v[i];\n            pos = i;\n        } else {\n            v[i-1] += v[i];\n        }\n    }\n    if (v[0] >= 0) return 0;\n    else if (v[0] + sum >= 0) return pos;\n    else return -1;\n}\n\n方法三：开辟一个长度为2*n-1的数组v，记录N[i]-g[i]（环转化为线性）。使用两个指针start和end。如果[start, end]区间和小于0，令start = end + 1并继续。直至找到长度为N的区间[start, end]，并且区间和大于等于0。找到返回start。\n\nint selectGasStation_3(const vector<int> &a, const vector<int> &g, const int n) {\n    int v[2 * n];\n    for (int i = 0; i < n; ++i)\n    {\n        v[i] = N[i] - g[i];\n        v[i+n] = N[i] - g[i];\n    }\n    int sum = 0;\n    for (int start = 0, end = 0; start <= n && end < 2 * n; end++)\n    {\n        if (sum + v[end] < 0) {\n            start = end + 1;\n            sum = 0;\n        } else {\n            if (end - start == n - 1) \n                return start;\n            sum += v[end];\n        }\n    }\n    return -1;\n}\n\n以上三种解法的时间复杂度均为O(n)，应该满足最苛刻的效率要求了。",
    "ID" : "55f2e51de4b0152a61143381",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "现有一圆环形路，路上有n个加油站，第i个加油站储存有Ni升容量的油，每两个加油站之间有一定的距离（km），一汽车初始无油，该车每公里消耗w升油，请问该车从哪个加油站出发可以绕该环形路行驶一圈。给出所有的算法及时间的复杂度。"
  },
  {
    "answer" : "可以有两个方法：如果可以破坏链表m_pNext,那可以一个循环将所有m_pNext指向上一个接点，然后一个循环输出，然后再还原接点。\n个人觉得这个太复杂。\n方法二：使用递归或借助栈来做。（所有递归都可以通过栈来转成非递归）\n\nvoid PutRlist(const listNode * pNode)\n{\n    if（!pNode） return;\n    PutRlist(pNode->m_pNext);\n    \/\/输出。\n    std::cout<<pNode->m_nKey<< \"<-\";\n}",
    "ID" : "55f2e51de4b0152a61143390",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "从尾到头输出链表\n题目：输入一个链表的头结点，从尾到头反过来输出每个结点的值。链表结点定义如下：\nstruct ListNode\n{\n    int  m_nKey;\n    ListNode *m_pNext;\n};"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c61",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "5",
    "optionC" : "4",
    "optionAnswer" : "B",
    "answer" : "(exp1,exp2)、(exp3,exp4,exp5)表示是两个逗号表达式，值是最后一个值，相当于两个",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "question" : "函数调用func((exp1,exp2),(exp3,exp4,exp5))中所含实参的个数为（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "4",
    "optionC" : "3",
    "optionAnswer" : "A",
    "answer" : "每个字符变量被分配一个字节的内存空间。因此A选项正确。",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "question" : "C语言中char类型数据占字节数为?"
  },
  {
    "ID" : "55f2dfa6e4b0152a61142e2e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1",
    "optionC" : "0",
    "optionAnswer" : "B",
    "answer" : "运行可知",
    "optionB" : "-1",
    "type" : "1",
    "optionA" : "-2",
    "question" : "Initialize integer i as 0, what's the value of i after the following operation?  i += i > 0 ? i++ : i --;  "
  },
  {
    "ID" : "55e429cfe4b0152a610c833d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "700",
    "optionC" : "500",
    "optionAnswer" : "A",
    "answer" : "A和B之间的距离是100，那话费的时间就是100\/(40+60)=1,而鸽子的速度是400，那飞行路程就是400*1=400",
    "optionB" : "600",
    "type" : "1",
    "optionA" : "400",
    "question" : "两个人，A的速度为a，B的速度为b,在一直路上相向而行。在A、B距离为s的时候，A放出一个鸽子C，速度为c，C飞到B后，立即掉头飞向A，遇到A在掉头飞向B......就这样在AB之间飞来飞去，直到A、B相遇，假设a=40， b=60， c=400， s=100，这期间鸽子共飞行路程为"
  },
  {
    "ID" : "55f2e4fee4b0152a6114320c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "E7H",
    "optionC" : "E6H",
    "optionAnswer" : "D",
    "answer" : "十进制数-25的原码为10011001，反码为11100110，补码是反码加1，即为11100111，转化为十六进制即为E7",
    "optionB" : "99H",
    "type" : "1",
    "optionA" : "67H",
    "question" : "假设寄存器为8位，用补码形式存储机器数，包括一位符号位，那么十进制数-25在寄存器表示为："
  },
  {
    "ID" : "55f2e4ffe4b0152a61143256",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0",
    "optionC" : "Error",
    "optionAnswer" : "A",
    "answer" : "如果只是单单上面的代码  编译错误\n如果是下面两种情况，运行正确\n\n##############################\n#define a 10 \n\nvoid foo();  \/\/ 函数声明\n\nint main(){ \n   printf(\"%d..\",a); \n   foo(); \n   printf(\"%d\",a); \n} \n\nvoid foo(){ \n   #undef a \n   #define a 50 \n}\n\n\/out:Excersizes.exe \nExcersizes.obj \n10..10[Finished in 0.4s\n##################################\n#define a 10 \n\nvoid foo(){ \n   #undef a \n   #define a 50 \n}\nint main(){ \n   printf(\"%d..\",a); \n   foo(); \n   printf(\"%d\",a); \n} \n\n\/out:Excersizes.exe \nExcersizes.obj \n50..50[Finished in 0.5s]\n####################################",
    "optionB" : "10..50",
    "type" : "1",
    "optionA" : "10..10",
    "question" : "以下代码的输出结果是?\n\n#define a 10\n \nvoid foo(); \nmain(){\n \n  printf(\"%d..\",a);\n   foo();\n   printf(\"%d\",a);\n}\nvoid foo(){\n   #undef a\n   #define a 50\n}"
  },
  {
    "answer" : "4",
    "ID" : "55f2e51de4b0152a6114339b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "五对夫妇甲,乙,丙,丁,戊举行家庭聚会 每一个人都可能和其他人握手, 但夫妇之间绝对不握手. 聚会结束时, 甲先生问其他人: 各握了几次手? 得到的答案是: 0,1,2,3,4,5,6,7,8. 试问: 甲太太握了___次手?"
  },
  {
    "answer" : "x&7",
    "ID" : "55f2e51de4b0152a61143357",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "x为整型，请用位运算实现x%8?"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c17",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "静态成员函数",
    "optionC" : "虚函数",
    "optionAnswer" : "B",
    "answer" : "构造函数不能被继承。",
    "optionB" : "构造函数",
    "type" : "1",
    "optionA" : "常成员函数",
    "question" : "C++类体系中，不能被派生类继承的有（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c6a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "静态数据成员不能通过类的对象调用",
    "optionC" : "类的每个对象有自己的静态数据成员",
    "optionAnswer" : "D",
    "answer" : "静态成员属于类的即所有对象所共享的，只能在外部进行初始化。使用时可以使用\n形式有两种，类名::静态成员或者对象.静态成员。所以选择D项。",
    "optionB" : "静态数据成员要在构造函数内初始化",
    "type" : "1",
    "optionA" : "静态数据成员是类的所有对象所共有的",
    "question" : "下列关于静态数据成员的描述中正确的是（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c87",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "fstream infile(“d:\\\\file.dat”, ios::in| ios::out);",
    "optionC" : "ofstream infile(“d:\\file.dat”, ios::out);",
    "optionAnswer" : "D",
    "answer" : "打开文件写入数据可用“ios::out”，文件名书写时用到两个“\\”，是因为转义字符“\\\\”代表一个“\\”",
    "optionB" : "ifstream infile(“d:\\\\file.dat”, ios::in);",
    "type" : "1",
    "optionA" : "ifstream infile(“d:\\file.dat”, ios::in);",
    "question" : "要求打开文件 d:\\file.dat，可写入数据，正确的语句是  （  ）"
  },
  {
    "answer" : "7",
    "ID" : "55f2e51ee4b0152a6114339c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "赛马，有25匹马，每次只能5匹马进行比赛，比赛只能得到5匹马之间的快慢程度，而不是速度，请问，最少要比___次，才能获得最快的前3匹马？"
  },
  {
    "ID" : "55f2e4fee4b0152a61143229",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "联合变量占有的内存空间是该联合成员占有最大内存空间的成员所需的存储空间",
    "optionC" : "联合的成员在某一个时刻只有当前的是有效的",
    "optionAnswer" : "A",
    "answer" : "1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。\n2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。",
    "optionB" : "联合的成员是共址的",
    "type" : "1",
    "optionA" : "联合变量定义时不可初始化",
    "question" : "下列关于联合的描述中，错误的是？"
  },
  {
    "answer" : "方案一：\n使用栈，碰到左括号入栈，碰到右括号出栈，看最后栈是否空，是否还有未匹配完的右括号。\n方案二：\n思路同上，但是检查压栈时要对括号做优先级检查。",
    "ID" : "55f2e51de4b0152a61143350",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "假设有如下字符串： (234453)[234]{2324} 现在，要求编程分析其括号配对是否正确。请自行选择下列两种方案之一实现该程序：\n方案一：不考虑括号优先级，只考虑配对正确性；方案二：考虑括号优先级，比如{1[2（3）4]5} 是正确的。但是[1{2}3]是不正确的。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143211",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "func_a 和func_b 分配的内存会自动初始化0",
    "optionC" : "func_b 存在内存泄露",
    "optionAnswer" : "B",
    "answer" : "栈上的数据是一个随机值，一般是0xcccccccc,而堆上的内存如果不调用相应的构造函数或者显示初始化它是不会被初始化的",
    "optionB" : "func_b 使用了太多的栈，程序可能会在运行时候崩溃。",
    "type" : "1",
    "optionA" : "func_a 获得临时内存的方式效率通常更高。",
    "question" : "请阅读下面代码片段并且回答问题：\n\n#define SIZE_20M (20*1024*1024)\nvoid func_a()\n{\n    char *tmp = malloc(SIZE_20M)\n    return;\n}\nvoid func_b()\n{\n    char temp[SIZE_20M];\n    \/\/...do something using temp\n    return;\n}\n\n关于这段代码，下列说法正确的是"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114325d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "常量是在程序运行过程中值不能被改变的量",
    "optionC" : "定义符号常量必须用类型名来设定常量的类型",
    "optionAnswer" : "C",
    "answer" : "数值型常量有整型常量,实型常量,不论是整型常量还是实型常量都有正值和负值之分,所以A正确。在C语言的预编译处理中,可以用符号名代表一个常量,定义时不必指定常量类型,所以C错误,B正确。常量的定义就是常量是在程序运行过程中值不饿能够被改变的量,所以D正确。",
    "optionB" : "常量可以用一个符号名来代表",
    "type" : "1",
    "optionA" : "数值型常量有正值和负值的区分",
    "question" : "以下叙述中错误的是？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f8",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0",
    "optionC" : "16",
    "optionAnswer" : "D",
    "answer" : "func(1)=0，因为没有break语句，switch中会一直计算到b=0。这是提醒我们不要忘了break。",
    "optionB" : "20",
    "type" : "1",
    "optionA" : "30",
    "question" : "int func(int a)\n{\n    int b;\n    switch (a)\n    {\n        case 1: b = 30;\n        case 2: b = 20;\n        case 3: b = 16;\n        default: b = 0;\n    }\n    return b;\n}\n则func(1) = ?"
  },
  {
    "answer" : "算法思想：当然最直接的方法是采用暴力法，从N+1开始逐步加1判断是否是不重复数，是就退出循环输出，这种方法一般是不可取的，例如N=11000000，你要一个个的加1要加到12010101，一共循环百万次，每次都要重复判断是否是不重复数，效率极其低下，因此是不可取的。这里我采用的方法是：从N+1的最高位往右开始判断与其次高位是否相等，如果发现相等的（即为重复数）则将次高位加1，注意这里可能进位，如8921—>9021，后面的直接置为010101...形式，如1121—>1201，此时便完成“不重复数”的初步构造，但此时的“不重复数”不一定是真正的不重复的数，因为可能进位后的次高位变为0或进位后变成00，如9921—>10001，此时需要再次循环判断重新构造直至满足条件即可，这种方法循环的次数比较少，可以接受。\n\nSource Code：\n\/\/ 求比指定数大且最小的“不重复数”\n#include <stdio.h>void minNotRep(int n)\n{\n    \/\/ 需要多次判断\n    while(1)\n    {\n        int a[20], len = 0, i, b = 0;\n        \/\/ flag为true表示是“重复数”，为false表示表示是“不重复数”\n       bool flag = false;\n       \/\/ 将n的各位上数字存到数组a中\n        while(n)\n        {\n           a[len++] = n % 10;\n            n = n \/ 10;\n        }\n        \/\/ 从高位开始遍历是否有重复位\n        for(i = len - 1; i > 0; i--)\n       {\n           \/\/ 有重复位则次高位加1（最高位有可能进位但这里不需要额外处理）\n            if(a[i] == a[i - 1] && !flag)\n           {\n                a[i - 1]++;\n               flag = true;\n            }\n            else if(flag)\n           {\n                \/\/ 将重复位后面的位置为0101...形式\n                a[i - 1] = b;\n                b = (b == 0) ? 1 : 0;\n            }\n        }\n       \/\/ 重组各位数字为n，如果是“不重复数”则输出退出否则继续判断\n        for(i = len - 1; i >= 0; i--)\n        {\n            n = n * 10 + a[i];\n        }\n       if(!flag)\n        {\n            printf(\"%d\\n\", n);\n           break;\n       }\n    }\n}\nint main()\n{\n    int N;\n    while(scanf(\"%d\", &N))\n    {\n        minNotRep(N + 1);\n   }\n   return 0;\n}<\/stdio.h>",
    "ID" : "55f2e51ee4b0152a611433a9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定N是一个正整数，求比N大的最小“不重复数”，这里的不重复是指没有两个相等的相邻位，如1102中的11是相等的两个相邻位故不是不重复数，而12301是不重复数。"
  },
  {
    "answer" : "DQFXAPBNMYCW",
    "ID" : "55f2e51de4b0152a6114336f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "设有字母序列{Q,D,F,X,A,P,N,B,Y,M,C,W}，请写出按二路归并方法对该序列进行一趟扫描后的结果为___。\n(输出结果请按照以下格式：ABCDEFG，字母之间没有逗号)"
  },
  {
    "ID" : "55f2e4fee4b0152a611431ef",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "运行",
    "optionAnswer" : "A",
    "answer" : "const用来说明所定义的变量是只读的。 这些在编译期间完成，编译器可能使用常数直接替换掉对此变量的引用",
    "optionB" : "链接",
    "type" : "1",
    "optionA" : "编译",
    "question" : "c++中，声明const int i,是在哪个阶段做到 i只可读的？"
  },
  {
    "ID" : "55f2e4fee4b0152a61143222",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "hellotheword",
    "optionC" : "hello",
    "optionAnswer" : "B",
    "answer" : "a是指针的数组 \nchar** p = a; \/\/char** p = &a[0] \np++;\/\/p是指针自增+4，而a中元素是指针，每个正好四个字节，因此p++后恰好p= &a[1] *p=a[1];输出\"the\"，输出结果为B",
    "optionB" : "the",
    "type" : "1",
    "optionA" : "theworld",
    "question" : "下列程序的输出结果为：\n\n#include\nvoid main()\n{\n       char* a[ ] = { \"hello\", \"the\", \"world\"};\n       char** pa = a;\n       pa++;\n       cout<<”*pa<<endl;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a6114324a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "20",
    "optionC" : "60",
    "optionAnswer" : "B",
    "answer" : "这个题的为难之处呢，就在于前面定义结构体里面用到的冒号，如果你能理解这个符号的含义，那么问题就很好解决了。这里的冒号相当于分配几位空间，也即在定义结构体的时候，分配的成员a 4位的空间， b 5位，c 7位，一共是16位，正好两个字节。下面画一个简单的示意：\n变量名  位数\ntest    15 14 13 12 11 10 9 |8 7 6 5 4 |3 2 1 0\ntest.a                      |          |0 0 1 0\ntest.b                      |0 0 0 1 1 |\ntest.c   0  0  0  0  0  0 0 |          |\n在执行i=*((short *)&test); 时，取从地址&test开始两个字节（short占两个字节）的内容转化为short型数据，即为0x0032，再转为int型为0x00000032，即50",
    "optionB" : "50",
    "type" : "1",
    "optionA" : "30",
    "question" : "写出下列程序在X86上的运行结果\n\nstruct mybitfields\n{\n    unsigned short a : 4;\n    unsigned short b : 5;\n    unsigned short c : 7;\n} test\n \nvoid main(void)\n{\n    int i;\n    test.a = 2;\n    test.b = 3;\n    test.c = 0;\n \n    i = *((short *)&test);\n    printf(\"%d\\n\", i);\n}"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c10",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "构造函数必须指定类型说明",
    "optionC" : "构造函数可以设置默认参数",
    "optionAnswer" : "D",
    "answer" : "构造函数无返回类型不能继承但可以重载，所以选择D项。",
    "optionB" : "构造函数可以重载",
    "type" : "1",
    "optionA" : "构造函数的函数名与类名相同",
    "question" : "构造函数不具备的特征是（）"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114325a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "当使用free释放掉一个指针内容后，指针变量的值被置为NULL",
    "optionC" : "野指针是指向未分配或者已释放的内存地址",
    "optionAnswer" : "D",
    "answer" : "编译器不会自动置NULL，需要程序员手动置NULL，否则free会产生野指针。",
    "optionB" : "指针的数据类型声明的是指针实际指向内容的数据类型",
    "type" : "1",
    "optionA" : "32位系统下任何类型指针的长度都是4个字节",
    "question" : "以下对C语言的”指针“描述不正确的是："
  },
  {
    "ID" : "55f2e4ffe4b0152a6114325c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "32位下：4,4,2^32     64位下：4,4,2^64",
    "optionC" : "32位下：4,4,2^32     64位下：4,8,2^64",
    "optionAnswer" : "C",
    "answer" : "特别是int相关的类型在不同位数机器的平台下长度不同。C99标准并不规定具体数据类型的长度大小，只规定级别。作下比较：  \n（1）16位平台  \nchar         1个字节8位 \nshort        2个字节16位 \nint             2个字节16位 \nlong         4个字节32位 \n指针         2个字节16位  \n（2）32位平台  \nchar         1个字节8位 \nshort        2个字节16位 \nint             4个字节32位 \nlong         4个字节32位\nlong long    8个字节64位  \n指针         4个字节32位  \n（3）64位平台  \nchar     1个字节 \nshort     2个字节\n int                 4个字节  \nlong             8个字节（区别） \nlong long    8个字节  \n指针             8个字节（区别）",
    "optionB" : "32位下：4,4,不限制   64位下：4,8,不限制",
    "type" : "1",
    "optionA" : "32位下：4,4,2^32     64位下：8,8,2^64",
    "question" : "以下系统中，int类型占几个字节，指针占几个字节，操作系统可以使用的最大内存空间是多大："
  },
  {
    "answer" : "*\/3 14-15 * * 1,2,3,4,5 \/home\/script\/check.sh\n周一到周五每天14-15点内，每隔3分钟执行一次check.sh脚本\nLinux crontab定时执行任务 \n基本格式 : \n*　　*　　*　　*　　*　　command \n分　时　日　月　周　命令 \n第1列表示分钟1～59 每分钟用*或者 *\/1表示 \n第2列表示小时1～23（0表示0点） \n第3列表示日期1～31 \n第4列表示月份1～12 \n第5列标识号星期0～6（0表示星期天） \n第6列要运行的命令",
    "ID" : "55f2e51ce4b0152a6114332a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "现有\/home\/script\/check.sh脚本，要求每周一到周五14点内每三分钟运行一次，相应的crontab配置是()"
  },
  {
    "ID" : "55f2e469e4b0152a61143131",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "运行",
    "optionAnswer" : "A",
    "answer" : "const用来说明所定义的变量是只读的。 这些在编译期间完成，编译器可能使用常数直接替换掉对此变量的引用。",
    "optionB" : "链接",
    "type" : "1",
    "optionA" : "编译",
    "question" : "c++中，声明const int i,是在哪个阶段做到 i只可读的？"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c15",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "继承",
    "optionC" : "是一个类的成员函数与另一个类的关系",
    "optionAnswer" : "D",
    "answer" : "友元可以是函数与类的关系即友元函数，也可以类与类的关系即友元类，但友元不\n能继承，是单向性，且不具有传递性。友元可以访问类中所有成员，提高了访问的方便性。因此\n选择D项。",
    "optionB" : "是类与类的关系",
    "type" : "1",
    "optionA" : "提高程序的运行效率",
    "question" : " 友元关系不能（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7eb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1",
    "optionC" : "0.5",
    "optionAnswer" : "C",
    "answer" : "",
    "optionB" : "0.25",
    "type" : "1",
    "optionA" : "0",
    "question" : "#include <stdio.h > \nmain()\n{ \n    double x=2.0,y;\n    if(x<0.0)y=0.0;\n    else if((x<5.0)&&(! x)) y=1.0\/(x+2.0);\n    if(x<10.0)y=1.0\/x;\n    else if y=10.0;\n    printf(\"％f\\n\",y);\n}\n程序运行后的输出结果是"
  },
  {
    "ID" : "55f2dfa6e4b0152a61142e2a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "None of the above.",
    "optionC" : "Multiple threads mar cause deadlock,while multiple processes won't cause deadlock.",
    "optionAnswer" : "B",
    "answer" : "B是对的，AC都有错",
    "optionB" : "Changes to the main thread(cancellation，priority change，etc.) may affect the behavior of the other threads of the process; Changes to the parent process does not affect child processes.",
    "type" : "1",
    "optionA" : "Threads share the same address space of the parent process;Processes share the same address space of the parent process.",
    "question" : "Which statement(s) is(are) correct about thread and process？"
  },
  {
    "ID" : "55f2e4fee4b0152a61143249",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "一个抽象类和接口中的方法必须是抽象方法",
    "optionC" : "纯虚函数和虚函数的区别在于前者不包含定义，而后者可以包含函数体。",
    "optionAnswer" : "D",
    "answer" : "抽象类 ： 类中至少有一个方法是抽象方法，则该类就是抽象类\n接口 ：类中的方法全部都是抽象方法。 ",
    "optionB" : "c++中没有接口的概念，与之对应的是纯虚类，对应的是java的接口",
    "type" : "1",
    "optionA" : "c++虚类相当与java里面的抽象类",
    "question" : "下述有关c++的虚类和java接口的描述，说法错误的是？"
  },
  {
    "answer" : "用栈来出现，凡是左括号就压栈，凡是右括号就出栈，最后如果栈为空就匹配正确",
    "ID" : "55f2e51ee4b0152a611433a0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "判断一个括号字符串是否匹配正确，如果括号有多种，怎么做？如（（[]））正确，[[(()错误。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143200",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "两者可能等价",
    "optionC" : "#include <filename.h>搜索范围比#include “filename.h”小",
    "optionAnswer" : "B",
    "answer" : "#include\"\"从当前工作路径开始搜索，然后扩展到标准库路径。?",
    "optionB" : "#include “filename.h”只搜索用户工作路径",
    "type" : "1",
    "optionA" : "#include <filename.h>只搜索标准库路径",
    "question" : "对于#include ??<filename.h>?和 #include “filename.h”，以下说法错误的是（ ）。"
  },
  {
    "ID" : "55e6d85be4b0152a610de81c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "不确定",
    "optionC" : "8",
    "optionAnswer" : "B",
    "answer" : "指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "2",
    "question" : "一个32位的机器,该机器的指针是多少字节?"
  },
  {
    "ID" : "55e6d85ae4b0152a610de800",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "不存在指向空值的引用，但是存在指向空值的指针。",
    "optionC" : "删除空指针是无害的，不能删除引用。",
    "optionAnswer" : "B",
    "answer" : "声明一个引用的同时，如果不是作为函数的参数或返回值，必须进行初始化，明确引用是哪个变量的别名，引用一旦成为某个变量的别名后，在程序运行过程中不可改变这种指代关系。",
    "optionB" : "指针初始化以后不能被改变，引用可以改变所指的对象。",
    "type" : "1",
    "optionA" : "引用必须被初始化，指针不必。",
    "question" : "关于引用与指针的区别，下面叙述错误的是："
  },
  {
    "ID" : "55f2e4fee4b0152a61143212",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "3,5",
    "optionC" : "6,7",
    "optionAnswer" : "C",
    "answer" : "const在前，内容不能变；\nconst在后，指针不能变；\nconst* ，指针指向为常量；\n*const ，指针本身为常量。\n",
    "optionB" : "1,3,5,6",
    "type" : "1",
    "optionA" : "1,2,3,4,5,6,7",
    "question" : "请找出下面程序中有哪些错误：\n\nint main()\n{\n   int i=10;\n   int j=1;\n   const int *p1;\/\/(1)\n   int const *p2=&i; \/\/(2)\n   p2=&j;\/\/(3)\n   int *const p3=&i;\/\/(4)\n   *p3=20;\/\/(5)\n   *p2=30;\/\/(6)\n   p3=&j;\/\/(7)\nreturn 0;\n}"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c89",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "反对称性",
    "optionC" : "传递性",
    "optionAnswer" : "C",
    "answer" : "任何一个类都可以派生出一个新类，派生类也可以再派生出新类，再次派生出的新类也具有之前基类的成员，因此继承具有传递性。",
    "optionB" : "对称性",
    "type" : "1",
    "optionA" : "自反性",
    "question" : "在C++中，类与类之间的继承关系具有（  ）"
  },
  {
    "answer" : "int n = INT_MIN;\ndo\n{\n    if(0 != f(n))\n    {\n        \/\/error\n        break;\n     }\n}\nwhile(n++ != INT_MIN);\n\nif(n != INT_MIN) error;\/\/",
    "ID" : "55f2e51de4b0152a61143395",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一个函数“int f(int n)”，请编写一段程序调试函数f(n)是否总是返回0，并添加必要的注视和说明。"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f8",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "A::f() A::f()const",
    "optionC" : "A::f() B::f()const",
    "optionAnswer" : "B",
    "answer" : "类A中的f函数是虚函数，可以实现动态绑定。\n因此第一次调用a->f()的时候调用的是其实际类型B的f()函数，输出B::f() \n第二次调用，常指针调用const函数，输出 A::f()const",
    "optionB" : "B::f() A::f()const",
    "type" : "1",
    "optionA" : "B::f() B::f()const",
    "question" : "What's the output of the following code?(3 Points)\n\nclass A\n{\n    public:\n    virtual void f()\n    {\n        cout<<\"A::f()\"<<endl;\n    }\n    void f() const {\n        cout<<“A::f() const\"<<endl;\n    }\n}\nclass B : A\n{\n    public:\n    void f(){\n        cout<<“B::f()”<<endl;\n    }\n}\ng(const a* a)\n{\n    a->f();\n}\nint main()\n{\n    A* a = new B();\n    a->f();\n    g(a);\n    delete a ;\n}"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c29",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "字符型函数",
    "optionC" : "虚函数",
    "optionAnswer" : "C",
    "answer" : "使用关键字static声明的成员函数就是静态成员函数，静态成员函数也属于整个类\n而不属于类中的某个对象，它是该类的所有对象共享的成员函数。\n静态成员函数可以在类体内定义，也可以在类外定义。当在类外定义时，要注意不能使用\nstatic关键字作为前缀。\n由于静态成员函数在类中只有一个拷贝（副本），因此它访问对象的成员时要受到一些限制：静\n态成员函数可以直接访问类中说明的静态成员，但不能直接访问类中说明的非静态成员；若要访\n问非静态成员时，必须通过参数传递的方式得到相应的对象，再通过对象来访问。虚函数是非静\n态的、非内联的成员函数。静态成员函数不能被说明为虚函数。",
    "optionB" : "浮点函数",
    "type" : "1",
    "optionA" : "整型函数",
    "question" : "静态成员函数不能说明为（）"
  },
  {
    "answer" : "package com.yuzhouwan.changeSourceString;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\n\/**\n * \n * 给定一个原串和目标串，能对源串进行如下操作：<br>\n * 1.在给定位置插入一个字符 <br>\n * 2.替换任意字符 <br>\n * 3.删除任意字符 要求完成一下函数，返回最少的操作数，使得源串进行这些操作后等于目标串。源串和目标串长度都小于2000。<br>\n * \n * @author asdf2015\n * \n *\/\npublic class ChangeStringTest {\n\n    \/**\n     * 返回从源字符串到目标字符串的最小操作数 source: 源字符串 target：目标字符串 返回：最小操作数\n     *\/\n    public int minOperationCount(String source, String target) {\n        int operator = 0;\n        char[] sChars = source.toCharArray();\n        char[] tChars = target.toCharArray();\n\n        int sLen = sChars.length;\n        int tLen = tChars.length;\n        int len = sLen > tLen ? sLen : tLen;\n\n        if (sLen == 0 || tLen == 0)\n            return len;\n\n        for (int j = 0, i = 0; i <= len;) {\n\n            if (i >= sLen)\n                return operator + len - j;\n            if (j >= tLen)\n                return operator + len - i;\n\n            if (sChars[i] != tChars[j]) {\n\n                if (j + 1 < tLen && sChars[i] == tChars[j + 1]) {\n                    source = addChar(source, i, tChars[j]);\n                    i++;\n                    j += 2;\n                } else if (i + 1 < sLen && sChars[i + 1] == tChars[j]) {\n                    source = deteleChar(source, i);\n                    i += 2;\n                    j++;\n                } else {\n                    source = replaceChar(source, i, sChars[j]);\n                    i++;\n                    j++;\n                }\n                operator++;\n\n            } else {\n                i++;\n                j++;\n            }\n        }\n        return operator;\n    }\n\n    @Test\n    public void testMinOperationCount() {\n        assertEquals(0, minOperationCount(\"a\", \"a\"));\n        assertEquals(1, minOperationCount(\"\", \"a\"));\n        assertEquals(1, minOperationCount(\"a\", \"ab\"));\n        assertEquals(1, minOperationCount(\"ad\", \"ab\"));\n        assertEquals(1, minOperationCount(\"ad\", \"a\"));\n        assertEquals(2, ",
    "ID" : "55f2e51de4b0152a61143383",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个原串和目标串，能对源串进行如下操作： \n1.在给定位置插入一个字符 \n2.替换任意字符 \n3.删除任意字符 要求完成一下函数，返回最少的操作数，使得源串进行这些操作后等于目标串。源串和目标串长度都小于2000。"
  },
  {
    "answer" : "堆栈溢出一般是循环的递归调用导致的,如果使用的大数据结构的局部变量,也可能导致",
    "ID" : "55f2e51ee4b0152a611433d1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "堆栈溢出一般是由什么原因导致的？"
  },
  {
    "answer" : "int arrive_time[] = new int[] { 10, 12, 15, 17, 18, 19, 19, 20, 25 };\nint process_time[] = new int[] { 1, 18, 10, 19, 16, 8, 6, 7, 3 };\nint total = 0, lastTime = 0;\nint atms[] = new int[] { 0, 0, 0, 0 };\nfor (int i = 0; i < process_time.length; i++) {\n        int time = arrive_time[i] - lastTime;\n        for (int j = 0; j < atms.length; j++) {\n            atms[j] -= time;\n    }\n    lastTime = arrive_time[i];\n    boolean wait = true;\n    for (int j = 0; j < atms.length; j++) {\n        if (atms[j] <= 0) {\n            atms[j] = process_time[i];\n            wait = false;\n            break;\n        }\n    }\n    if (wait) {\n        int temp = atms[0];\n        for (int j = 0; j < atms.length; j++) {\n            for (int j2 = j + 1; j2 < atms.length; j2++) {\n                if (atms[j2] < atms[j]) {\n                    temp = atms[j2];\n                    atms[j2] = atms[j];\n                    atms[j] = temp;\n        }\n    }\n}\n        total += atms[0];\n        atms[0] += process_time[i];\n    }\n}\nSystem.out.println((double) total \/ arrive_time.length);",
    "ID" : "55f2e51de4b0152a6114337b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "银行取款排队模拟 \n假设银行有4个柜台，假设某天有200位客户来办理业务，每个客户到达银行的时间和业务处理时间分别用两个数组arrive_time 和 process_time 来描述。 \n请写程序计算所有客户的平均等待时间，假设每个客户在去到营业部之后先拿号排队，然后在任意一个柜台有空闲的时候，号码数最小的客户上去办理，假设所有的客户拿到号码之后不会因为银行众所周知的慢而失去耐心走掉。"
  },
  {
    "ID" : "55f2e46ae4b0152a61143158",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Func(&(*a))",
    "optionC" : "Func(*a)",
    "optionAnswer" : "A",
    "answer" : "C++中&有另外一个含义，用来声明引用，&不是地址运算符，而是类型标识符的一部分。就像声明char*指的是指向char的指针一样，int &指的是指向int的引用，变量和变量的引用指向相同的值和内存单元，引用相当于变量的别名。因此在参数传递时也只需要传递变量名即可，即Func(a)。它的形式上看起来与值传递相同，但它传递参数时不复制副本，与指针一样可以修改主调函数的参数值，且使用起来更方便。",
    "optionB" : "Func(&a)",
    "type" : "1",
    "optionA" : "Func(a)",
    "question" : "某函数申明如下：\nvoid Func(int &nVal1);\n有int a,下面使用正确的为："
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c1d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "若文件存在，打开失败；若文件不存在，建立一个新文件",
    "optionC" : "若文件存在，将文件写指针定位于文件首；若文件不存在，建立一个新文件",
    "optionAnswer" : "A",
    "answer" : "ios::binary，采用二进制形式，ios::app定位到文件尾部。",
    "optionB" : "若文件存在，将其置为空文件；若文件不存在，打开失败",
    "type" : "1",
    "optionA" : "若文件存在，将文件写指针定位于文件尾；若文件不存在，建立一个新文件",
    "question" : "语句ofstream f(“TEMP.DAT”,ios::app｜ios::binary)?的功能是建立流对象f，试图打\n开文件TEMP.DAT 并与之连接，并且（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114321d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "5",
    "optionC" : "18",
    "optionAnswer" : "A",
    "answer" : "本题考查位运算中按位或运算符,或运算只要两个比较的位中有一个为1,否则结果为0,,13用二进制表示为00001101,5用二进制表示为00000101,或后00001101,即13,选项A正确。",
    "optionB" : "15",
    "type" : "1",
    "optionA" : "13",
    "question" : "若有一下程序\n\n#include<stdio.h>\nmain(){\n    int c;\n    c=13 | 5;\n    printf(\"%d\\n\",C);\n｝\n则程序的输出结果是？"
  },
  {
    "answer" : "\/\/ ---------------------------------------------------   \n\/\/  注1: 一般要求一个解,此程序是得到所有解   \n\/\/  注2: 由于32位unsigned int限制,最多32个物品                           \n\/\/ ---------------------------------------------------   \n  \n#include \"stdafx.h\"   \n#include <iostream>   \nusing   namespace  std;  \n  \n\/\/ 物品总数   \nconst   int  N_ITEM = 5;  \n  \n\/\/ 背包能装的重量   \nconst   int  BAG = 15;  \n  \n\/\/ 初始化每个物品的重量   \nint  item[N_ITEM] = {2, 3, 5, 7, 8};  \n  \n\/\/ 标记数组   \nint  flag[N_ITEM] = {0, 0, 0, 0, 0};  \n  \n\/\/ 结果计数器   \nint  resultCount = 0;  \n  \n\/\/ 打印结果   \nvoid  Print();  \n  \nint  main()  \n{  \n    \/\/ 打印已知条件   \n    cout << \"BAG Weight:\"  << BAG << endl;  \n    cout << \"Item Number:\"  << N_ITEM << endl;  \n  \n    for  ( int  i=0; i!=N_ITEM; i++)  \n    {  \n        cout << \"Item.\"  << i+1 <<  \" W=\"  << item[i] <<  \"\\t\" ;  \n    }  \n  \n    cout << endl;  \n  \n    unsigned int  count = 0;  \n    unsigned int  all_count = 1;  \n  \n    for  ( int  i=0; i!=N_ITEM; i++)  \n    {  \n        all_count *= 2;\/\/all_count记录可能解的个数   \n    }  \n  \n    while  (1)  \n    {  \n        \/\/ 模拟递归...列举所有flag数组可能   \n        \/\/ 其实就这个for循环是关键   \n        for  ( int  i=0; i!=N_ITEM; i++)  \n        {  \n            if  ( 0 == flag[i] )  \n            {  \n                flag[i] = 1;  \n                continue ;  \n            }             \n            else    \n            {  \n                flag[i] = 0;  \n                break ;  \n            }  \n        }  \n          \n        \/\/ 本次重量,初始化0   \n        int  temp = 0;  \n  \n        \/\/ 按标记计算所有选中物品重量和   \n        for  ( int  i=0; i!=N_ITEM; i++)  \n        {  \n            if  ( 1 == flag[i] )  \n            {  \n                temp += item[i];  \n            }  \n        }  \n  \n        \/\/ 满足背包重量就打印   \n        if  ( temp == BAG )  \n        {  \n            resultCount++;  \n            Print();  \n        }         \n  \n        \/\/ 如果遍历了所有情况就break掉while(1)循环   \n        count++;  \n        if  (count == all_count)  \n        {  \n            break ;  \n        }  \n    }  \n  \n    return  0;  \n}  \n  \nvoid  Print() ",
    "ID" : "55f2e51de4b0152a61143385",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "“背包题目”的基本描述是：有一个背包，能盛放的物品总重量为S,设有N件物品，其重量分别为w1，w2，…，wn，希望从N件物品中选择若干物品，所选物品的重量之和恰能放进该背包，即所选物品的重量之和即是S。递归和非递归解法都能求得“背包题目”的一组解，试写出“背包题目”的非递归解法"
  },
  {
    "answer" : "1和2 先过。1返回，5和10先过，2返回，1和2一起过。一共时间=2+1+10+2+2=17分钟",
    "ID" : "55f2e51de4b0152a61143392",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有ABCD四个人要在夜里过一座桥，他们通过这座桥分别需要耗时1、2、5、10分钟，现在只有一支手电，过桥时必须带有手电，并且同时最多只能两个人一起过桥。请问如何安排能够让四个人尽快都过桥。"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143265",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "10",
    "optionC" : "9",
    "optionAnswer" : "B",
    "answer" : "本题考查宏定义,宏定义只是做个简单的替换,执行SQR( k+m )\/SQP( k+m )=k+m*k+m\/k+m*k+m=15\/2, a\/ = SQR( k+m )的结果为1, 选项B正确。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "有以下程序\n\n#include <stdio.h>\n#define SQR( X ) X * X\nmain( )\n{\n    int a=10, k=2, m=1;\n    a \/ = SQR( k+m )\/SQR( k+m );\n    printf( \"%d\\n\" ,a );\n}\n程序运行后的输出结果是?"
  },
  {
    "ID" : "55f2e469e4b0152a61143127",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类是具有共同行为的若干对象的统一描述体",
    "optionC" : "对象是类的实例，一个对象必须属于一个已知的类",
    "optionAnswer" : "A",
    "answer" : "c语言中结构体无成员函数，而c++中的类是有成员函数的",
    "optionB" : "类和对象之间的关系是抽象和具体的关系",
    "type" : "1",
    "optionA" : "类就是C语言中的结构体类型，对象就是C语言中的结构体变量",
    "question" : "下面关于类和对象的描述中，错误的是："
  },
  {
    "answer" : "vector<int> findSeq(unsigned __int64* file_length,int n, unsigned block_length)\n{\n    vector<int> seqnums;\n    unsigned __int64 totalSize = 0;\n    int preSeq=-1;\n    for(int i=0; i<n;i++){\n        totalSize += file_length[i];\n        int seq = totalSize\/block_length;\n        if(!(totalSize%block_length)){\n        seq--;\n        }\n       if(preSeq==seq){\n            if(seqnums.empty()||seqnums.back()!=seq){\n                  seqnums.push_back(seq);\n            }\n       }\n preSeq = seq;\n    }\n    return seqnums;\n}",
    "ID" : "55f2e51ee4b0152a611433b4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有n个文件的长度记载在一个无符号64位整数数组中unsigned__int64 file_length[n]，把这n 个文件从逻辑上按序首尾拼接在一起形成一个逻辑上的大文件，然后以每块长度为unsigned block_length把这个逻辑上的大文件划分成大小相等的数据块（当然，最后一块有可能比block_length小），请定义和实现一个函数，把边界块的序号集合返回给函数的调用者（第一个数据块序号为0）。\n注：边界块指的是跨多个文件的数据块。"
  },
  {
    "ID" : "55e6d85be4b0152a610de822",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "hello",
    "optionC" : "程序崩溃",
    "optionAnswer" : "C",
    "answer" : "GetMemory(char *p);这里*p是形参,是局部变量\n不能讲malloc申请的地址指针返回，造成内存泄露\n更严重的是执行GetMemory(str);后str依然为NULL\n执行strcpy(str, 'hello world');就会出错",
    "optionB" : "显示为乱码",
    "type" : "1",
    "optionA" : "hello world",
    "question" : "运行下面这段代码，会出现的情况是:()void GetMemory(char *p)\n{\n    p = (char *)malloc(100);\n}\nvoid Test(void)\n{\n    char *str = NULL;\n    GetMemory(str);\n    strcpy(str, 'hello world');\n    printf(str);\n}"
  },
  {
    "answer" : "40",
    "ID" : "55f2e51de4b0152a6114339a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "小支欲用积分兑换安仔娃娃。兑换的规则是10积分可以兑一个安仔并返还5积分。小支有200积分，最多可以兑到___个安仔？(假设可以借积分)"
  },
  {
    "ID" : "55e6d85be4b0152a610de817",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "map的删除操作只会导致指向被删除元素的迭代器失效",
    "optionC" : "vector的删除操作只会导致指向被删除元素及后面的迭代器失效",
    "optionAnswer" : "A",
    "answer" : "因为由 Vector 的 iterator 和 listIterator 方法所返回的迭代器是快速失败的?：如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。",
    "optionB" : "map的插入操作不会导致迭代器失效",
    "type" : "1",
    "optionA" : "vector的插入操作不会导致迭代器失效",
    "question" : "下面关于迭代器失效的描述哪个是错误的（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c68",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "double",
    "optionC" : "void",
    "optionAnswer" : "C",
    "answer" : "无形参或无返回值都可以用void来声明，int char double分别是整型、字符型和实型。",
    "optionB" : "char",
    "type" : "1",
    "optionA" : "int",
    "question" : "在C++中不返回任何类型的函数应该说明为（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143223",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "19",
    "optionC" : "16",
    "optionAnswer" : "D",
    "answer" : "5 * add(3, 4)\n对于宏，编译器会直接替换，所以上述表达式变成5 * 3 + 4 = 19",
    "optionB" : "25",
    "type" : "1",
    "optionA" : "23",
    "question" : "下列程序的输出是：（ ）\n\n#define add(a,b) a+b\nint main()\n{\n    printf(“ % d\\n”, 5 * add(3, 4));\n    return 0;\n}\n"
  },
  {
    "answer" : "1.通过拓扑排序来建立执行顺序.\n2. 对于无关联的拓扑节点可以并发执行",
    "ID" : "55f2e51ee4b0152a611433d9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "用 C 语言写一个函数来执行一串任务。任务是互相依赖的。比如 B 任务依赖 A 任 务，则 A 完成 B 才能执行。不考虑并发限制，假设所有的任务都能一次执行成功， 所有的任务执行时间都相等。任务数据结构原型为：\ntypedef struct {\n    \/\/该任务的 ID\n    int id;\n    \/\/该任务依赖的任务的 ID\n    int *child;\n    \/\/该任务依赖的任务个数\n    int child_num;\n} task;\n \n\/\/ 函数原型：\nbool doschedule(task*pask，inttask_num);\n \n\/\/以下函数可以直接调用：\nvoid dotask(int id); \/\/执行一个进程\n \n\/\/等待 timeout 时间，并返回一个执行成功的任务的 id，如果没有任务在时间片内完成，则返回-1\nint waittask(int timeout);\n \nbool killtask(int id); \/\/杀掉一个进程"
  },
  {
    "ID" : "55e6d85ae4b0152a610de810",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "16",
    "optionC" : "15",
    "optionAnswer" : "D",
    "answer" : "func(5)=5+func(4)\nfunc(4)=4+func(3)\nfunc(3)=3+func(2)\nfunc(2)=2+func(1)\nfunc(1)=1+func(0)\nfunc(0)=1\n5+4+3+2+1+1=16",
    "optionB" : "10",
    "type" : "1",
    "optionA" : "0",
    "question" : "下列程序的输出结果为:#include<iostream.h>\nint func(int n)\n{\n　　 if(n<1)\n       return 1;\n    else\n       return n+func(n-1);\n    return 0;\n}\nvoid main() {\n    cout<< func(5) <<endl;\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114327c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "7 9",
    "optionC" : "1 3",
    "optionAnswer" : "A",
    "answer" : "a指向三维数组，&a+1指向数组的下一个位置。*(ptr-1)指向数组的最后一个元素，数组的最后一个元素为12。\na+1指向a[1][0][0]的位置，该位置的元素为7。",
    "optionB" : "1 6",
    "type" : "1",
    "optionA" : "7 12",
    "question" : "求输出结果 \nint a[2][2][3]= { {{1,2,3},{4,5,6}},{{7,8,9},{10,11,12}}};\nint *ptr=(int *)(&a+1);\nprintf(“%d %d”, *(int*)(a+1), *(ptr-1));"
  },
  {
    "ID" : "55f2e4fee4b0152a61143243",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "覆盖是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同",
    "optionC" : "隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了",
    "optionAnswer" : "D",
    "answer" : "使用相同函数名但参数个数不同或参数类型不同应该是函数重载，函数覆盖发生在父类与子类之间，其函数名、参数类型、返回值类型必须同父类中的相对应被覆盖的函数严格一致，覆盖函数和被覆盖函数只有函数体不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本，这种机制就叫做函数覆盖。",
    "optionB" : "继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展",
    "type" : "1",
    "optionA" : "封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏",
    "question" : "下面有关继承、多态、组合的描述，说法错误的是?"
  },
  {
    "ID" : "55f2e46ae4b0152a6114315e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "没有办法能做到",
    "optionC" : "将构造函数和析构函数均设为私有",
    "optionAnswer" : "B",
    "answer" : "[ 编 译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。 因此， 将析构函数设为私有，类对象就无法建立在栈（静态）上了，只能在堆上（动态new）分配类对象 。]",
    "optionB" : "将析构函数设为私有",
    "type" : "1",
    "optionA" : "将构造函数设为私有",
    "question" : "在C++中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143221",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "xycdBCD",
    "optionC" : "ABabcz",
    "optionAnswer" : "D",
    "answer" : "原型：char  *strcat  ( char  *dest, const  char  *src)\n    用法：#include  <string.h>\n    功能：连接两个字符串；strcat()会将参数src字符串 拷贝到 参数dest所指的字符串尾。 第一个参数dest要有足够的空间来容纳要拷贝的字符串。\n    说明：strcat()返回dest的字符串起始地址。",
    "optionB" : "abcABz",
    "type" : "1",
    "optionA" : "xyabcAB",
    "question" : "下列程序的输出结果是#include<iostream>\nusing namespace std;\n \nint main()\n{\n    char p1[10] = \"abcd\", *p2, str[10] = \"xyz\";\n    \n    p2 = \"ABCD\";\n    strcpy(str + 2, strcat(p1 + 2, p2 + 1));\n    printf(\" %s\", str);\n}"
  },
  {
    "answer" : "#include\"iostream\"\n#include\"math.h\"\n#define MAX 100\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    int N;\n    double D[MAX],sum=0,SumD[MAX];\n    cin>>N;\n    for(int i=0;i<N;i++)\n    {\n        cin>>D[i];\n        sum+=D[i];\n        SumD[i] = sum;\n    }\n    while(true)\n    {\n        int a,b;\n        cin>>a>>b;\n        if(a>N||b>N)\n            break;\n        float temp = fabs(SumD[a-1]-SumD[b-1]);\n        cout<<\"result: \"<<(temp>(sum-temp)?(sum-temp):temp)<<endl;\n    }\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a6114337c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "某环形公路上有N个站点，分别记为A1......An，从Ai到A（ i+1）的距离为Di。An到A1的距离为Do，假设Do=Dn=1，保存在数组D（N）中，现在要求你与一个函数，能够高效的计算出公路上任意两点的最近距离，要求空间复杂度不能超过O(N)。\n\nconst int N=100;\ndouble D(N);\n...\nVoid preprocess(){\n\/\/Write your code here,        (1)\n}\ndouble Distance(int i, int j){\n\/\/ Write your code bere         (2)\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143264",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1",
    "optionC" : "0.5",
    "optionAnswer" : "C",
    "answer" : "本题重点考査if语句,变量x和y均为double类型,由于变量x赋值为2.0,因此执行if((x<5.0)&&(! x)),即条件为0,继续执行if(x<10.0),条件为1,即执行y=1.0\/x;。依据printf ()函数输出类型中f是以小数形式输出单、双精度实数。因此C选项正确。",
    "optionB" : "0.25",
    "type" : "1",
    "optionA" : "0",
    "question" : "有以下程序\n\n#include <stdio.h > \nmain()\n{ \n    double x=2.0,y;\n    if(x<0.0)y=0.0;\n    else if((x<5.0)&&(! x)) y=1.0\/(x+2.0);\n    if(x<10.0)y=1.0\/x;\n    else if y=10.0;\n    printf(\"％f\\n\",y);\n}\n程序运行后的输出结果是"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143261",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "编译不通过",
    "optionAnswer" : "B",
    "answer" : "因为strlen() = 3, strlen(b) = 3;",
    "optionB" : "a<=b",
    "type" : "1",
    "optionA" : "a>b",
    "question" : "有如下程序段：\n\nchar a[] = \"xyz\", b[] = {'x', 'y', 'z'};\nif (strlen(a) > strlen(b))\n    printf(\"a > b\\n\");\nelse\n    printf(\"a <= b\\n\");\n\n则程序输出："
  },
  {
    "ID" : "55f2e469e4b0152a6114312c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "abddcccd",
    "optionC" : "abcc",
    "optionAnswer" : "D",
    "answer" : "函数中在??return?str;前面加一句*it1 = '\\0'；这样输出就是abdd，没有这句就是abddcccd。",
    "optionB" : "abdd",
    "type" : "1",
    "optionA" : "abdcccd",
    "question" : "What is the result of the following program?\n\nchar *f(char *str , char ch)\n{\n    char *it1 = str;\n    char *it2 = str;\n    while(*it2 != '\\0')\n    {\n        while(*it2 == ch)\n        {\n            it2++;\n        }\n        *it1++ = *it2++;\n     }\n     return str;\n}\n \nint main(void)\n{\nchar *a = new char[10];\nstrcpy(a , \"abcdcccd\");\ncout<<f(a, 'c');\nreturn 0;\n}"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c75",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "使用成员名限定或赋值兼容规则",
    "optionC" : "使用作用域分辨运算符或虚基类",
    "optionAnswer" : "B",
    "answer" : "解决二义性问题主要要两种方法：(1)赋值兼容规则；(2)虚基类。",
    "optionB" : "使用作用域分辨运算符或成员名限定",
    "type" : "1",
    "optionA" : "只能使用作用域分辨运算符",
    "question" : "解决定义二义性问题的方法有（）"
  },
  {
    "ID" : "55f2e469e4b0152a61143135",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int i=0;printf(“%d%d\\n”,i++,i--);",
    "optionC" : "char *p=”hello”;char ch=*p++;",
    "optionAnswer" : "C",
    "answer" : "应该选C吧。其他都是未定义行为。\nA，D：表达式的先后顺序，是由编译器决定的，有可能不同\nB：常量字符串不能修改，指针改为数组可以。",
    "optionB" : "char *p=”hello”;p[1]=’E’;",
    "type" : "1",
    "optionA" : "Int i=0;i=(i++);",
    "question" : "下列 C 代码中，不属于未定义行为的有___"
  },
  {
    "answer" : "在处理消息事件的时候，对WM_GETTEXT和EM_GETLINE事件进行过滤",
    "ID" : "55f2e51de4b0152a6114334b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "对于Edit控件，你如何抓防止密码框内容被抓取？"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f6",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "float",
    "optionC" : "char",
    "optionAnswer" : "D",
    "answer" : "switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型",
    "optionB" : "long",
    "type" : "1",
    "optionA" : "int",
    "question" : "switch(c)语句中，c不可以是什么类型（）"
  },
  {
    "answer" : "import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] left,right;\n        String[] line;\n        String nextLine,outString;\n        while(sc.hasNext()){\n            nextLine = sc.nextLine();\n            \/\/有王炸就王炸最大\n            if(nextLine.contains(\"joker JOKER\")){\n                outString = \"joker JOKER\";\n            }else{\n                \/\/拆分 先拆成左右 再拆成单排\n                line = nextLine.split(\"-\");\n                left = line[0].split(\" \");\n                right = line[1].split(\" \");\n                 \n                \/\/炸弹最大\n                if(left.length == 4 && right.length != 4){\n                    outString = line[0];\n                }else if(right.length == 4 && left.length != 4){\n                    outString = line[1];\n                }\n                \/\/ 牌数相同的情况下比较最小的牌的大小，compare方法返回牌所对应的值\n                else if(right.length == left.length){              \n                    if(count(left[0])>count(right[0])){\n                        outString = line[0];\n                    }\n                    else{\n                        outString = line[1];\n                    }      \n                }else{\n                    outString = \"ERROR\";\n                }\n            }\n             \n            System.out.println(outString);\n \n        }\n    }\n \n    \/\/2-JOKER 按大小返回2-16\n    private static int count(String str) {\n        return \"345678910JQKA2jokerJOKER\".indexOf(str);}}",
    "ID" : "55f2e51ce4b0152a61143326",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:) \n3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER \n输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER\n请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR\n\n基本规则：\n（1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；\n（2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）\n（3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；\n（4）输入的两手牌不会出现相等的情况。\n\n答案提示：\n（1）除了炸弹和对王之外，其他必须同类型比较。\n（2）输入已经保证合法性，不用检查输入是否是合法的牌。\n（3）输入的顺子已经经过从小到大排序，因此不用再排序了."
  },
  {
    "ID" : "55f2e4fee4b0152a61143214",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "和具体机器配置相关",
    "optionC" : "一样",
    "optionAnswer" : "B",
    "answer" : "_beginthreadex()比较于?CreateThread()有更高的线程安全性，不会造成多个线程共用同一个全局变量的情况",
    "optionB" : "_beginthreadex",
    "type" : "1",
    "optionA" : "CreateThread",
    "question" : "如果要实现一个多线程(非MFC)程序, 选择多线程CRT, 创建线程的时候应该用CreateThread还是_beginthreadex()？"
  },
  {
    "answer" : "答：typedef char *String_t 定义了一个新的类型别名，有类型检查。而#define String_d char * 只是做了\n个简单的替换，无类型检查，前者在编译的时候处理，后者在预编译的时候处理。\n同时定义多个变量的时候有区别，主要区别在于这种使用方式String_t a,b; String_d c,d; a,b ,c 都是\nchar*类型，而d 为char 类型\n由于typedef 还要做类型检查。。#define 没有。。所以typedef 比#define 安全。。",
    "ID" : "55f2e51ee4b0152a611433e0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "typedef char *String_t; 和#define String_d char * 这两句在使用上有什么区别？"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c1a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "另一个类的对象",
    "optionC" : "自身类对象的引用",
    "optionAnswer" : "B",
    "answer" : "类的定义，如果有自身类对象，使得循环定义，B项错误。在类中具有自身类的指针，可\n以实现链表的操作，当然也可以使用对象的引用。类中可以有另一个类的对象，即成员对象。所\n以选择B选项。",
    "optionB" : "自身类对象",
    "type" : "1",
    "optionA" : "自身类对象的指针",
    "question" : "下列不能作为类的成员的是（）"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143269",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "6385",
    "optionC" : "6982",
    "optionAnswer" : "D",
    "answer" : "本题中首先是将二维字符数组c赋值指针数组p,然后遍历p找到两个字符串中的偶数位置的字符并组成一个数值输出,根据代码执行即可得到结果为6385",
    "optionB" : "9824",
    "type" : "1",
    "optionA" : "9284",
    "question" : "有以下程序\n\n#include<iostream>\nusing namespace std;\nint main ( )\n{\n    char c [2][5] = { \"6938\" , \"8254\" }, * p [2] ;\n    int s=0;\n    for (int  i =0 ; i < 2 ; i ++ )\n        p [i] = c [i] ;\n    for (int i = 0,j=0; i <4; i++,j+=2)\n    {   if (j>3)\n        {\n            j=0;\n        }\n        s = 10 * s + (p [i\/2] [j]-'0');\n    }\n    cout<<s<<endl;\n    return 0;\n}\n程序运行后的输出结果是？"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c08",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "保护成员或私有成员",
    "optionC" : "保护成员",
    "optionAnswer" : "A",
    "answer" : "在派生类中基类的保护或者基类公有都可以直接访问，基类的私有成员只能是基类\n的成员函数来访问。所以选择A项。",
    "optionB" : "公有成员",
    "type" : "1",
    "optionA" : "私有成员",
    "question" : "在公有派生类的成员函数不能直接访问基类中继承来的某个成员，则该成员一定是基类中\n的（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7fa",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "vector;",
    "optionC" : "list;",
    "optionAnswer" : "D",
    "answer" : "vector是STL中最常见的容器，它是一种顺序容器，支持随机访问。vector是一块连续分配的内存，从数据安排的角度来讲，和数组极其相似，不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。vector的扩充机制：按照容器现在容量的一倍进行增长。vector容器分配的是一块连续的内存空间，每次容器的增长，并不是在原有连续的内存空间后再进行简单的叠加，而是重新申请一块更大的新内存，并把现有容器中的元素逐个复制过去，然后销毁旧的内存。这时原有指向旧内存空间的迭代器已经失效，所以当操作容器时，迭代器要及时更新。",
    "optionB" : "set;",
    "type" : "1",
    "optionA" : "map；",
    "question" : "STL中的哪种结构在增加成员时可能会引起原有成员的存储位置发生："
  },
  {
    "answer" : "你的第一感觉或许是，公司应该雇用 100 多人，或者 200 多人吧。答案或许会让你大吃一惊：公司应该雇用 365 个人。注意，雇用 365 个人并不意味着全体员工全年的总工作时间为 0 ，因为 365 个人的生日都是随机的，恰好每天都有一个人过生日的概率极小极小。下面我们就来证明，这个问题的最优解就是 365 人。\n由于期望值满足线性关系（即对于随机变量 X 和 Y 有 E(X) + E(Y) = E(X+Y) ），因此我们只需要让每一天员工总工作时间的期望值最大就可以了。假设公司里有 n 个人，那么在特定的一天里，没有人过生日的概率是 (364\/365)n 。因此，这一天的期望总工作时间就是 n · (364\/365)n 个工作日。为了考察函数 n · (364\/365)n 的增减性，我们来看一下 ((n+1) · (364\/365)n+1) \/ (n · (364\/365)n) 的值，它等于 (364 · (n+1)) \/ (365 · n) 。如果分子比分母小，解得 n > 364 。可见，要到 n = 365 以后，函数才是递减的。\n答案：365",
    "ID" : "55f2e51de4b0152a6114336c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "某公司有这么一个规定：只要有一个员工过生日，当天所有员工全部放假一天。但在其余时候，所有员工都没有假期，必须正常上班。假设一年有365天，每个员工的生日都概率均等地分布在这365天里。那么，这个公司需要雇用多少员工，才能让公司一年内所有员工的总工作时间期望值最大？"
  },
  {
    "ID" : "55f2e4fee4b0152a6114322f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "出错",
    "optionC" : "xy123ABC",
    "optionAnswer" : "D",
    "answer" : "strcat(p1,p2)出错，因为p1只被分配了4个字节的地址空间，将p2拼接在p1后面会引起内存溢出。",
    "optionB" : "z123ABC",
    "type" : "1",
    "optionA" : "xyz123ABC",
    "question" : "下面程序的输出结果是\n\nchar *p1= “123”, *p2 = “ABC”, str［50］= \"xyz\";\nstrcpy（str+2,strcat（p1,p2））;\ncout << str;"
  },
  {
    "ID" : "55e6d85be4b0152a610de81a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Java使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作",
    "optionC" : "finally在异常处理时提供 finally 块来执行任何清除操作。",
    "optionAnswer" : "B",
    "answer" : "final修饰的方法不能被覆盖\nfinal修饰的字段为常量\nfinal修饰的类不能被继承",
    "optionB" : "如果一个方法被声明为final，可以被覆盖",
    "type" : "1",
    "optionA" : "如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承",
    "question" : "下面有关final, finally, finalize的区别描述错误的是？"
  },
  {
    "ID" : "55e6d85be4b0152a610de819",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "一般来讲在 32 位系统下，堆内存可以达到4G的空间，但是对于栈来讲，一般都是有一定的空间大小的。",
    "optionC" : "对于堆来讲，频繁的 new\/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题",
    "optionAnswer" : "B",
    "answer" : "堆的生长方向，是向上的，也就是内存地址增加的方向；栈的生长方向是向下的，也就是内存地址减小的方向",
    "optionB" : "对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。",
    "type" : "1",
    "optionA" : "对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制",
    "question" : "下面有关c++内存分配堆栈说法错误的是？"
  },
  {
    "answer" : "题目不难，注意是每个台阶最多能跳阶，也可以少于，用贪心算法，维护一个变量max用于存储还能跳多少台阶，然后遍历一遍数组，也就是依次模拟跳一个台阶，跳一次max-1，如果当前台阶所允许的最大步数大于max，就让max等于该数。如果max等于0返回false\n\ndef canJump(self, nums):\n        maxStep=nums[0]\n        for i in range(1,len(nums)):\n            if maxStep==0:\n                return False\n            maxStep-=1\n            if maxStep<nums[i]:\n                maxStep=nums[i]\n        return True",
    "ID" : "55f2e51de4b0152a6114335a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一排台阶，每个台阶上有一个非负整数，代表在该台阶上时能最多向前跳几个台阶。从第0个台阶开始跳，实现一个函数，判断是否能到达最后一个台阶。\n例如： 4 2 2 1 0 2 返回 false\n            2 1 3 1 1 0 返回 true\nbool jump(int array[], int size)\n{                 \n}"
  },
  {
    "ID" : "55e6d85be4b0152a610de81d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "k ＝ i - s",
    "optionC" : "﹡k ＝ i - s",
    "optionAnswer" : "A",
    "answer" : "fun函数的功能是求数组中最大值所在元素的下标。通过for循环语句,每次将最大的数给﹡k ,即﹡k ＝ i。因此A选项正确。",
    "optionB" : "k ＝ i",
    "type" : "1",
    "optionA" : "﹡k ＝ i",
    "question" : "以下程序调用fun函数求数组中最大值所在元素的下标。\n#include <stdio.h>\nvoid fun ( int ﹡s,int n,int ﹡k )\n{\n    int i;\n    for ( i ＝ 0 ,﹡k ＝ i;i < n;i + + )\n    if( s [i] > s [﹡k] )   \n        ________ ;\n}\nmain ( )\n{\n    int a [5] ＝ ｛1,6,2,8,0｝ , k;\n    fun ( a,5,&k );\n    printf (\"%d %d＼n\",k,a [k] );\n}\n在横线处应填入的内容是?"
  },
  {
    "ID" : "55e6d85be4b0152a610de816",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "4",
    "optionC" : "3",
    "optionAnswer" : "D",
    "answer" : "&a是数组指针，其类型为int(*)[4]; \n而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同，a是长度为4的int数组指针，所以要加5*sizeof(int)，所以ptr实际是a[4],但是ptr与（&a+1）类型是不一样的，这点非常重要，所以ptr-1只会减去sizeof(int*),a，&a的地址是一样的，但意思就不一样了，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[4]",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "question" : "下面代码会输出什么（）int main(int argc, char **argv)\n{\n    int a[4] = {1, 2, 3, 4};\n    int *ptr = (int *)(&a + 1);\n    printf(\"%d\", *(ptr - 1));\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114325f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "x数组与y数组等价",
    "optionC" : "x数组的长度小于y数组的长度",
    "optionAnswer" : "A",
    "answer" : "对于 static char x [ ]= \"abcde\" ;而言，长度为6，因为 \"abcde\" 是字符串，末尾默认有'\\0'结束符，长度为6。\n对于 static char y [ ]={ 'a' , 'b' , 'c' , 'd' , 'e' };而言，是将每个字符逐一赋值到y[]中，所以长度为5。\n所以，答案为A    x数组的长度大于y数组的长度",
    "optionB" : "x数组和y数组的长度相同",
    "type" : "1",
    "optionA" : "x数组的长度大于y数组的长度",
    "question" : "有定义如下：\nstatic char x[ ]= \"abcde\";\nstatic char y[ ]={ 'a', 'b', 'c', 'd', 'e'};\n则正确的说法是？"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "16 20",
    "optionC" : "16 24",
    "optionAnswer" : "C",
    "answer" : "根据以下条件进行计算：\n1、  结构体的大小等于结构体内最大成员大小的整数倍\n2、  结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的地址偏移量应该是8的倍数。\n3、  为了满足规则1和2编译器会在结构体成员之后进行字节填充！\n\nA中，a占4个字节，b本应占2个字节，但由于c占4个字节，为了满足条件2，b多占用2个字节，为了满足条件1，d占用4个字节，一共16个字节。\nB中，a占8个字节，b占2个字节，但由于c占4个字节，为了满足条件2，b多占用2个字节，\n即abc共占用8+4+4=16个字节，\n为了满足条件1，d将占用8个字节，一共24个字节。\n",
    "optionB" : "12 12",
    "type" : "1",
    "optionA" : "12 16",
    "question" : "class A\n{\n        int a;\n        short b;\n        int c;\n        char d;\n};\nclass B\n{\n        double a;\n        short b;\n        int c;\n        char d;\n};\n\n在32位机器上用gcc编译以上代码，求sizeof(A),sizeof(B)分别是多少。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143248",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "hite",
    "optionC" : "white",
    "optionAnswer" : "A",
    "answer" : "因为++p后，p指向violet中的i，**p是指向数组中字符串的指针，**p+1后指向下一个字符串（pink）的第二个字符。打印出来就是ink",
    "optionB" : "pink",
    "type" : "1",
    "optionA" : "ink",
    "question" : "下述程序的输出是______。\n\n#include<stdio.h>\n \nint main()\n{\n    static char *s[] = {\"black\", \"white\", \"pink\", \"violet\"};\n    char **ptr[] = {s+3, s+2, s+1, s}, ***p;\n    p = ptr;\n    ++p;\n    printf(\"%s\", **p+1);\n    return 0;\n}"
  },
  {
    "answer" : "解题思路：\n1、使用单例模式。定义一个sequenceGenerator单例类， 声明一个getSequence方法，将sequence序号依次相加 。\n\n2、产生 ID 的规则是：将 ID设置为字符串。ID =  当前日期+整型sequence。\n\n伪代码：\n\npublic class SequenceGenerator {\n\nprivate SequenceGenerator generatorInstance = null;\n\nprivate long sequence = 0;\n\nprivate SequenceGenerator (){}\n\npublic static SequenceGenerator getInstance(){\n\n   if(generatorInstance == null){\n      synchoronized(this){\n       generatorInstance  = new SequenceGenerator ();\n   }\n   return generatorInstance  ;\n }\n}\n\npublic synchronized int getSequence(){\n      if(++sequence没有超过long型的最大值）return sequence；\n    \n}\n}",
    "ID" : "55f2e51de4b0152a61143356",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "一般在大型系统中，都会为每个资源分配一个唯一的ID，在大型系统中这个并非易事，目前人人网一天产生新鲜事在千万量级，现在由你来设计一个产生新鲜事ID的模块。要求写出解题思路和伪代码。\n拿分法宝：\n1） 新鲜事ID绝对不能重复\n2）你可以借助DB等辅助工具，提供InsertDB， UpdateDB， QueryDB三API供你使用， 假设访问DB不会有异常。\n3)  高并发情况要考虑， 提供Lock, Unlock两个API供你使用。\n4） 要求写出解题思路和伪代码出来。"
  },
  {
    "answer" : "1.所有的query结果都放在硬盘\n2.所有query到query结果的映射存储在内存\n3.多余内存作为缓存,缓存淘汰机制为查询次数和LRU",
    "ID" : "55f2e51ee4b0152a611433de",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "百度的某服务机制类似于 CS（customer-server），有时候大量用户访问服务器 S， 导致 S 运行效率缓慢。 为了提升效率， 拟在 C 上利用一些空余的结果空间作为缓存。 已知在 C 的一台客户机上，每天接收 1000w query，其中 500w uniq query，每个 query 5KB，客户机内存 3GB，硬盘 500GB。做出一个方案，说明系统结构、存储结 构、性能优化等方面的设计。"
  },
  {
    "answer" : "import java.util.ArrayList;\npublic class Test {\n    public static ArrayList<String> getSolution(int n) {\n        ArrayList<String> list = new ArrayList<String>();\n        list = recurse(n, 0, 2);\n        return list;\n    }\n    public static ArrayList<String> recurse(int n, int from, int to) {\n        ArrayList<String> list = new ArrayList<String>();\n        \/\/如果只有一个圆盘\n        if(n == 1) {\n            if(from == 0 && to == 1) {\n                list.add(\"move left to mid\");\n            } else if(from == 0 && to == 2) {\n                list.add(\"move left to right\");\n            } else if(from == 1 && to == 0) {\n                list.add(\"move mid to left\");\n            } else if(from == 1 && to == 2) {\n                list.add(\"move mid to right\");\n            } else if(from == 2 && to == 0) {\n                list.add(\"move right to left\");\n            } else if(from == 2 && to == 1) {\n                list.add(\"move right to mid\");\n            }\n        } else {\n            if(from == 0 && to == 1) {\n                \/\/先将n-1个圆盘从左边搬到右边\n                list.addAll(recurse(n - 1, 0, 2));\n                \/\/再将最底层的圆盘从左边搬到中间\n                list.add(\"move left to mid\");\n                \/\/最后将n-1个圆盘从右边搬到中间\n                list.addAll(recurse(n - 1, 2, 1));\n            } else if(from == 0 && to == 2) {\n                \/\/先将n-1个圆盘从左边搬到中间\n                list.addAll(recurse(n - 1, 0, 1));\n                \/\/再将最底层的圆盘从左边搬到右边\n                list.add(\"move left to right\");\n                \/\/最后将n-1个圆盘从中间搬到右边\n                list.addAll(recurse(n - 1, 1, 2));\n            } else if(from == 1 && to == 0) {\n                \/\/先将n-1个圆盘从中间搬到右边\n                list.addAll(recurse(n - 1, 1, 2));\n                \/\/再将最底层的圆盘从中间搬到左边\n                list.add(\"move mid to left\");\n                \/\/最后将n-1个圆盘从右边搬到左边\n                list.addAll(recurse(n - 1, 2, 0));\n            } else if(from == 1 && to == 2) {\n                \/\/先将n-1个圆盘从中间搬到左边\n                list.addAll(recurse(n - 1, 1, 0));\n         ",
    "ID" : "55f2e51ce4b0152a6114332c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "对于传统的汉诺塔游戏我们做一个拓展，我们有从大到小放置的n个圆盘，开始时所有圆盘都放在左边的柱子上，按照汉诺塔游戏的要求我们要把所有的圆盘都移到右边的柱子上，请实现一个函数打印最优移动轨迹。\n给定一个int n，表示有n个圆盘。请返回一个string数组，其中的元素依次为每次移动的描述。描述格式为： move from [left\/mid\/right] to [left\/mid\/right]。\n测试样例： 输入： 1   返回：move from left to right"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c67",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "C++中不管＃if后的常量表达式是否为真，该部分都需要编译",
    "optionC" : "C++的编译指令可以以#或\/\/开始",
    "optionAnswer" : "B",
    "answer" : "编译指令以＃作为开头，只能一行写一条，＃if有选择进行编译，所以选择B项。",
    "optionB" : "#include指令中的文件名可含有路径信息",
    "type" : "1",
    "optionA" : "C++每行可以写多条编译指令",
    "question" : "有关C++编译指令，以下叙述正确的是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143237",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "map的删除操作只会导致指向被删除元素的迭代器失效",
    "optionC" : "vector的删除操作只会导致指向被删除元素及后面的迭代器失效",
    "optionAnswer" : "A",
    "answer" : "因为由 Vector 的 iterator 和 listIterator 方法所返回的迭代器是快速失败的 ：如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。",
    "optionB" : "map的插入操作不会导致迭代器失效",
    "type" : "1",
    "optionA" : "vector的插入操作不会导致迭代器失效",
    "question" : "下面关于迭代器失效的描述哪个是错误的（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143245",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "友元函数是有关键字friend修饰，调用的时候也是通过指针this调用的",
    "optionC" : "类的成员函数是属于类的，调用的时候是通过指针this调用的",
    "optionAnswer" : "D",
    "answer" : "类的友元函数的访问权限跟类内部的方法相同，但是友元函数不属于本类的对象，一般它是另一个类的成员函数，不能通过本类的this指针进行访问。",
    "optionB" : "友元函数和类的成员函数都可以访问类的私有成员变量或者是成员函数",
    "type" : "1",
    "optionA" : "友元函数可以让本类和友元类对象调用",
    "question" : "下面有关友元函数与成员函数的区别，描述错误的是？"
  },
  {
    "answer" : "这个问题需要再加一个条件：n为偶数，应为如果n为偶数，先拿的必胜，如果n为奇数，那么先拿的必输。\n  思路：假设n为偶数，那么先拿的可以决定后拿每次拿的硬币在原硬币位置中下标为奇数或者为偶数，那么先拿的可以比较硬币在奇数位置的面额之和 和 偶数位置的面额之和，从而使得自己每次拿奇数还是偶数。",
    "ID" : "55f2e51ce4b0152a61143339",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有n枚硬币按照0到n-1对它们进行编号，其中编号为i的硬币面额为vi，两个人轮流从剩下硬币中取出一枚硬币归自己所有，但每次取硬币的时候只能取剩下的硬币中编号最小的硬币或者编号最大的硬币，在两个都采用最优策略的情况下，作为先取硬币的你请编写程序计算出你能获得硬币总面额的最大值？（请简述算法原理，时间复杂度并实现具体的程序），语言不限。int MaxValue(int v[],int n){\n}"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c8a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "virtual void fun(){};",
    "optionC" : "virtual void fun();",
    "optionAnswer" : "B",
    "answer" : "A是错误的写法；B是纯虚函数；C是虚函数的声明；D是虚函数的定义。",
    "optionB" : "virtual void fun()=0;",
    "type" : "1",
    "optionA" : "void fun()=0;",
    "question" : "下面函数原型声明中，（  ）声明了fun为纯虚函数"
  },
  {
    "ID" : "55f2e46ae4b0152a6114314f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数指针数组，每个指针指向一个int func(int param)的函数。",
    "optionC" : "函数指针数组，每个指针指向一个int func(int* param)的函数。",
    "optionAnswer" : "D",
    "answer" : "1、首先*s[10]  是一个指针数组，s 是一个含有10个指针的数组，故可以这样来看这条声明语句：假设 p 等价于 s[10],声明语句变为 int (*p)(int);\n2、观察 int (*p)(int), 从名字开始，p前面有一个 * ，因此 p 是指针，有侧是形参列表，表示p指向的是函数，在观察左侧，函数返回的是 int；\n3、则 int (*p)(int) 解读为：函数指针，指向一个 int func(int param) 的函数；\n4、故 int (*s[10])(int) :解读为：函数指针数组，每个指针指向一个 int func(int param)的函数。",
    "optionB" : "指针数组，每个指针指向长度为10的int数组",
    "type" : "1",
    "optionA" : "指针数组，每个指针指向长度为1的int数组",
    "question" : "int (*s[10])(int) 表示的是什么？"
  },
  {
    "answer" : "先求每个子树的最大值和最小值,递归实现。",
    "ID" : "55f2e51de4b0152a61143386",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "写一个函数,输入一个二叉树,树中每个节点存放了一个整数值,函数返回这棵二叉树中相差最大的两个节点间的差值绝对值。请注意程序效率。"
  },
  {
    "answer" : "C++语言: 电话号码对应的英语单词(注意此题的非递归做法)\n\n#include#include#define N 4 \/\/电话号码个数 \n  \nusing namespace std;\n  \nchar c[][10] = {\"\",\"\",\"ABC\",\"DEF\",\"GHI\",\"JKL\",\"MNO\",\"PQRS\",\"TUV\",\"WXYZ\"};\/\/存储各个数字所能代表的字符 \nint number[N] = {2, 4 ,7, 9}; \/\/存储电话号码 \nint total[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4}; \/\/各个数组所能代表的字符总数 \nint answer[N]; \/\/数字目前所代表的字符在其所能代表的字符集中的位置,初始为0 \n  \nvoid Search(int *number, int n); \/\/非递归的办法 \nvoid RecursiveSearch(int *number, int cur, char *ps, int n); \/\/递归的办法\nint main()\n{\n        \/\/Search(number, N); \n        char ps[N+1] = {0};\n        RecursiveSearch(number, 0, ps, N);\n        return 0;\n}\n  \n  \nvoid Search(int *number, int n)\n{\n        int i;\n        while(1)\n        {\n                for(i=0; i<n; ++i)=\"\" printf(\"%c\",=\"\" c[number[i]][answer[i]]);=\"\" printf(\"\\n\");=\"\" int=\"\" k=\"n-1;\" 用k和while循环来解决扩展性问题,模拟了递归=\"\" while(k=\"\">= 0)\n                {\n<\/n;>\n \n    <n; ++i)=\"\" printf(\"%c\",=\"\" c[number[i]][answer[i]]);=\"\" printf(\"\\n\");=\"\" int=\"\" k=\"n-1;\" 用k和while循环来解决扩展性问题,模拟了递归=\"\" while(k=\"\">                        if(answer[k] < total[number[k]]-1) { ++answer[k]; break; } else { answer[k] = 0; --k; } } if(k < 0) break; } } \/*递归的解法: number为存储电话号码的数组,pos为当前处理的数字在number中的下标,初始为0 *ps为一外部数组,用于存放字母,n代表电话号码的长度(个数) * 此递归的方法好理解,比上面非递归的办法好写易懂 * *\/ <\/n;>\n \n    <n; ++i)=\"\" printf(\"%c\",=\"\" c[number[i]][answer[i]]);=\"\" printf(\"\\n\");=\"\" int=\"\" k=\"n-1;\" 用k和while循环来解决扩展性问题,模拟了递归=\"\" while(k=\"\">\n<\/n;>\nvoid RecursiveSearch(int *number, int pos, char *ps, int n)\n{\n        int i;\n        for(i=0; i<total[number[pos]]; ++i)\n        {\n                ps[pos] = c[number[pos]][i];\n                if(pos == n-1)\n                        cout<<ps<<endl;\n                else\n                        RecursiveSearch(number, pos+1, ps, n);\n        }\n}",
    "ID" : "55f2e51de4b0152a6114336a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "现在有一个手机，手机上的键盘上有这样的对应关系，2对应\"abc\",3对应\"def\".....手机里面有一个userlist用户列表，当我们输入942的时候出来拼音的对应可能是“xia”，“zha”，“xi”，“yi”等，当我们输入9264的时候出来是yang，可能是“样”，“杨”，“往”等，现在我们输入一个字符串数字，比如926等，要在电话簿userlist中查找出对应的用户名和电话号码并返回结果。 C++语言: 电话号码对应的英语单词(注意此题的非递归做法)"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "exponential",
    "optionC" : "quadratic",
    "optionAnswer" : "A",
    "answer" : "因为e是不断地除以2，所以调用次数应该是以2为底的对数！",
    "optionB" : "linear",
    "type" : "1",
    "optionA" : "logarithmic",
    "question" : "Consider the following definition of a recursive function, power, that will perform exponentiation.int power(int b, int e) {\n    if (e == 0)\n        return 1;\n    if (e %2 == 0)\n        return power (b * b, e \/ 2);\n    return b * power(b * b, e \/ 2);\n}\nAsymptotically (渐进地) in terms of the exponent e, the number of calls to power that occur as a result of the call power(b, e) is"
  },
  {
    "ID" : "55f2e46ae4b0152a61143165",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "在这段代码之外写一段代码，调用该代码的一些模块，完成新功能需求",
    "optionC" : "修改老代码的内部逻辑，满足新的需求",
    "optionAnswer" : "D",
    "answer" : "A：对原有代码影响太大，接口改了，要重构所有涉及的代码，风险太大；\nB：貌似可以。题意“在需要利用其实现一个新的需求”\nC： 修改后的测试工作量太大，如果测试不全，隐患很多\nD：这个比较合适，不会影响原有代码逻辑，可以利用当前已有的代码模块。",
    "optionB" : "将老代码抛弃，自己重新实现类似的逻辑",
    "type" : "1",
    "optionA" : "修改老代码的接口，满足新的需求",
    "question" : "有一段年代久远的C++代码，内部逻辑复杂，现在需要利用其实现一个新的需求，假定有以下可行的方案，应当优先选择"
  },
  {
    "ID" : "55f2e4fee4b0152a61143240",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "new和malloc都可用于申请动态内存，new是一个操作符，malloc是是一个函数",
    "optionC" : "new和malloc都是保留字，不需要头文件支持",
    "optionAnswer" : "C",
    "answer" : "new\/delete都是要分两步操作的：new分配内存，并且调用对象的构造函数初始化一个对象；delete调用相应的析构函数，然后释放内存\nmalloc\/free只是分配内存\/回收内存， 所以A、B对；\nmalloc需要头文件\"stdlib.h\"或者\"malloc.h\" C错；\nnew\/delete都是内建的操作符，而malloc是一个函数，其函数原型是：\nvoid *malloc(unsigned int num_bytes);\n所以选C",
    "optionB" : "new   初始化对象，调用对象的构造函数，对应的delete调用相应的析构函数，malloc仅仅分配内存，free仅仅回收内存",
    "type" : "1",
    "optionA" : "new 建立的是一个对象， malloc分配的是一块内存.",
    "question" : "下面有关malloc和new，说法错误的是？?"
  },
  {
    "ID" : "55e6d85be4b0152a610de823",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "4 6",
    "optionC" : "6 5",
    "optionAnswer" : "D",
    "answer" : "本题主要考查了指向字符串的指针和字符数组,strl为一个字符指针,所以sizeof为4,str2为字符数组,其中包含6个字符,所以答案为4 6",
    "optionB" : "5 5",
    "type" : "1",
    "optionA" : "5 6",
    "question" : "在32位编译器上,设有定义\nchar * strl = \"Hello\",str2[ ] = \"Hello\";\n则以下语句\nprintf(\"%d %d\",sizeof(str),sizeof(str2));\n的输出结果是"
  },
  {
    "answer" : "1. 指针是一个实体，而引用仅是个别名；\n2. 引用使用时无需解引用(*)，指针需要解引用；\n3. 引用只能在定义时被初始化一次，之后不可变；指针可变；\n4. 引用没有 const，指针有 const；\n5. 引用不能为空，指针可以为空；\n6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；\n7. 指针和引用的自增(++)运算意义不一样；\n8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。",
    "ID" : "55f2e51ee4b0152a611433cd",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "引用与指针有什么区别？"
  },
  {
    "answer" : "extern “C”\nC++语言为了支持重构（重构的特征?：相同的范围、相同的名字、不同的参数），在编译时对函数的命名方式进行了改变，编译后的名字包括一些参数的信息。extern \"C\"的作用，就是“提示”编译器，下面的文件和函数，要用C语言的命名规则进行。",
    "ID" : "55f2e51ce4b0152a61143334",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "C++调用C语言库时，需要加()"
  },
  {
    "answer" : "(1)首先一千万条查询记录，每条字符串长0~255，而限制内存&lt; 1G，所以不能把一千万条记录全部放进内存中处理，经计算，1千万条记录的大小为256Byte*10^8=0.25KB * 10^8=2.5*10^7KB，而1G = 1024M = 1024*1024KB = 1.024*1.024*10^6KB，所以我将1千万条记录分成25次读取，每次读取40万条记录，使用哈希表来计算出40万条记录重复次数最大的前10条记录，哈希表的key是记录字符串，值是重复次数。这样25次访问完1千万条记录，将会得到250条记录，然后使用Map存储这250条记录，key是重复次数，值是记录字符串，比较函数是greater函数对象，从大到小存储在Map中，前10条即是最热门的10条查询串。 <\/div> <div> (2)复杂度分析：N + klogk < O(N)",
    "ID" : "55f2e51ee4b0152a611433c7",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "搜索引擎的日志要记录所有查询串,有一千万条查询,不重复的不超过三百万\n要统计最热门的10条查询串. 内存<1G. 字符串长 0-255\n(1) 主要解决思路\n(2) 算法及其复杂度分析"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c84",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "动态联编是在编译时确定操作函数的 ",
    "optionC" : "动态联编调用函数操作是指向对象的指针或对象引用      ",
    "optionAnswer" : "D",
    "answer" : "动态联编是在运行时确定操作函数的，主要体现在继承里指向基类对象的指针或者引用指向派生类对象。",
    "optionB" : "动态联编是在运行时确定所调用的函数代码的",
    "type" : "1",
    "optionA" : "动态联编是以虚函数为基础的    ",
    "question" : "关于动态联编的下列描述中，（）是错误的"
  },
  {
    "answer" : "501",
    "ID" : "55f2e51de4b0152a6114335d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : " 2014! 的末尾有___个0"
  },
  {
    "answer" : "#include <utility>\n#include <string.h>\nclassString\n{\npublic:\n    String():data_(newchar[1])\n    {\n        *data_ = '\\0';\n    }\n    String(const char * str):data_(newchar[strlen(str) + 1])\n    {\n        strcpy(data_, str);\n    }\n    String(const String & rhs)\n        : data_(newchar[rhs.size() + 1])\n    {\n        strcpy(data_, rhs.c_str());\n    }\n    \/* Delegate constructor in C++11\n    String(const String& rhs):String(rhs.data_)\n    {\n    }\n    *\/\n    ~String()\n    {\n        delete[] data_;\n    }\n    \/* Traditional:\n    String& operator=(const String& rhs)\n    {\n        String tmp(rhs);\n        swap(tmp);\n        return *this;\n    }\n    *\/\n    String &operator=(String rhs)\/\/ yes, pass-by-value\n    {\n        swap(rhs);\n        return*this;\n    }\n    \/\/ C++ 11\n    String(String &&rhs): data_(rhs.data_)\n    {\n        rhs.data_ = nullptr;\n    }\n    String &operator=(String && rhs)\n    {\n        swap(rhs);\n        return*this;\n    }\n    \/\/ Accessors\n    size_t size() const\n    {\n        return strlen(data_);\n    }\n    const char * c_str() const\n    {\n        return data_;\n    }\n    void swap(String & rhs)\n    {\n        std::swap(data_, rhs.data_);\n    }\nprivate:\n    char *data_;\n};",
    "ID" : "55f2e51de4b0152a61143379",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请用c++ 实现stl中的string类，实现构造，拷贝构造，析构，赋值，比较，字符串相加，获取长度及子串等功能。"
  },
  {
    "ID" : "55e6d85be4b0152a610de820",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "'\\09'",
    "optionC" : "'a'",
    "optionAnswer" : "D",
    "answer" : "字符常量是用单引号括起来的一个字符。例如：'a'、'='、'+'等。转义字符是一种特殊的字符常量。转义字符以反斜线\"\\\"开头,后跟一个或几个字符。D选项中'\\09',\\0表示后面的字符是八进制数。又出现9所以是非法的,故D选项正确。",
    "optionB" : "'\\b'",
    "type" : "1",
    "optionA" : "'\\007'",
    "question" : "以下选项中非法的C语言字符常量是？"
  },
  {
    "answer" : "排列用C，组合用A。既然题目说是无数个,就相当于有放回的取6个不同颜色的球。因此，所有情况是6^5=7776，充当分母\n\nA5种：C65A55=720\nA4种：C64C41A55\/2=3600\nA3种：C63[C31A55\/(3!)+C32A55\/(2!*2!)]=3000\nA2种：C62[C21A55\/(4!)+C31A55\/(3!*2!)]=450\nA1种：C61[A55\/5!]=6\n算完在草稿纸上验算一下有没有算漏掉：A5+A4+A3+A2+A1=7779=6^5,说明准确无误，\n\n再算概率：\nP5=A5\/7776\nP4=A4\/7776\n...",
    "ID" : "55f2e51de4b0152a6114338e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有6种不同颜色的球，分别记为1,2,3,4,5,6，每种球有无数个。现在取5个球，求在以下的条件下：\n1、5种不同颜色，\n2、4种不同颜色的球，\n3、3种不同颜色的球， \n4、2种不同颜色的球，\n它们的概率。"
  },
  {
    "answer" : "这段代码是在固定字符串里面搜索字符 ‘d’\n用C语言实现\n\nif (strstr (“Hello, World!”, “d”) != NULL))\n    exitProcess(1);\nexitProcess (0);",
    "ID" : "55f2e51de4b0152a6114334e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "以下是一段汇编代码，请用C语言实现相同功能。\n\n.data\nSourceStringdb \"Hello, World!\",0\n.code\nstart:\ncld\nxoreax, eax\nmovedi, offset SourceString\nmov al, 'd'\nmovecx, 13\nrepnescas\njz wow\ninvokeExitProcess, 0\nwow:\ninvokeExitProcess, 1\nend start"
  },
  {
    "answer" : "方法1：\n\nint main()\n　{\n　　char* src = \"hello,world\";\n　　int len = strlen(src);\n　　char* dest = (char*)malloc(len+1);\/\/要为\\0分配一个空间\n　　char* d = dest;\n　　char* s = &src[len-1];\/\/指向最后一个字符\n　　while( len-- != 0 )\n　　*d++=*s--;\n　　*d = 0;\/\/尾部要加\\0\n　　printf(\"%s\\n\",dest);\n　　free(dest);\/\/ 使用完，应当释放空间，以免造成内存汇泄露\n　　return 0;\n　}\n方法2：\n\nmain()\n{\n　　　char str[]=\"hello,world\";\n　　　int len=strlen(str);\n　　　char t;\n　　　for(int i=0; i　　　{\n　　　　t=str[i];\n　　　　str[i]=str[len-i-1]; str[len-i-1]=t;\n　　　}\n　　　printf(\"%s\",str);\n　　　return 0;\n}",
    "ID" : "55f2e51ee4b0152a611433b1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请找出下面代码中的所有错误\n说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”\n\n#include\"string.h\"\nmain()\n　　{\n　　 char*src=\"hello,world\";\n　　 char* dest=NULL;\n　　 int len=strlen(src);\n　　 dest=(char*)malloc(len);\n　   char* d=dest;\n　　 char* s=src[len];\n　　 while(len--!=0)\n　　     d++=s--;\n　　 printf(\"%s\",dest);\n　　 return 0;\n　}"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "fastcall",
    "optionC" : "pascal",
    "optionAnswer" : "A",
    "answer" : "可变参数函数需要由调用者清栈，因为当前函数并不知道要有多少参数被传入，所以必须用cdcel",
    "optionB" : "stdcall",
    "type" : "1",
    "optionA" : "cdecl",
    "question" : "Which of the following calling convention(s) support(s) support variable-length parameter(e.g. printf)?"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c01",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "clog",
    "optionC" : "cout",
    "optionAnswer" : "A",
    "answer" : "(1)标准输入流cin：istream类的对象。(2)标准输出流cout：ostream类的对象。\n(3)非缓冲型标准出错流cerr：ostream类的对象。(4)缓冲型标准出错流clog：ostream类的对象",
    "optionB" : "cerr",
    "type" : "1",
    "optionA" : "cin",
    "question" : "在C++中，使用流进行输入输出，其中用于屏幕输入（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143208",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "一种类型当它至少提供了另一种类型的行为,则这种类型是另一种类型的子类型",
    "optionC" : "子类型就是指派生类是基类的子类型",
    "optionAnswer" : "D",
    "answer" : "子类型必须是子类继承了父类的所有可继承特性，也即公有继承，才能说是子类型，否则就只是单纯的子类",
    "optionB" : "子类型关系是不可逆的",
    "type" : "1",
    "optionA" : "在公有继承下,派生类是基类的子类型",
    "question" : "关于子类型的描述中，（ ）是错误的？"
  },
  {
    "ID" : "55f2e469e4b0152a6114312a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "p=Test::fun",
    "optionC" : "p=fun()",
    "optionAnswer" : "D",
    "answer" : "class MyClass {\npublic:\n    MyClass(int i = 0) { cout << 1; }\n    MyClass(const MyClass&x) { cout << 2; }\n    MyClass& operator=(const MyClass&x) { cout << 3; return*this; }\n    ~MyClass() { delete this; }\n    void fun(int) {}\n};\nint main(void)\n{\n    {\n        void (MyClass::*function)(int);\n        function = MyClass::fun;\n    }\n    system(\"pause\");\n    return 0;\n}",
    "optionB" : "p=Test::fun()",
    "type" : "1",
    "optionA" : "p=fun",
    "question" : "已知fun(int)是类Test的公有成员函数，p是指向成员函数fun()的指针，采用（ ）是正确的。"
  },
  {
    "answer" : "1.用户输入一些关键字查询时，将用户的相关信息(ip,cookie,keyword,usernameetc.)，暂时存储。（临时对象，临时文件等等）。\n2.定时从暂时缓存处，一次行读取，写入到数据库中。\n3.记录下来关键字后，需要定时从数据库中提取出来。\n4.数据库存储建议采用Oracle，因为这个数据量会增加很快，且很大。最好采用分表处理。\n5.定时生成相关关键字页面，可以与定时关键字写入数据库放在一起。",
    "ID" : "55f2e51de4b0152a61143380",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "京东商城的商品搜索功能是整个网站架构中非常重要的一个模块。当用户在搜索栏中写入他们想要搜索的关键字时，往往会有一些热门的关键词出现在提示框中。对于这一功能的实现，你认为需要注意什么。"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143259",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "struct B;struct A(B& _b;);struct B{A& _a;};",
    "optionC" : "struct A{A& _a;};",
    "optionAnswer" : "A",
    "answer" : "struct成员类型不可以是它自己。\n因为会递归定义。\n理论上这样导致结构体的大小不能被计算（无限大小）。所以不能在结构体里的成员类型是结构体本身。\n但是成员可以定义为该结构体的指针。就像你上面这段代码。因为指针的大小是已知的（随编译器和操作系统而定）。\n所以可以定义为该结构体的指针，但不是该结构体。",
    "optionB" : "struct A{A* _a;};",
    "type" : "1",
    "optionA" : "struct A{A  _a};",
    "question" : "以下定义错误的是："
  },
  {
    "ID" : "55f2e4ffe4b0152a6114325e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "'\\09'",
    "optionC" : "'a'",
    "optionAnswer" : "D",
    "answer" : "本题考查字符常量,字符常量是用单引号括起来的一个字符。例如：'a'、'='、'+'等。转义字符是一种特殊的字符常量。转义字符以反斜线\"\\\"开头,后跟一个或几个字符。D选项中'\\09',\\0表示后面的字符是八进制数。又出现9所以是非法的,故D选项正确。",
    "optionB" : "'\\b'",
    "type" : "1",
    "optionA" : "'\\007'",
    "question" : "以下选项中非法的C语言字符常量是？"
  },
  {
    "ID" : "55e6d85be4b0152a610de81f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "在一个函数内的复合语句中定义的变量在本函数范围内有效",
    "optionC" : "在一个函数内定义的变量只在本函数范围内有效",
    "optionAnswer" : "D",
    "answer" : "自动变量的作用域仅限于定义该变量的个体内。在函数中定义的自动变量，只在该函数内有效。在复合语句中定义的自动变量只在该复合语句中有效。自动变量属于动态存储方式，只有在使用它，即定义该变量的函数被调用时才给它分配存储单元，开始它的生存期。函数调用结束，释放存储单元，结束生存期。因此函数调用结束之后，自动变量的值不能保留。在复合语句中定义的自动变量，在退出复合语句后也不能再使用，否则将引起错误。",
    "optionB" : "函数中的形式参数是局部变量",
    "type" : "1",
    "optionA" : "在不同的函数中可以使用相同名字的变量",
    "question" : "以下叙述中不正确的是"
  },
  {
    "ID" : "55f2e469e4b0152a6114313f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int *ip=new int(12);\nfor(int i=0;i<12;++i){\nip[i]=i;\n}\ndelete []ip;",
    "optionC" : "double *a=new double[1];\n\/\/.... \ndelete a;",
    "optionAnswer" : "C",
    "answer" : "new 和delete 配套使用  free和malloc配套使用 AB错误\nD是因为申请的是一个元素，后面跟的12是初始化值，而不是数组，所以错误。\nnew和delete与free和malloc的差别是前面2个会分别调用构造函数和析构函数",
    "optionB" : "int *ip=static_cast<int*>(malloc(sizeof(int)));\n*ip=10;\n\/\/.....\ndelete ip;",
    "type" : "1",
    "optionA" : "int *a=new int(12);\n\/\/..... \nfree(a);",
    "question" : "以下涉及到内存管理的代码段中，没错误的是："
  },
  {
    "ID" : "55f2e4fee4b0152a61143235",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "rand()%(n-i)>m   m++",
    "optionC" : "rand()%(n-i)>=m   m++",
    "optionAnswer" : "B",
    "answer" : "为了方便解释假设n等于10，m等于5：\n第一次rand()%(n-0)的余数范围是0~9,有可能小于m(=5)，可以输出i=0；随后i++,m--\n第二次rand()%(n-1)的余数范围是0~8,有可能小于m(=4)，可以输出i=1；随后i++,m--\n...\n第五次rand()%(n-4)的余数范围是0~5,有可能小于m(=1)，可以输出i=4；随后i++,m--得到i=5,m=0\n\n第六次rand()%(n-5)的余数范围是0~4,不可能小于m(=0)，算法结束。\n\n倘若rand()%(n-i)<=m，则第六次还满足条件，意味着多输出的一次；\n\n而rand()%(n-i)>=m，将会因为判断条件不满足而提早退出。因此选B",
    "optionB" : "rand()%(n-i)<m   m--",
    "type" : "1",
    "optionA" : "rand()%(n-i)<=m   m--",
    "question" : "下面的程序可以从0....n-1中随机等概率的输出m个不重复的数。这里我们假设n远大于m\n\nknuth(int n, int m)\n{ \n    srand((unsigned int)time(0)); \n    for (int i = 0; i < n; i++) { \n        if ( ) { \n            cout << i << endl;\n            ( );\n        }\n     }\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a61143219",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int a [ 10 ] ;",
    "optionC" : "int * a ;",
    "optionAnswer" : "B",
    "answer" : "本题考查typedef的使用方法,typedef对已存在的类型使用一个新的名字,其中本题中int * 用T来代替,所以定义T a[ 10 ];就相当于是int * a[10];选项B正确。",
    "optionB" : "int * a [ 10 ] ;",
    "type" : "1",
    "optionA" : "int ( * a ) [ 10 ] ;",
    "question" : "若有定义\n\ntypedef int * T; \nT a[10]; \n则a的定义与下面哪个语句等价?"
  },
  {
    "answer" : "int BinarySearch(char **ar,int begin,int end,char *v)\n{\n    int result=-1;\n    while(begin <= end)\n    {\n        int mid=begin+(end-begin)\/2;\n        if(strcmp(ar[mid],v) > 0)\n            end=mid-1;\n        else if(strcmp(ar[mid],v) < 0)\n            begin=mid+1;\n        else\n        {\n            if(result < mid)\n                result=mid;\n            begin=mid+1;\n        }\n    }\n    return result;\n}",
    "ID" : "55f2e51ee4b0152a611433b2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "以下代码功能：找出一个有序(字典序)字符串数组arr中值等于字符串v的元素的符号，如果有多个元素满足这个条件，则返回其中序号最大的。请找出下面代码中所有错误，直接在代码右侧空白处修改\n\nInt bisearch(char**arr, int b, int e, char*v){\n    Int minIndex = b, maxIndex = e, midIndex;\n    while(minIndex<maxindex){\n        midIndex=(minIndex+maxIndex)\/2;\n        if(strcmp(arr[midIndx],v<=0)){\n            minIndex = midIndex;\n        }else{\n            maxIndex=minIndex;\n        }\n   }\n        \n    if(!strcmp(arr[maxIndex],v)){\n        return maxIndex;\n    }else{\n        return -1;\n    }\n}"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c69",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "变量Sample与a按位与的结果作为函数Set的参数",
    "optionC" : "将a的地址赋给变量Set",
    "optionAnswer" : "B",
    "answer" : "成员函数使用对象的引用作为形参。该函数的功能是将已知对象的所有数据成员的\n值拷贝给相应对象的所有数据成员，不会建立临时对象，这里是对象的引用所以选择B。",
    "optionB" : "a是类Sample的对象引用，用来作函数Set（）的形参",
    "type" : "1",
    "optionA" : "指向类Sample的名为a的指针",
    "question" : "若Sample类中的一个成员函数说明如下：void set(Sample& a)，则Sample& a的含义是（）"
  },
  {
    "ID" : "55f2e46ae4b0152a61143154",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "* strp",
    "optionC" : "strp[3]",
    "optionAnswer" : "B",
    "answer" : "本题考查字符串指针作为函数参数,本题中p作为字符串指针传入fun中,p指向的内容并没有发生变化,所以选项B正确。",
    "optionB" : "strp",
    "type" : "1",
    "optionA" : "str[0]",
    "question" : "若有以下程序段\n\nchar str[4][12]={\"aa\", \"bbb\", \"cccc\", \"d\"},*strp[4];\nint i;\nfor(i=0;i<4;i++) \n    strp[i]=str[i];\n不能正确引用字符串的选项是"
  },
  {
    "answer" : "在特定时间内完成特定的任务，实时性与可靠性。\n所谓“实时操作系统”，实际上是指操作系统工作时，其各种资源可以根据需要随时进行动态分配。由于各种资源可以进行动态分配，因此其处理事务的能力较强、速度较快。 应该说，实时操作系统是在早期的操作系统基础上发展起来的，早期的操作系统的各种资源都是事先已经分配好的，工作期间这些资源不能再重新进行分配。因此其处理事务的能力较差、速度较慢，现在则称之为“非实时操作系统”。但“非实时操作系统”诞生时，其功能、性能等在当时也是非常强的，人们在未认识到更好的操作系统之前并不将其这样称呼。将来如果新的、功能更强的、实时性能更高的操作系统出现，也许现在称之为“实时”的操作系统则可能将让位于新的“实时操作系统”了。从这方面讲“实时操作系统”是一个相对的概念的",
    "ID" : "55f2e51ee4b0152a611433ce",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "描述实时系统的基本特性"
  },
  {
    "answer" : "(a):根据uid,msg分库记录用户的消息.直接通过sql查询实现\n\n(b):A follow B, B发消息的时候主动发送消息id到A的新鲜事列表.\n如果A是僵死用户就通过拉的方式,登陆后获取所有关注用户的微薄",
    "ID" : "55f2e51ee4b0152a611433a4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "微博上，每个用户可以发送一条消息，可以 follow 另一个用户， 当用户发送消息时，所有 follow 他的用户都能看见这条消息。如 A follow B，则 B 的消息，A 都能看见。\n实现一个微博客消息存储系统，可以使用多台机器来满足性能要求， 可以再海量的用户和消息下，快速的实现以下两种查询：\na）给定一个用户，查询他发送的消息，按消息发送时间排序，新 的消息在前。\nb）给定一个用户，查询他 follow 的所有人的消息，按消息发送时 间排序，新的消息在前."
  },
  {
    "ID" : "55f2e46ae4b0152a61143155",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "赋值操作函数",
    "optionC" : "非静态成员函数",
    "optionAnswer" : "A",
    "answer" : "构造函数是不能被继承的,但是可以被调用,如果父类重新定义了构造函数,也就是没有了默认的构造函数,子类创建自己的构造函数的时候必须显式的调用父类的构造函数。而其余的三个在我们平常的使用中都可以被继承使用。",
    "optionB" : "静态成员函数",
    "type" : "1",
    "optionA" : "构造函数",
    "question" : "C++类体系中，不能被派生类继承的有?"
  },
  {
    "answer" : "400",
    "ID" : "55f2e51de4b0152a61143388",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "两个人，A的速度为a，B的速度为b,在一直路上相向而行。在A、B距离为s的时候，A放出一个鸽子C，速度为c，C飞到B后，立即掉头飞向A，遇到A在掉头飞向B......就这样在AB之间飞来飞去，直到A、B相遇，假设a=40， b=60， c=400， s=100，这期间鸽子共飞行路程为?"
  },
  {
    "answer" : "a中奇\/偶数的数量必有其一不小于长度的一半所以必然有解，找到不符合的两个交换\n\n#include <algorithm>\nusing namespace std;\nclass Solution {\npublic:\n    \/**\n     *  奇数位上都是奇数或者偶数位上都是偶数\n     *  输入：数组arr，长度大于2\n     *  len：arr的长度\n     *  将arr调整成奇数位上都是奇数或者偶数位上都是偶数\n     *\/\n    void oddInOddEvenInEven(vector<int>& arr, int len) {\n        int i = 0, j = 1;\n        while(i < len && j < len){\n            while(i < len && (arr[i] & 1) == 0) i += 2;\n            while(j < len && (arr[j] & 1) == 1) j += 2;\n            if(i < len && j < len) swap(arr[i], arr[j]);\n        }\n    }\n};",
    "ID" : "55f2e51de4b0152a61143342",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个长度不小于2的数组arr。 写一个函数调整arr，使arr中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),下标0,2,4,6...算作偶数位,下标1,3,5,7...算作奇数位，例如[1,2,3,4]调整为[2,1,4,3]即可"
  },
  {
    "answer" : "Java 和 C++ 都是面向对象的语言，但他们也存在着一些区别\n\n1、Java 不支持多继承\n2、Java 没有指针和引用\n3、c++ 需要程序员手动管理堆内存，Java有自动垃圾回收机制\n\nJava运行在java虚拟机上，速度相对较慢，在实时性要求高的场合应该用c++\njava通常在手机上应用的比较多。",
    "ID" : "55f2e51de4b0152a61143374",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "JAVA和C++的区别是什么?分别用在什么情景比较好?"
  },
  {
    "answer" : "测试文件的内容输出的是struct_pitem结构中的priority字段的16进制形式，将其转换为字符串正好是通过pqueue_insert函数放入到pqueue结构中的prio3、prio1、prio2的值。通过观察测试文件中每一行的值可以发现对应的字符串序列为prio3、prio2、prio1，跟插入字符串的顺序并不一致，说明pqueue既不是先进先出（队列），也不是后进先出（栈）。\n\n另外，通过观察测试文件可以发现测试文件中的字符串是按照从小到大排列的，而且struct_pitem中的priority字段含义可以理解，这是一个优先级队列，priority字段代表队列的优先级，priority字段越小，优先级越高。\n\n理解了队列的结构后，就可以写出插入的代码了。\n\npitem *pqueue_insert(pqueue pq, pitem *item)\n{\n    if (!item)\n    {\n        return NULL;\n    }\n     \n    if (pq->count == 0)\n    {\n        pq->items = item;\n        count++;\n        return pq->items;\n    }\n     \n    \/\/ 查找要插入的位置\n    pitem *iter, *item2, *item_before = NULL;\n    iter = pqueue_iterator(pq);\n    for(item2=pqueue_next(&iter); item2!=NULL; item2=pqueue_next(&iter))\n    {\n        int result = 0;\n        for (int i=0; i<8; i++)\n        {\n            if (item[i] < item2[i])\n            {\n                result = -1;\n            }\n            else if (item[i] < item2[i])\n            {\n                result = 1;\n            }\n        }\n         \n        if (result == -1)\n        {\n            break;\n        }\n        item_before = item2;\n    }\n     \n    if (!item_before)\n    {\n        \/\/ item需要插入到队列中的第一个位置\n        item_before = pq->items;\n        pq->items = item;\n        item->next = item_before;\n    }\n    else\n    {\n        pitem *tmp = item_before->next;\n        item_before->next = item;\n        item->next = tmp;\n    }\n    pq->count++;\n    return item;\n}",
    "ID" : "55f2e51de4b0152a6114333c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有pqueue.h如下\n\n#ifndef HEADER_PQUEUE_H\n#define HEADER_PQUEUE_H\ntypedef struct_pqueue{\n    pitem *items;\n     int count;\n}pqueue_s;\ntypedef struct_pqueue *pqueue;\ntypedef struct_pitem{\n    unsigned char priority[8];\n    void *data;\n    struct_pitem *next;\n}pitem;\ntypedef struct_pitem *piterator;\npitem *pitem_new(unsigned char *prio64be,void *data);\nvoid pitem_free(pitem *item);\n  \npqueue pqueue_new(void);\nvoid pqueue_free(pqueue pq);\npitem *pqueue_insert(pqueue pq,pitem *item);\npitem *pqueue_peek(pqueue pq);\npitem *pqueue_pop(pqueue pq);\npitem *pqueue_find(pqueue pq,unsigned char *prio64be);\npitem *pqueue_iterator(pqueue pq);\npitem *pqueue_next(piterator *iter);\nint pqueue_size(pqueue pq);\n#endif \/*! HEADER_PQUEUE_H *\/\npq_test.c如下：\n\n#include<stdlib.h>\n#include<string.h>\n#include\"pqueue.h\"\n\/*remember to change expected.txt if you change there values*\/\nunsigned char prio1[8]=\"supercal\";\nunsigned char prio2[8]=\"ifragili\";\nunsigned char prio3[8]=\"sticexpi\";\nstatic void\npqueue_print(pqueue pq)\n{\n     pitem *iter,*item;\n     iter=pqueue_iterator(pq);\n     for(item=pqueue_next(&iter);item!=NULL;\n         item=pqueue_next(&iter)){\n         printf(\"item\\t%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n             item ->priority[0],item->priority[1],\n             item ->priority[2],item->priority[3],\n             item ->priority[4],item->priority[5],\n             item ->priority[6],item->priority[7],\n         }\n}\nint main(void)\n{\n     pitem *item;\n     pqueue pq;\n     pq=pqueue_new();\n     item=pitem_new(prio3,NULL);\n     pqueue_insert(pq,item);\n  \n     item=pitem_new(prio1,NULL);\n     pqueue_insert(pq,item);\n  \n     item=pitem_new(prio2,NULL);\n     pqueue_insert(pq,item);\n     item=pqueue_find(pq,prio1);\n     fprintf(stderr,\"found %p\\n\",item->priority);\n     item=pqueue_find(pq,prio2);\n     fprintf(stderr,\"found %p\\n\",item->priority);\n  \n     item=pqueue_find(pq,prio3);\n     fprintf(stderr,\"found %p\\n\",item->priority);\n      \n     pqueue_print(pq);\n     for(item=pqueue_pop(pq);item!=NULL;item=pqueue_pop(pq))\n     pitem_free(item);\n  \n     pqueue_free(pq);\n     return 0;\n}\npq_test.sh如下：\n\n#!\/bin\/sh\nset -e\n.\/pq_test | cmp $srcdir\/pq_expected.txt-\npq_expected.txt如下：\nitem 6966726167696c69\nitem 7374696365787069\nitem 737570657263616c\n\n1.根据测试代码描述pqueue的工作原理。\n2.请实现 pitem *pqueue_insert(pqueue pq,pitem *item);"
  },
  {
    "ID" : "55f2dfa6e4b0152a61142e2b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "None of the above",
    "optionC" : "Port numbers below 1024 are called well-known ports and are reserved for standard services. For example,port 21 is reserved for FTP protocol, and port 25 is for SMTP protocol.",
    "optionAnswer" : "C",
    "answer" : "C是正确的",
    "optionB" : "TCP supports multicasting.",
    "type" : "1",
    "optionA" : "TCP provides a way for applications to send encapsulated IP datagrams and send them without having to establish a connection.",
    "question" : "Which statement(s) below regarding TCP(Transmission Control Protocol) is(are) correct?"
  },
  {
    "ID" : "55e6d85be4b0152a610de818",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "char?str[]?=?{\"a\",?\"b\"};",
    "optionC" : "char?str[2][3]={{'a','b'},{'e','d'},{'e','f'}};",
    "optionAnswer" : "B",
    "answer" : "A中字符变量不能存放字符串，C中维度错了，D和A的问题一样",
    "optionB" : "char?str[2][3]={\"a\",\"b\"};",
    "type" : "1",
    "optionA" : "char?str[2]?=?{\"a\",\"b\"};",
    "question" : "下面关于数组的初始化正确的是："
  },
  {
    "ID" : "55f2e4fee4b0152a6114324b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "p=A或p=&A[0][0]",
    "optionC" : "p=A[0]或p=&A[0][0]",
    "optionAnswer" : "C",
    "answer" : "int A[10][10];\n    int *p;\n     \n    \/\/p = A;\/\/不能通过编译\n    \/\/cout<<p<<\",\"<<*p<<endl;\n    p = A[0];\n    cout<<p<<\",\"<<*p<<endl;\n    \/\/p = A[0][0]; \/\/不能通过编译\n    \/\/cout<<p<<\",\"<<*p<<endl;\n    p = &A[0][0];\n    cout<<p<<\",\"<<*p<<endl;\n \n答案为C",
    "optionB" : "p=A[0]或p=A[0][0]",
    "type" : "1",
    "optionA" : "p=A或p=A[0]",
    "question" : "要使指针变量p指向2维数组A的第1个元素，正确的赋值表达式是（）。"
  },
  {
    "answer" : "\/\/二分法求解\n\/\/a^b = (a ^ (b\/2))^2\nint GetPow(int a, int b) {\n    if (b == 1 || b == 0) {\n        return a;\n    }\n    if (b % 2) {\n        return ((int) (pow((float) GetPow(a, b \/ 2), 2) * a) % 1000);\n    } else {\n        return ((int) (pow((float) GetPow(a, b \/ 2), 2)) % 1000);\n    }\n}",
    "ID" : "55f2e51ee4b0152a611433a3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定两个数A、B（0，<a,b<100000），求A^B中最后三位数是多少。请简要描述你的思路。<\/a,b< "
  },
  {
    "ID" : "55f2dfa6e4b0152a61142e2c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "DES",
    "optionC" : "RC4",
    "optionAnswer" : "A",
    "answer" : "MD5是不可逆加密，不可以用来加密文本，DES和RC4是对称加密，RSA是不对称加密，都可以用于文本加密。",
    "optionB" : "RSA",
    "type" : "1",
    "optionA" : "MD5",
    "question" : "Which of the following method(s) CANNOT be used for Text-encryption:"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c7f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "派生类指针调用虚函数",
    "optionC" : "基类对象调用虚函数",
    "optionAnswer" : "A",
    "answer" : "使用基类的指针或引用，由指向或引用的对象来决定调用不同类的虚函数。所以选\n择A。",
    "optionB" : "派生类对象调用虚函数",
    "type" : "1",
    "optionA" : "基类指针调用虚函数",
    "question" : "要采用动态多态性，说法正确的是（）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c0a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "保证基类公有成员在子类中可以被访问。",
    "optionC" : "保证基类保护成员在子类中可以被访问。",
    "optionAnswer" : "A",
    "answer" : "this指针是隐藏的，可以使用该指针来访问调用对象中的数据。基类的成员在派生\n类中能否访问，与继承方式有关，与this没有关系。所以选择A项。",
    "optionB" : "保证基类私有成员在子类中可以被访问。",
    "type" : "1",
    "optionA" : "保证每个对象拥有自己的数据成员，但共享处理这些数据的代码",
    "question" : "关于this指针使用说法正确的是（）"
  },
  {
    "ID" : "55f2e46ae4b0152a61143146",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8",
    "optionC" : "2",
    "optionAnswer" : "A",
    "answer" : "数组为3行4列如下\n3 4 0 0\n2 8 6 0\n0 0 0 0\na[1][2]求的是第二行第三列的值，所以为6",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "6",
    "question" : "假定一个二维数组的定义语句为“int a[3][4]={{3,4},{2,8,6}};”，则元素a[1][2]的值为"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c28",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "重载函数名可以不同",
    "optionC" : "重载函数必须有不同的形参列表",
    "optionAnswer" : "C",
    "answer" : "函数的重载必须函数名相同而形参类型或个数不同，与返回值无关。",
    "optionB" : "重载函数参数个数必须相同",
    "type" : "1",
    "optionA" : "重载函数必须具有不同的返回值类型",
    "question" : "下列有关重载函数的说法中正确的是（）"
  },
  {
    "ID" : "55e429cfe4b0152a610c8343",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "难度",
    "optionC" : "现实性",
    "optionAnswer" : "B",
    "answer" : "算法的计算量的大小称为计算的（B. 复杂性 ）。",
    "optionB" : "复杂性",
    "type" : "1",
    "optionA" : "效率",
    "question" : "算法的计算量的大小称为计算的()"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7fd",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "链接错误",
    "optionAnswer" : "A",
    "answer" : "调用静态函数本身不会执行构造函数， 但?get?()实例化了一个对象，所以在get（）里面调用了构造函数。",
    "optionB" : "编译错误",
    "type" : "1",
    "optionA" : "输出A()",
    "question" : "编译运行如下程序会出现什么结果<p class=\"p0\">\n    #include <iostream>\nusing namespace std;\n \nclass A\n{\n    A()\n    {\n        printf(\"A()\");\n    }\npublic:\n    static A &get()\n    {\n        static A a;\n        return a;\n    }\n};\nint main()\n{\n    A::get();\n    return 0;\n}\n \n \n<\/p>"
  },
  {
    "answer" : "输出结果为： 4 5\nstrlen只是对传递给Func 函数的那个字符串求长度，跟str_arg中的那个2 是没有任何关系的， 即使把2 改为200 也是不影响输出结果的",
    "ID" : "55f2e51ee4b0152a611433e3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "下面程序的输出结果为多少？\nvoid Func(char str_arg[2])\n{\n int m = sizeof(str_arg); \/\/指针的大小为4\n int n = strlen(str_arg); \/\/对数组求长度，str_arg 后面的那个2没有任何意义，数组已经退化为指针了\n printf(\"%d\\n\",m);\n printf(\"%d\\n\",n);\n}\nint main(void)\n{\n char str[]=\"Hello\";\n Func(str);\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143260",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "foobarb_fpp",
    "optionC" : "barfoob_foo",
    "optionAnswer" : "A",
    "answer" : "A *p=newB;\/\/ A类指针指向一个实例化对象B， B类继承A类，先调用父类的无参构造函数，bar()输出bar，B类没有自己显示定义的构造函数。\np->foo();\/\/执行B类里的foo()函数，因为foo不是虚函数，所以直接调用父类的foo函数，输出foo\np->bar();\/\/执行B类的bar()函数, 该函数为虚函数，调用子类的实现，输出b_bar",
    "optionB" : "foobarb_bar",
    "type" : "1",
    "optionA" : "barfoob_bar",
    "question" : "有如下C++代码：\n\nstruct A{\n  void foo(){printf(\"foo\");}\n  virtual void bar(){printf(\"bar\");}\n  A(){bar();}\n};\nstruct B:A{\n  void foo(){printf(\"b_foo\");}\n  void bar(){printf(\"b_bar\");}\n};\n那么 \n1\n2\n3\nA *p=new B;\np->foo();\np->bar();\n输出为：  "
  },
  {
    "answer" : "-5",
    "ID" : "55f2e51ee4b0152a6114339d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "店主销售电话卡，他以60元的价格各销售了两张。其中一张是赚了20%，另一张是亏了20%。 请问他总共赚了____钱(亏了的话请用负数表示)？"
  },
  {
    "answer" : "#define LONG_MAX 2147483647L  \n#define LONG_MIN (-2147483647L-1L)\n#include<stdio.h>\nlong strtol ( char *  nptr, char  **  endptr, int  base   )  {\n      const char *s = nptr;\n     unsigned long acc;\n      unsigned char c;\n    unsigned long cutoff;\n     int neg = 0,any, cutlim;\n\/\/判断正负号   \n  do{ c = *s++;\n      } while (c==' ');\n      if (c == '-')\n    {\n          neg = 1;\n         c = *s++;\n    }\n      else if (c == '+')\n          c = *s++;\n\/\/判断进制数\n      if ((base == 0 || base == 16) &&\n          c == '0' && (*s == 'x' || *s == 'X'))\n      {\n          c = s[1];\n          s += 2;\n          base = 16;\n      }\n      if (base == 0)\n          base = c == '0' ? 8 : 10;\n  \n\/\/溢出处理\n     cutoff = neg ? -(unsigned long) LONG_MIN : LONG_MAX;\n     cutlim = cutoff % (unsigned long) base;\n      cutoff \/= (unsigned long) base;\n      for (acc = 0, any = 0;; c = *s++)\n      {\n         if (c>='0'&&c<='9')\n              c -= '0';\n          else if ((c>='A'&&c<='Z')||(c>='a'&&c<='z'))\n             c -= (c>='A'&&c<='Z') ? 'A' - 10 : 'a' - 10;\n          else\n              break;\n          if ((int) c >= base)\n              break;\n          if (any < 0 || acc > cutoff || acc == cutoff && (int) c > cutlim)\n              any = -1;\n          else\n          {\n              any = 1;\n              acc *= base;\n             acc += c;\n          }\n      }\n\/\/超过范围则输出range error\n     if (any < 0)\n      {\n        \/\/ acc = neg ? LONG_MIN : LONG_MAX;\n          \/\/errno = ERANGE;\n    printf(\"range error.\\n\");\n      }\n      else if (neg)\n          acc = -acc;\n      if (endptr != 0)\n         *endptr = any ?(char *) ( s - 1) : (char *) nptr;\n      return acc;\n }\nint main(){\n char*nptr=\"-0x12G 00,\";char  *endptr[100];int  base=0;\n long n= strtol ( nptr,   endptr, base) ;\n printf(\"n=%ld\\nendptr=%s\\n\",n,*endptr);\n}",
    "ID" : "55f2e51de4b0152a61143389",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "实现strtol函数，其原型如为int strtol(const char *num_str, char **endptr, int base)，num_str存放待转换的字符串，可以是负数也可以是正数；endptr指向第一个非法字符的地址，如果endptr为null则不指向第一个非法字符的地址；base用于指示进制，若base为0，则根据num_str的指示来转换。函数必须检查溢出，如果正数溢出，返回int_max；若负数溢出，返回int_min。"
  },
  {
    "answer" : "int getLongestSubString(char* query, char* text){\n int imax = INT_MIN;\n int m = strlen(query);\n int n = strlen(text);\n vector<vector<int>> temp(m, vector<int>(n, 0));\n \n for (int i = 0; i < m; i ++){\n  for (int j = 0; j < n; j ++){\n   if (query[i] == text[j]){\n    if (i == 0 || j == 0){\n     temp[i][j] = 1;\n    }\n    else{\n     temp[i][j] = temp[i - 1][j - 1] + 1;\n    }\n    \n    imax = max(imax, temp[i][j]);\n   }\n  }\n }\n \n return imax;\n}",
    "ID" : "55f2e51ce4b0152a61143332",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个query和一个text，均由小写字母组成。要求在text中找出以同样的顺序连续出现在query中的最长连续字母序列的长度。例如，query为 \"acbac\",text为\"acaccbabb\",那么text中的\"cba\"为最长的连续出现在query中的字母序列，因此，返回结果应该为其长度3。请注意程序效率。"
  },
  {
    "answer" : "类型声明符在C语言里面主要有三个用途：\n1.声明静态局部变量\n2.声明静态外部全局变量\n3.声明静态外部函数",
    "ID" : "55f2e51ee4b0152a611433cc",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "static有什么用途？（请至少说明两种）"
  },
  {
    "answer" : "# include <string.h>\n#include <stdio.h>\n#include <iostream>\n#include <stdlib.h>\nint fun1(int x)\n{\n int count  = 0;\n while(x)\n {\n  count++;\n  x=x&(x-1);\n }\n return count;\n}\nvoid swap(int *i,int *j)\n{\n *i = *i^*j;\n *j = *i^*j;\n *i = *i^*j;\n}\nint main()\n{\n  int n =5;\n  int a[n];\n  int x;\n  int count1,count2;\n  for (int i = 0; i < n; ++i)\n  {\n  printf(\"please input the number:\\n\");\n  std::cin>>x;\n  a[i] = x;\n  }\n  for (int i = 1; i < n; ++i)\n  {\n   for (int j = n-1; j >=i; --j)\n   {\n      count1 = fun1(a[j]);\n      count2 = fun1(a[j-1]);\n      if(count1 == count2) \n      {\n       if(a[j]<a[j-1])   swap(&a[j],&a[j-1]);\n       else continue;\n      }\n      else if(count1 < count2)   swap(&a[j],&a[j-1]);\n      else continue;\n   }\n  for (int i = 0; i < n; ++i)\n  {\n   std::cout<<a[i]<<\"  \";\n  }\n  printf(\"\\n\");\n  }\n\n}",
    "ID" : "55f2e51de4b0152a6114335f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "对一个unsigned int32型数组a进行排序，记ni为a[i]的二进制表示中\"1\"的数量，指定排序策略如下：\na)            如果ni < nj，则a[i]排在a[j]前面\nb)           如果ni == nj，按值从小到大排序"
  },
  {
    "answer" : "第一--五局：分成5个组，可以得出5个组的第一名\n第六局：5个第一名一起跑，这样可以得出最快的那一匹。\n第七局：可能成为2，3名的再赛一次，包括最快组的2，3名，次快组的1，2名，第三快组的第1名。\n\n所以一共是7次",
    "ID" : "55f2e51de4b0152a61143393",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "25匹马赛跑，每次只能跑5匹马，最快能赛几次找出跑得最快的3匹马？赛跑不能计时，并假设每匹马的速度是恒定不变的。请给出答案并描述比赛过程。"
  },
  {
    "answer" : "5",
    "ID" : "55f2e51ce4b0152a61143328",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "一个具有3个节点的二叉树可以有___种形态"
  },
  {
    "ID" : "55f2e4fee4b0152a61143242",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "一个参数不可以既是const又是volatile",
    "optionC" : "volatile适用于多线程应用中被几个任务共享的变量",
    "optionAnswer" : "D",
    "answer" : "一个参数既可以是const还可以是volatile. 一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。",
    "optionB" : "优化器在用到volatile变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份",
    "type" : "1",
    "optionA" : "当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后再取变量值时，就直接从寄存器中取值",
    "question" : "下面有关volatile说法错误的有？"
  },
  {
    "ID" : "55f2e4fee4b0152a6114324c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "多继承",
    "optionC" : "非法继承",
    "optionAnswer" : "D",
    "answer" : "多重继承：指一个类可以同时继承多个基类的行为何特征行为，但容易出现二义性",
    "optionB" : "单继承",
    "type" : "1",
    "optionA" : "循环继承",
    "question" : "一个类如果有一个以上的基类就叫做（）。"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c14",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "继承",
    "optionC" : "是一个类的成员函数与另一个类的关系",
    "optionAnswer" : "D",
    "answer" : "友元可以是函数与类的关系即友元函数，也可以类与类的关系即友元类，但友元不\n能继承，是单向性，且不具有传递性。友元可以访问类中所有成员，提高了访问的方便性。因此\n选择D项。",
    "optionB" : "是类与类的关系",
    "type" : "1",
    "optionA" : "提高程序的运行效率",
    "question" : "友元关系不能（）"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c21",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "数据抽象",
    "optionC" : "继承机制",
    "optionAnswer" : "C",
    "answer" : "继承指在原有类的基础上产生新类。数据封装即数据和操作组合在一起，形成类。\n信息的隐藏，通过访问权限来实现。数据抽象，将事物的特征抽象为数据成员或服务。因此选择\nC项。",
    "optionB" : "数据封装",
    "type" : "1",
    "optionA" : "信息隐藏",
    "question" : "如果从原有类定义新类可以实现的是（）"
  },
  {
    "answer" : "全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。\n从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。\nstatic函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件\nstatic全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;\nstatic局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；\nstatic函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝",
    "ID" : "55f2e51ee4b0152a611433c4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？"
  },
  {
    "ID" : "55f2e4fee4b0152a611431fd",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "C#",
    "optionC" : "objectC",
    "optionAnswer" : "B",
    "answer" : "A，C，D都是类C语言，B不是\nPython是解释执行的，其他语言都需要先编译",
    "optionB" : "Python",
    "type" : "1",
    "optionA" : "JAVA",
    "question" : "从运行层面上来看，从四个选项选出不同的一个。"
  },
  {
    "answer" : "10，12，120",
    "ID" : "55f2e51ee4b0152a611433c3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请写出下列代码的输出内容\n    <span class=\"s1\">int main() {\n \n        <span class=\"s1\">int a, b, c, d;\n \n        a = 10;\n \n        b = a++;\n \n        c = ++a;\n \n        d = 10 * a++;\n \n        <span class=\"s2\">printf(<span class=\"s3\">\"b，c，d：%d，%d，%d\"<span class=\"s2\">，b，c，d);\n \n        <span class=\"s1\">return 0;\n \n    }\n \n<\/span><\/span><\/span><\/span><\/span><\/span>"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c78",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "数据抽象",
    "optionC" : "定义新类",
    "optionAnswer" : "C",
    "answer" : "面向对象设计中的类的特点：抽象、封装、继承和多态等，继承用于对类的扩展\n，所以选择C项。",
    "optionB" : "数据封装",
    "type" : "1",
    "optionA" : "信息隐藏",
    "question" : "继承机制的作用是（）"
  },
  {
    "answer" : "#include <iostream>\n \nusing namespace std;\n \nint getMax(int *pScore, int low, int high)\n{\n    if(low > high)\n    {\n        high = low ^ high;\n        low = low ^ high;\n        high = low ^ high;\n    }\n    int maxScore = pScore[low];\n    for(int i = low + 1; i <= high; ++i)\n    {\n        if(maxScore < pScore[i])\n        {\n            maxScore = pScore[i];\n        }\n    }\n \n    return maxScore;\n}\n \nint main()\n{\n    int N = 0;\n    int M = 0;\n    while(cin >> N >> M)\n    {\n        int *pScore = new int[N + 1];\n        for(int i = 1; i <= N; ++i)\n        {\n            cin >> pScore[i];\n        }\n \n        for(int i = 0; i < M; ++i)\n        {\n            char ch = '\\0';\n            int low = 0;\n            int high = 0;\n \n            cin >> ch >> low >> high;\n \n            if('Q' == ch)\n            {\n                cout << getMax(pScore, low, high) << endl;\n            }\n            else if('U' == ch)\n            {\n                pScore[low] = high;\n            }\n            else\n            {\n                \/\/ continue;\n            }\n        }\n \n        delete[] pScore;\n    }\n \n    return 0;\n}",
    "ID" : "55f2e51ce4b0152a61143324",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩."
  },
  {
    "ID" : "55f2e4ffe4b0152a61143279",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "几小时",
    "optionC" : "几分钟",
    "optionAnswer" : "D",
    "answer" : "计算执行次数得到递推公式\nf(n)=f(n-1)+....+f(0)\nf(n)=2(f(n-2)+...+f(0))\nf(n)=2^2(f(n-3)+...+f(0))\n...\nf(n)=2^(n-1)f(0)=2^(n-1)\nf(35)=2^34  大改100多亿\n计算机应该是每秒几百万次\n所以算下来需要几个小时",
    "optionB" : "几秒",
    "type" : "1",
    "optionA" : "几毫秒",
    "question" : "在一台主流配置的PC机上，调用f(35)所需的时间大概是_______。\n\nint f(int x) {\n    int s=0;\n    while(x-- >0)   s+=f(x);\n    return max(s,1);\n}"
  },
  {
    "ID" : "55f2e46ae4b0152a61143149",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "k=3 a=14",
    "optionC" : "k=6 a=11",
    "optionAnswer" : "B",
    "answer" : "当k=0时,执行while一次,得到k=1,a为2;当k=1时,执行while一次,得到k=2,a为4;当k=2时,执行while一次,得到k=3,a=7;当k=3时,执行while一次,得到k=4,a为12;所以答案为B选项。",
    "optionB" : "k=4 a=12",
    "type" : "1",
    "optionA" : "k=5 a=15",
    "question" : "有以下程序\n#include<stdio. h>\nmain()\n{ \n    char *s=\"12134\";\n    int k=0, a=0;\n    while(s[k+1])\n    { \n       k++;\n       if(k%2= =0)\n       {\n            a=a+(s[k]-'0'+1);\n            continue;    \n       }\n       a=a+(s[k]-'0');\n    }\n    printf(\"k=%d a=%d\\n\",k,a);\n}\n程序运行后的输出结果是?"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c7a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "变量p的值为100",
    "optionC" : "变量p只可以指向一个整型变量",
    "optionAnswer" : "D",
    "answer" : "指针变量如同其他变量一样，在使用之前必须先声明。声明指针变量的格式为：\n<类型名>*<变量名>;\n其中，<类型名>是指针变量所指向对象的类型，它可以是C++语言预定义的类型，也可以是用户\n自定义类型。<变量名>是用户自定义的标识符。符号*表示<变量>是指针变量。而不是普通变量\n。 *表示指针，p是变量，p指向一个整型的变量，值为a的地址值，*p=100。",
    "optionB" : "变量p经初始化，获得变量a的地址",
    "type" : "1",
    "optionA" : "声明变量p，其中*表示p是一个指针变量",
    "question" : "若有以下定义，则说法错误的是（）int a=100,*p=&a;"
  },
  {
    "ID" : "55f2e469e4b0152a6114312b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "析构函数中调用虚函数",
    "optionC" : "构造函数中调用虚函数",
    "optionAnswer" : "B",
    "answer" : "所谓虚函数就是多态情况下只执行一个,而从继承的概念来讲,总是要先构造父类对象,然后才能是子类对象,如果构造函数设为虚函数,那么当你在构造父类的构造函数时就不得不显示的调用构造,还有一个原因就是为了防错,试想如果你在子类中一不小心重写了个跟父类构造函数一样的函数,那么你的父类的构造函数将被覆盖,也即不能完成父类的构造.就会出错.\n在构造函数不要调用虚函数。在基类构造的时候，虚函数是非虚，不会走到派生类中，既是采用的静态绑定。显然的是：当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的，所以C++中是不可以在构造父类对象部分的时候调用子类的虚函数实现。但是不是说你不可以那么写程序，你这么写，编译器也不会报错。只是你如果这么写的话编译器不会给你调用子类的实现，而是还是调用基类的实现。\n\n在析构函数中也不要调用虚函数。在析构的时候会首先调用子类的析构函数，析构掉对象中的子类部分，然后在调用基类的析构函数析构基类部分，如果在基类的析构函数里面调用虚函数，会导致其调用已经析构了的子类对象里面的函数，这是非常危险的。",
    "optionB" : "派生关系中的基类析构函数声明为虚函数",
    "type" : "1",
    "optionA" : "构造函数声明为虚函数",
    "question" : "以下哪个做法是正确的：（ ）"
  },
  {
    "ID" : "55f2e46ae4b0152a6114314a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "void f(int *ret) { int a[3] = {1, 2, 3}; ret = a; return; }",
    "optionC" : "vector<int> f() {vector<int> v(3); return v; }",
    "optionAnswer" : "C",
    "answer" : "因为C不存在内存泄露的问题且可以得到想要结果，但所有选项都是可以编译通过的，无语法错误。A是内存泄露，没有delete，B数组是临时的，根本传不到主调函数里，D的问题同B一样。",
    "optionB" : "int *f() { int a[3] = {1, 2, 3}; return a; }",
    "type" : "1",
    "optionA" : "int f() { int *a = new int(3); return *a; }",
    "question" : "Which of following C++ code is correct?"
  },
  {
    "ID" : "55f2e4fee4b0152a6114320e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "inline",
    "optionC" : "extern",
    "optionAnswer" : "D",
    "answer" : "D.  A.virtual 表示虚函数   B.mutable 和const是反义词,mutable只能由于修饰类的非静态数据成员\nC,extern表示外部的,说明作用域",
    "optionB" : "mutable",
    "type" : "1",
    "optionA" : "virtual",
    "question" : "内联函数用什么作标识?"
  },
  {
    "ID" : "55f2e4fee4b0152a61143234",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "NAN",
    "optionC" : "编译错误",
    "optionAnswer" : "B",
    "answer" : "选B\n\/和%优先级一样，从左到右计算，150\/50=3,3%5=3,所以结果为3",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "5",
    "question" : "下面代码的输出结果是?\nmain(){\n        printf(\"%d\",150\/50%5);\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143266",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Open The Door",
    "optionC" : "open the door",
    "optionAnswer" : "C",
    "answer" : "字符串输入函数gets的功能是从标准输入设备键盘上输入一个字符串。首先使指针变量p指向字符串的首字母,while循环语句中对字符串的每个字符进行fun函数操作。fun函数的功能是,将字符串中的大写字母变小写字母。将处理结果返回主函数,主函数通过putchar( )字符输出函数进行输出。因此C选项正确。",
    "optionB" : "oPEN tHE dOOR",
    "type" : "1",
    "optionA" : "OPEN THE DOOR",
    "question" : "有以下程序\n\n#include <stdio.h>\nchar fun(char *c)\n{\n     if(*c<=`Z`&& *c>=`A`)\n        *c-=`A`-`a`;\n     return *c;\n}\nmain()\n{\n    char s[81],*p=s;\n    gets(s);\n    while(*p)\n    {\n        *p = fun(p);\n        putchar( *p);\n        p++;\n    }\n    printf(\"\\n\");\n}\n若运行时从键盘上输入OPEN THE DOOR<回车>,程序的输出结果是?"
  },
  {
    "answer" : "简单区间动态规划，dp(l,r)表示在[l,r]这段区间先手能获得的最大值，dp(l,r)=sum(l,r)-min(dp(l+1,r), dp(l, r-1))，答案为max(dp(0,len), sum(0,len)-dp(0,len))，O(N^2)的时间和空间\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\nclass Solution {\npublic:\n \/**\n *  得到硬币博弈问题的获胜分值\n *  输入：代表硬币排列情况的数组arr\n *  返回：硬币博弈问题的获胜分值\n *\/\n int getWinValue(vector<int> arr, int len) {\n        if(len <= 0) return 0;\n        vector<int> sum(arr);\n        vector<vector<int> > dp(len, vector<int>(len, 0));\n        for(int i = 0; i < len; ++i){\n            if(i > 0) sum[i] += sum[i - 1];\n            dp[i][i] = arr[i];\n        }\n        for(int L = 1; L < len; ++L) for(int i = 0; i + L < len; ++i){\n            int j = i + L;\n            dp[i][j] = sum[j] - sum[i] + arr[i] - MIN(dp[i + 1][j], dp[i][j - 1]);\n        }\n        return sum[len - 1] - MIN(dp[0][len - 1], sum[len - 1] - dp[0][len - 1]);\n    }\n};",
    "ID" : "55f2e51de4b0152a61143344",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "面值为正数的硬币放置成一排，玩家1和玩家2轮流拿走硬币，规定每个玩家在拿硬币时，只能拿走最左或最右的硬币。 例如： 硬币面值与排列为：1,2,3,4,5，现在轮到玩家1拿硬币。 在当前状态下，玩家1只能拿走1或5， 如果玩家1拿走1，则排列变为2,3,4,5，那么接下来玩家2可以拿走2或5，然后继续轮到玩家1拿硬币... 如果玩家1拿走5，则排列变为1,2,3,4，那么接下来玩家2可以拿走1或4；然后继续轮到玩家1拿硬币... 游戏按照这个规则进行，直到所有的硬币被拿完，每个玩家获得的分数是各自拿走硬币的总和。 游戏胜负的规定： 如果玩家1最后获得的分数大于玩家2，则玩家1获胜； 如果玩家2最后获得的分数大于玩家1，则玩家2获胜； 因为玩家1先拿硬币，所以如果最后两人获得分数一样则玩家2获胜； 给定一个数组arr，表示硬币的面值和排列状况，请返回最终获胜者的分数。 例子： arr=[8,7,5,3] 玩家1将获胜，分数为13 所以返回13 arr=[1,9,1] 玩家2将获胜，分数为9 所以返回9"
  },
  {
    "ID" : "55f2e4fee4b0152a61143206",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "(unsigned long)(2-3)*1",
    "optionC" : "sizeof(3)<<(sizeof(2)<<(sizeof(1)))",
    "optionAnswer" : "C",
    "answer" : "sizeof(1) sizeof(2) sizeof(3) 都是4 那么4*2^(4*(2^4)) = 2^ 66 大于D选项的2^32-1",
    "optionB" : "3<<(2<<sizeof(1))",
    "type" : "1",
    "optionA" : "2*3*sizeof(1)",
    "question" : "给你1、2、3 这三个数字，可以使用C的各种运算符，你能表示的最大的整数是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "*(a[1]+1)",
    "optionC" : "*(&a[1]+1)",
    "optionAnswer" : "C",
    "answer" : "在二维数组中a[1]表示的是a[1][0]的地址，数组在内存中连续存储，所以a[1]+1表示的是a[1][1]的地址，所以D可以取得正确的值；\n指针操作*(a+1)与a[1]等价，所以B也可以取得正确的值；\n二维数组在内存中是行优先存储的，所以A中a[0][0]的地址加5可以取得正确值；\nC选项错误，应改为*(&a[1][0]+1)，因为a[1]就表示a[1][0]的地址。",
    "optionB" : "*(*(a+1)+1)",
    "type" : "1",
    "optionA" : "*(&a[0][0]+5)",
    "question" : "int a[3][4]，下面哪个不能表示 a[1][1]?"
  },
  {
    "answer" : "系统前台：\n用JS监控input输入框的内容变化，用户输入或者删除字符（输入串的发生变化）就触发异步Javascript提交输入内容到后台，引发后台查询。然后再讲查询结果出现频率最高的前10条query展现给用户提示。\n\n系统后台：\n首先有26台服务器分别存储26个字母开头的query。所以首先要设计一个接收用户请求的服务器，这台服务器可以根据用户请求的首字母将查询请求分发给对应26台服务器中的一个（相当于查询请求的路由功能）。\n然后就是这26台查询服务器如何设计的问题了。\n假设query不超过10亿条，每个query不超过50字节。也就是query文件不超过50G，分在26台机器上也就是每台机器上的query文件不超过2G。\n每个机器上维护着一张哈希表，对于每条query, 在哈希表表中存放其地址。收到每个query做hash运算可以找到query对应的地址。对应每个query存储两项信息，即query本身和被查询次数，也就是类似query:times这样的存储格式。\n下面做预处理：26台机器都对自身存储的query进行遍历，分别找出a到z开头query出现频率最高的top10，这样的查询一次遍历就能找到，时间复杂度为O（N）。然后对找到的top10在内存中构建一个最小堆。其他非top10的query无需做排序处理。到这里预处理完成。\n然后说查询过程，查询分为两类，\n1，以给出搜索提示的异步Javascript提交的查询，这种查询直接返回最小堆中的10个query词条即可。\n2，用户最终提交的查询（即用户输入完毕点击搜索按钮提交的查询），这种查询的query是用户最终查询的词条，这样的查询应该引起后台存储的对应query频率的变化。当一个query到达的时候，先用hash运算找到他的位置和对应的频率，hash操作时间复杂度是O(1),然后对应的次数+1，然后用这个+1的次数与最小堆中首个元素比较，如果大于最小堆首个元素，与最小堆中首个元素交换，然后最小堆做更新操作，保证最小堆的特性。否则不操作。这样最小堆中维护的10个query始终是这台机器上频率最高的，查询时返回这10个query词条即可。",
    "ID" : "55f2e51de4b0152a6114333e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "实现一个简化的搜索提示系统。给定一个包含了用户query的日志文件，对于输入的任意一个字符串s，输出以s为前缀的在日志中出现频率最高的前10条query。\n由于是分布式系统，假设至少有26台机器，每个机器存储以26个字母开头的query日志文件（如机器1存的是a字母开头的，机器2存的是以b字母开头的……）\n每个机器上维护着一张哈希表，对于每条query, 在哈希表表中存放其地址（哈希地址为链式的），并对其进行排序，按频率由高到低进行排序。\n当用户进行搜索时，可以很快定位到某台机器，并根据哈希表，返回出现频率最高的前10条query。\n\n提示：\n1、可以预处理日志\n2、假设query不超过10亿条，每个query不超过50字节。\n3、考虑在大查询量的情况下如何实现分布式服务"
  },
  {
    "ID" : "55f2e4fee4b0152a61143236",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "read",
    "optionC" : "fgetc",
    "optionAnswer" : "D",
    "answer" : "read是UNIX或类UNIX系统中的系统函数，而fread才是C库里面的库函数",
    "optionB" : "scanf",
    "type" : "1",
    "optionA" : "printf",
    "question" : "下面的函数中哪个是系统调用而不是库函数？"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c06",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "virtual void tt(int){}",
    "optionC" : "virtual void tt(int)",
    "optionAnswer" : "A",
    "answer" : "当在基类中不能为虚函数给出一个有意义的实现时，可以将其声明为纯虚函数，实\n现由派生类完成。格式：virtual<函数返回类型说明符><函数名>(<参数表>)=0;。",
    "optionB" : "void tt(int)=0",
    "type" : "1",
    "optionA" : "virtual void tt()=0",
    "question" : "以下基类中的成员函数表示纯虚函数的是（）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bfa",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "9",
    "optionC" : "5",
    "optionAnswer" : "B",
    "answer" : "a(2)调用1次带参数的构造函数，b［3］调用3次无参数的构造函数，指针没有给它\n分配空间，没有调用构造函数。所以共调用构造函数的次数为4。",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "3",
    "question" : "假定AB为一个类，则执行“AB a(2), b［3］,*p［4］;”语句时调用该类构造函数的次数\n为（）"
  },
  {
    "answer" : "53",
    "ID" : "55f2e51de4b0152a6114335b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "由权值分别为3，8，6，2，5的叶子结点生成一棵哈夫曼树，它的带权路径长度为 "
  },
  {
    "ID" : "55f2e4fee4b0152a61143228",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "fork是clone的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等",
    "optionC" : "clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等",
    "optionAnswer" : "C",
    "answer" : "fork() 函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以 fork() 函数不带参数； clone() 函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以 clone() 函数带参数，没有复制的资源可以通过指针共享给子进程 ",
    "optionB" : "clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的。",
    "type" : "1",
    "optionA" : "clone和fork最大不同在于fork不再复制父进程的栈空间，而是自己创建一个新的。",
    "question" : "下列关于 clone 和 fork 的区别描述正确的有？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de809",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "有限次循环",
    "optionC" : "是无限循环",
    "optionAnswer" : "A",
    "answer" : "?循环判断为 0 即不满足循环条件",
    "optionB" : "循环体执行一次",
    "type" : "1",
    "optionA" : "循环体一次也不执行",
    "question" : "设m和n都是int类型，那么以下for循环语句，______.for(m=0,n=-1;n=0;m++,n++)\n    n++;"
  },
  {
    "answer" : "int FindMaxSubMin(BinTree *root)\n{\n    stack<BinTree*> s;\n    BinTree *p=root;\n    int MaxNode = p->data;\n    int MinNode = p->data;\n    while(p!=NULL||!s.empty())\n    {\n        while(p!=NULL)\n        {\n            s.push(p);\n            p=p->lchild;\n        }\n        if(!s.empty())\n        {\n            p=s.top();\n            if(p->data > MaxNode)\n            {\n                MaxNode = p->data;\n            }\n            if(p->data < MinNode)\n            {\n                MinNode = p->data;\n            }\n            s.pop();\n            p=p->rchild;\n        }\n }\n return abs(MaxNode - MinNode);\n }",
    "ID" : "55f2e51ce4b0152a61143331",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "写一个函数，输入一个二叉树，树中每个节点存放了一个整数值，函数返回这颗二叉树中相差最大的两个节点间的差值绝对值。请注意程序效率。"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c20",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "使用它创建对象数组时必须指定初始值",
    "optionC" : "使用它创建对象时要调用构造函数",
    "optionAnswer" : "D",
    "answer" : "new创建的对象数组不能指定初始值，所以调用无参的构造函数，选择D项",
    "optionB" : "使用它创建的对象或对象数组可以使用运算符delete删除",
    "type" : "1",
    "optionA" : "它可以用来动态创建对象和对象数组",
    "question" : "关于new运算符的下列描述中，错误的是（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c6c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "引用",
    "optionC" : "赋值",
    "optionAnswer" : "B",
    "answer" : "删除对象或结束程序时，自动调用析构函数。",
    "optionB" : "撤销",
    "type" : "1",
    "optionA" : "建立",
    "question" : "类的析构函数是对一个对象进行以下哪种操作时自动调用的是（）"
  },
  {
    "answer" : "public static int getCount(int sum){\n    int count = 0;\n    for(int i = 0; i <= sum\/5; i++){\n      for(int j = 0; j <= sum\/10; j++){\n        for(int k = 0; k <= sum\/20; k++){\n          for(int p = 0; p <= sum\/50; p++){\n            for(int q = 0; q <= sum\/100; q++){\n              if(5*i + 10*j + 20*k + 50*p + 100*q > sum){\n                continue;\n              } else if (5*i + 10*j + 20*k + 50*p + 100*q == sum){\n                System.out.println(i+\",\"+j+\",\"+k+\",\"+p+\",\"+q);\n                ++count;\n              }\n            }\n          }\n        }\n      }\n    }\n    return count;\n}",
    "ID" : "55f2e51de4b0152a6114337e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给你一个数小于1000000，分别用100,50,20,10,5块表示出来，有多少种表示方法。写出算法即可。"
  },
  {
    "ID" : "55f2e4fee4b0152a6114323b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "100,100",
    "optionC" : "4,100",
    "optionAnswer" : "A",
    "answer" : "对于形参char para[100]，其实参传递进来的是数组的地址，在32位系统中sizeof（para）=4\n对于指针p，是连续100字节空间的首地址，sizeof并不知道这个连续空间有多大，sizeof得到的是这个指针变量的大小，是4字节",
    "optionB" : "100，4",
    "type" : "1",
    "optionA" : "4，4",
    "question" : "下面函数的执行结果是输出\n\nfunc(char para[100])\n{\n    void *p = malloc(100);\n    printf(\"%d, %d\\n\", sizeof(para), sizeof(p));\n}"
  },
  {
    "ID" : "55f2e46ae4b0152a6114314c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "后缀一元运算符",
    "optionC" : "前缀一元运算符",
    "optionAnswer" : "C",
    "answer" : "首先可以判断是一元操作符。因为++和--有前缀和后缀两种形式，为了区分，要求在后缀形式加一个int参数。  const Fraction operator ++(int)   中 int不过是个哑元（dummy）,是永远用不上的，它只是用来判断＋＋是prefix  还是  postfix  。如果有哑元，则是postfix,否则，就是prefix 。 ",
    "optionB" : "二元运算符",
    "type" : "1",
    "optionA" : "无操作数的运算符",
    "question" : "在重载一个运算符为成员函数时，其参数表中没有任何参数，这说明该运算符是 （ ）。"
  },
  {
    "answer" : "任何人不必等的情况数 Cn=2N!\/(N!*N!*(N+1)) 总的情况数 T=2N!\/N!*N! 不必等的概率为：Cn\/T = 1\/(N+1)",
    "ID" : "55f2e51de4b0152a61143394",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "在有团购之前，大家都是现场买门票，公园的门票是5元，某天售票处开门时没有准备零钱。假设一天来购票的依次有2N个人，其中有N个人有5元零钱，其他N个人只有10元面值的钱；假设每人只买一张票。请问任何人都不必为找零而等待的概率是多少？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7ed",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "7",
    "optionC" : "8",
    "optionAnswer" : "C",
    "answer" : "首先注意for循环的控制条件,当b > = 20或者a >100则跳出for循环,也即b < 20且a < = 100时执行for循环;第一次进入循环a = 1,b = 1均满足循环条件,但b%3 = = 1条件满足,故执行b = b + 3,得到b = 4,注意有continue,所以后面语句不执行,直接跳到 a + +这个语句,所以第一次循环完之后a = 2,b = 4;进入第二轮循环,b%3 = = 1也是满足的,故再次b = b + 3,此轮循环执行之后a = 3,b = 7,进入下一轮。此后和前面循环同理,都是b%3 = = 1满足,因为每次都是加3,而之后又去模3,且都跳过for后面语句直接执行a + +,所以,一直循环到b = 22跳出for循环。此时a为8.综合起来就是,每次循环b增加3,a增加1,且当b > 22时跳出循环,结束程序。所以b从1增加到22,有(22-1)\/3 = 7,所以a = 1 + 7=8.因此c选项正确。",
    "optionB" : "9",
    "type" : "1",
    "optionA" : "10",
    "question" : "#include <stdio.h>\nmain()\n{ \n    int a, b;\n    for( a = 1,b = 1; a <= 100; a ++)\n    { \n        if( b >= 20) break;\n        if( b % 3 == 1)\n        { \n            b = b + 3; \n            continue;\n        }\n        b = b – 5;\n    }\n    printf(\"%d\\n\",a);\n}\n程序的输出结果是？"
  },
  {
    "ID" : "55f2e46ae4b0152a61143145",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "7",
    "optionC" : "5",
    "optionAnswer" : "D",
    "answer" : "位操作符，转化为二进制再运算",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "1",
    "question" : "C语言里i=5,j=7,请问i|j等于多少？"
  },
  {
    "answer" : "产生死锁的原因主要是：\n（1） 因为系统资源不足。\n（2） 进程运行推进的顺序不合适。\n（3） 资源分配不当等。\n产生死锁的四个必要条件：\n（1）互斥条件：一个资源每次只能被一个进程使用。\n（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n（3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。\n（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。",
    "ID" : "55f2e51de4b0152a61143364",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "数据库以及线程发生死锁的原理及必要条件，如何避免死锁"
  },
  {
    "ID" : "55f2e46ae4b0152a61143153",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "bBAb",
    "optionC" : "AbAb",
    "optionAnswer" : "D",
    "answer" : "void f( char* c, char d ){\n    *c = *c + 1;\n    d = d + 1;\n    cout<< *c << d;\n}\nvoid main( ){\n    char a = 'A', b = 'a';\n    f( &b, a);\n    cout<<a<<b<<endl;\n}\nf(&b,a)中打印 \"bB\"\ncout<<a<<b<<endl;打印\"Ab\"，因为 f函数 通过指针改变了b的值，但是a只是作为d的一个副本并没有改变。",
    "optionB" : "aBaB",
    "type" : "1",
    "optionA" : "BaBa",
    "question" : "下面一段代码的输出结果是\n\nvoid f ( char* c, char d ){\n    *c = *c + 1;\n    d = d + 1;\n    cout<< *c << d;\n}\nvoid main( ){\n    char a = 'A' , b = 'a';\n    f ( &b, a);\n    cout<<a<<b<<endl;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a6114324f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "字符a的起始地址",
    "optionC" : "字符o",
    "optionAnswer" : "A",
    "answer" : "这是一个关于二维数组指针的问题。\n假设定义一个int型的二维数组指针。\nint Sec[2][3]={4,6,3,7,2,7};\nint **P = Sec; \n**p 等价 Sec[0][0]  *p 等价 Sec[0]  *(p+n) 等价 Sec[n] *(*(p+n)+m) 等价 Sec[n][m]\n所以++m，为行数增加为afternoon一行，而*m输出整行。",
    "optionB" : "字符o的起始地址",
    "type" : "1",
    "optionA" : "afernoon",
    "question" : "以下程序的输出结果是：\n\n#include <iostream.h>\nvoid func(char **m){\n    ++m;\n    cout<<*m<<endl;\n}\nint main(){\n    static char *a[]={\"morning\", \"afternoon\", \"evening\"};\n    char **p;\n    p=a;\n    func(p);\n    return 0;\n}"
  },
  {
    "answer" : "66.70%",
    "ID" : "55f2e51ee4b0152a611433e1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "到商店里花 200块钱买商品返还 100 优惠券(可以在本商店代替现金)。请问实际上折扣是多少?"
  },
  {
    "ID" : "55f2e46ae4b0152a61143160",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int ch<='9'  0",
    "optionC" : "char   ch<='9'  0",
    "optionAnswer" : "B",
    "answer" : "char   ch<='9'   ‘0’ \n解析：1，返回的是转换后的字符，因此是char\n2，判断字符在’0’到’9’范围内，因此是 ch<=’9’\n3，’9’-ch 得到的是两个字符之间的差值，是整型，要转成对应的字符要+’0’，在括号内为j减",
    "optionB" : "char   ch<='9'  '0'",
    "type" : "1",
    "optionA" : "int ch<='9'  '0'",
    "question" : "下列给定程序中，函数fun的功能是:进行数字字符转换。若形参ch中是数字字符'0'～'9',则将'0'转换成'9','1'转换成'8', '2'转换成'7',…, '9'转换成'0';如果是其他字符则保持不变，并将转换后的结果作为函数值返回。 \n请在程序的下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。 \n试题程序。\n\n#include<stdio.h>\n_____ fun(char ch)\n{\n    if(ch>='0'&& _______)\n        return'9'-(ch- ______);\n    return ch;\n}\nmain( )\n{ \n    char c1,c2;\n    printf(\"\\nThe result:\\n\");\n    c1='2';\n    c2=fun(c1);\n    printf(\"c1=%c c2=%c\\n\",c1,c2);\n    c1='8';\n    c2=fun(c1);\n    printf(\"c1=%c c2=%c\\n\",c1,c2);\n    c1='a';\n    c2=fun(c1);\n    printf(\"c1=%c c2=%c\\n\",c1,c2);\n}"
  },
  {
    "answer" : "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Scanner;\n \nclass ByValueComparator implements Comparator<String>{\n    HashMap<String, Integer> base_map;\n    public ByValueComparator(HashMap<String,Integer> map) {\n        \/\/ TODO Auto-generated constructor stub\n        this.base_map = map;\n    }\n    @Override\n    public int compare(String str1, String str2) {\n        \/\/ TODO Auto-generated method stub\n        if(!base_map.containsKey(str1) || !base_map.containsKey(str2)){\n            return 0;\n        }\n        if(base_map.get(str1) < base_map.get(str2)){\n            return 1;\n        }else{\n            \/\/相等也要返回-1，否则在排序时不会把相等的值放到TreeMap中，若=0则新值替代原值\n            \/\/为何相等是返回-1不是返回1，根据情况而定，返回1代表新值放到旧值前面，-1代表新值放在旧值后面\n            return -1;\n        }\n    }\n}\npublic class juan1_q2 {\n    public static void main(String[] ags){\n        HashMap<String, Integer> recMap = new HashMap<String, Integer>();\n        Scanner input = new Scanner(System.in);\n        String file = \"\";\n        int errorLine = 0;\n        int lastIndex = 0;\n        String recName = null;\n        while(input.hasNext()){\n            file = input.next();\n            errorLine = input.nextInt();\n            lastIndex = file.lastIndexOf(\"\\\\\");\n            recName = (lastIndex < 0)?file:file.substring(lastIndex+1)+\" \"+errorLine;\n            int count = 0;\n            if(!recMap.containsKey(recName)){\n                recMap.put(recName, 1);\n            }else{\n                count = recMap.get(recName);\n                recMap.put(recName, count+1);\n            }\n        }\n        input.close();\n        \/\/--------以上统计，以下排序取值-------------\n        ArrayList<String> keys = new ArrayList<String>(recMap.keySet());\n        ByValueComparator bvc = new ByValueComparator(recMap);\n        Collections.sort(keys, bvc);\n        for(int i = 0;i < (keys.size() > 8?8:keys.size());i++){\n            String key = keys.get(i);\n            StringBuilder res ",
    "ID" : "55f2e51ce4b0152a61143325",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "开发一个简单错误记录功能小模块，能够记录出错的代码坐在的文件名称和行号。 \n处理:\n1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)\n2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并)\n3.输入的文件可能带路径，记录文件名称不能带路径"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143275",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0，0",
    "optionC" : "1，0",
    "optionAnswer" : "A",
    "answer" : "const修饰的常量值具有不可变性,c++编译器通常会对该变量做优化处理，在编译时变量i的值为已知的，编译器直接将printf输出的变量i替换为0。尽管如此，编译器仍然会为变量i分配存储空间，通过修改内存的hack方式将变量i在内存中的值修改后并不影响printf的输出。\n如果将i更改为volatile const int类型的，编译器就不会对变量i做优化，printf输出的结果就为1。",
    "optionB" : "1，1",
    "type" : "1",
    "optionA" : "0，1",
    "question" : "在c++中，\n\nconst int i = 0; \nint *j = (int *) &i; \n*j = 1; \nprintf(\"%d,%d\", i, *j)\n输出是多少？"
  },
  {
    "ID" : "55f2e469e4b0152a61143142",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "6，6，4",
    "optionC" : "6，4，4",
    "optionAnswer" : "B",
    "answer" : "sizeof(str),str是字符数组，所以第一个是7个字节\nsizeof(p), str的首元素地址赋给指针p，指针总占4个字节\nsizeof(n), int型整数，所以4个字节",
    "optionB" : "7，4，4",
    "type" : "1",
    "optionA" : "4，4，4",
    "question" : "下面函数的执行结果是输出\nchar str[]=”xunlei”;\nchar *p=str;\nint n=10;\nprintf(“%d,%d,%d\\n”,sizeof(str),sizeof(p),sizeof(n));"
  },
  {
    "answer" : "int getMax(int a[],int len)\n{  \n   int max1 = a[0];\/\/表示maxSum(n-2);  \n   int max2 = a[0]>a[1]? a[0]:a[1]; \/\/表示maxSum(n-1);  \n   int max3 = 0; \/\/ n \n   for(int i =2; i<len; i++){    \n    max3 = Max(a[i],Max(max1+a[i],max2));\n\/\/       max3 = a[i]+max1> max2 ? a[i]+max1:max2;  \/\/ 全部是负数也需要考虑的,这个没有\n        max1 = max2; \n        max2  = max3; \n   } \nreturn max3;\n}\n\nint Max(int a,int b){\nif(a>b)\nreturn a;else\nreturn b;\n}",
    "ID" : "55f2e51de4b0152a61143347",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个整数的数组，相邻的数不能同时选，求从该数组选取若干整数，使得他们的和最大，要求只能使用o(1)的空间复杂度。要求给出伪码。"
  },
  {
    "ID" : "55f2e469e4b0152a61143138",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "None of the above",
    "optionC" : "const static\/static",
    "optionAnswer" : "B",
    "answer" : "static int为静态变量，它的值始终保存在内存里，也就是上一次改变后的值",
    "optionB" : "–\/static",
    "type" : "1",
    "optionA" : "static\/const    const\/static",
    "question" : "Fill the blanks inside class definition\n\nclass Test {\n    public:\n         ____ int a;\n         ____ int b;\n    public:\n        Test::Test(int _a, int _b) : a(_a) {\n            b = _b;\n         }\n};\nint Test::b;\nint _tmain(int argc, __TCHAR *argv[]) {\n    Test t1(0, 0), t2(1, 1);\n    t1.b = 10;\n    t2.b = 20;\n    printf(“%u %u %u %u”, t1.a, t1.b, t2.a, t2.b);\n}\nRunning result: 0 20 1 20"
  },
  {
    "ID" : "55f2e469e4b0152a61143141",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int const *x = &y;",
    "optionC" : "const int *x = &y;",
    "optionAnswer" : "B",
    "answer" : "A，指针所指向的内存不可变，内存中的值也不能通过指针改变，错误；\nB，指针所指向的内存不可变，内存中的值可以改变，正确；\nC，指针所指向的内存可变，但内存中的值不能通过指针改变，错误；\nD，指针所指向的内存可变，但内存中的值不能通过指针改变，错误；",
    "optionB" : "int * const x = &y;",
    "type" : "1",
    "optionA" : "const int const *x = &y;",
    "question" : "请声明一个指针，其所指向的内存地址不能改变，但内存中的值可以被改变。"
  },
  {
    "ID" : "55f2e4fee4b0152a6114322a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类模板中的成员函数全部都是模板函数",
    "optionC" : "类模板的参数必须是虚拟类型的",
    "optionAnswer" : "D",
    "answer" : "A：下面列举的几种情况不能省略模板实参：\n1）从模板函数实参表获得的信息有矛盾之处。\n2）需要获得特定类型的返回值，而不管参数的类型如何。\n3）虚拟类型参数没有出现在模板函数的形参表中。\n4）函数模板含有常规形参。\nB：类模板与模板类的概念\n⑴ 什么是类模板 一个类模板（也称为类属类或类生成类）允许用户为类定义一种模式，使得类中的某些数据成员、默写成员函数的参数、某些成员函数的返回值，能够取任意类型（包括系统预定义的和用户自定义的）。\n  如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。\n⑵ 模板类是类模板实例化后的一个产物。可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。\n类模板的重点是模板。表示的是一个模板，专门用于产生类的模子。 模板类的重点是类。表示的是由一个模板生成而来的类。 \nC：类模板有三种类型模板参数：类型模板参数、无类型模板参数和模板模板参数(以模板作为模板的参数)。并不局限于虚拟类型，非虚拟类型也可以作为类模板参数。",
    "optionB" : "类模板与模板类所指的是同一概念",
    "type" : "1",
    "optionA" : "模板的实参在任何时候都可以省略",
    "question" : "下列关于模板的说法正确的是"
  },
  {
    "answer" : "函数原型为：int sprintf(char *str, const char *format, ...);\nint snprintf(char *str, size_t size, const char *format, ...);\nsnprintf中的size用来限定str可用空间的大小，防止str的内存越界。",
    "ID" : "55f2e51ce4b0152a61143335",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "sprinf和snprintf函数区别是"
  },
  {
    "ID" : "55f2e4fee4b0152a61143246",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "10,30，30",
    "optionC" : "20,30，10",
    "optionAnswer" : "A",
    "answer" : "用c++编译是答案A，用c编译会报错，c++有引用这东西",
    "optionB" : "10，20，30",
    "type" : "1",
    "optionA" : "20，30，30",
    "question" : "下面这段代码的输出结果为：\n\n#include<stdio.h>\nvoid change(int*a, int&b, int c)\n{\n      c=*a;\n      b=30;\n      *a=20;\n}\nint main ( )\n{\n      int a=10, b=20, c=30;\n      change(&a,b,c);\n      printf(“%d,%d,%d,”,a,b,c)；\n      return 0；\n }"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143272",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0x102 ， 0x506 ， 0x102030405060708 ， 0x0",
    "optionC" : "0x201 ， 0x605 ， 0x4030201 ， 0x8070605",
    "optionAnswer" : "B",
    "answer" : "小端机器的数据高位字节放在高地址，低位字节放在低地址。x86结构为小端模式。\npshort占用2个字节，在内存中的16进制为0x01 0x02，对应的16进制数为0x0201。\npshort + 2指向array数组的下标为4的元素，占用2个字节，在内存中的16进制为0x05 0x06，对应的16进制数为0x0605。 \npint64的int64类型不确定，但根据名字可以看出占用8个字节，对应的16进制形式为0x807060504030201。\npint  + 2占用4个字节，指向的array数组的下标为8的元素，8-11个元素没有指定数组的初始化值，默认为0，因此*(pint + 2)对应的16进制为0。",
    "optionB" : "0x201 ， 0x605 ， 0x807060504030201 ， 0x0",
    "type" : "1",
    "optionA" : "0x201 ， 0x403 ， 0x807060504030201 ， 0x0",
    "question" : "在32位小端的机器上，如下代码输出是什么：\n\nchar array[12] = {0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08};     \n short *pshort = (short *)array;     \n int *pint = (int *)array;     \n int64 *pint64 = (int64 *)array;     \n printf(\"0x%x , 0x%x , 0x%llx , 0x%llx\", *pshort , *(pshort+2) , *pint64 , *(pint+2));"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c1e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "实参与形参是同一对象",
    "optionC" : "形参是实参的备份",
    "optionAnswer" : "D",
    "answer" : "地址作为实参，表示实参与形参代表同一个对象。如果实参是数值，形参也是普通\n变量，此时形参是实参的备份。所以选择D项。",
    "optionB" : "实参与形参无联系",
    "type" : "1",
    "optionA" : "实参是形参的备份",
    "question" : "使用地址作为实参传给形参，下列说法正确的是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143216",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都是",
    "optionC" : "catch (A & x)",
    "optionAnswer" : "D",
    "answer" : "题目中问的是能否通过编译，只有B会捕获到异常，进行异常处理，而A和C由于和throw抛出的异常类型不匹配，导致这个异常不被捕获，从而成为未捕获的异常，调用terminate函数结束程序。",
    "optionB" : "catch (A * x)",
    "type" : "1",
    "optionA" : "catch (A && x)",
    "question" : "如何捕获异常可以使得代码通过编译？\n\nclass A {\n  public:\n        A(){}\n};\nvoid foo(){\n    throw new A;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a61143204",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "p2++;",
    "optionC" : "p2[2] = ‘l’;",
    "optionAnswer" : "A",
    "answer" : "p1是指向字符常量的指针，p1本身不是常量，所以p1++合法，A正确。\np2本身是指针常量，可以指向非常量的字符。但是\"hello\"这样声明的字符串是存储在只读存储区的，不可修改，所以B,C,D都错误。",
    "optionB" : "p1[2] = ‘w’;",
    "type" : "1",
    "optionA" : "p1++;",
    "question" : "给出以下定义，下列哪些操作是合法的？\nconst char *p1 = “hello”;\nchar *const p2 = “world”;"
  },
  {
    "ID" : "55e6d85be4b0152a610de828",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "5",
    "optionC" : "3",
    "optionAnswer" : "B",
    "answer" : "mod运算，即求余运算，是在整数运算中求一个整数n除以另一个整数p的余数的运算，且不考虑运算的商",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "0",
    "question" : "执行完a=5 mod 3 语句后，a的值为？"
  },
  {
    "answer" : "TOP-K问题，用个数为K的最小堆归并处理",
    "ID" : "55f2e51de4b0152a61143368",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有20个数组，每个数组有500个元素，并且是有序排列好的，现在在这20*500个数中找出排名前500的数。"
  },
  {
    "answer" : "动态规划。\n\n字符串 A, B, 记录结果为二维数组R[n][m] （其中n，m为A， B的长度）\nA 变换到 B 可以通过 如下 3个操作：\n添加。即已知A[0..i]变化到B[0..j-1]的最小操作次数，最后加上 B[j]即可。 R[[i][j] = R[i][j-1] + 1 (添加操作代价为1）\n删除。即已知A[0..i-1]变化到B[0..j]的最小操作次数， 最后删掉A[i]即可。 R[i][j] = R[i-1][j] + 1（删除操作代价为1）\n替换。即已知A[0..i-1]变化到B[0..j-1]的最小操作次数， 最后替换A[i]为B[j]即可。 R[i][j] = R[i-1][j-1] + 1（替换操作代价为1）\n公式为：\nR[[i][j] = min ( R[i][j-1] + 1, R[i-1][j] + 1,  R[i-1][j-1] + 1) \n\n当i或者j为0时， 相应地值为字符串长度（因为从一个字符串变成长度为0的字符串的代价为这个字符串的长度）。\n动态规划求出R[n][m]就可以了。\n\n时间复杂度O（nm)， 空间复杂度O（nm）（其实就是计算出R[n][m]这个数组）\n\n替换代价变为2的时候， 公式改为：\nR[[i][j] = min ( R[i][j-1] + 1, R[i-1][j] + 1,  R[i-1][j-1] + 2) ",
    "ID" : "55f2e51de4b0152a6114335c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "编辑距离，又称Levenshtein距离，是指两个子串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。请尝试写出一个算法来计算两个字符串的编辑距离，并计算其复杂度？在某些应用场景下，替换操作的代价比较高，假设替换操作的代价是插入和删除的两倍， 算法该如何调整？"
  },
  {
    "ID" : "55f2e469e4b0152a61143134",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "一个抽象类和接口中的方法必须是抽象方法",
    "optionC" : "纯虚函数和虚函数的区别在于前者不包含定义，而后者可以包含函数体。",
    "optionAnswer" : "D",
    "answer" : "抽象类 ： 类中至少有一个方法是抽象方法，则该类就是抽象类\n接口 ：类中的方法全部都是抽象方法。 ",
    "optionB" : "c++中没有接口的概念，与之对应的是纯虚类，对应的是java的接口",
    "type" : "1",
    "optionA" : "c++虚类相当与java里面的抽象类",
    "question" : "下述有关c++的虚类和java接口的描述，说法错误的是？"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c64",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "过程",
    "optionC" : "文件",
    "optionAnswer" : "B",
    "answer" : "面向过程的和面向对象都具有、函数、文件和过程这些概念，而面向对象程序才有\n类和对象的特征。所以选择B。",
    "optionB" : "类",
    "type" : "1",
    "optionA" : "函数",
    "question" : "在面向对象的程序设计中，首先在问题域中识别出若干个 （）"
  },
  {
    "answer" : "18",
    "ID" : "55f2e51de4b0152a61143361",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "n从1开始，每个操作可以对n加1或加倍，如果要使n是2014，最少需要___个操作"
  },
  {
    "ID" : "55f2e4fee4b0152a611431fc",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "D",
    "optionC" : "C",
    "optionAnswer" : "B",
    "answer" : "因为while(page.taglst[i] == \"<br>\" && i < taglen)这个判断，先执行page.taglst[i] == \"<br>\"这个判断，如果这个判断返回值为true，再执行i < taglen这个判断。当i=taglen的时候，执行page.taglst[i] == \"<br>\"这个判断就会越界，所以B处，最先出现越界",
    "optionB" : "B",
    "type" : "1",
    "optionA" : "A",
    "question" : "处理a.html文件时，以下哪行伪代码可能导致内存越界或者抛出异常（）\n\n         int totalBlank = 0;\n         int blankNum = 0;\n         int taglen = page.taglst.size();\nA       for(int i = 1; i < taglen-1; ++i)\n        {\n                 \/\/check blank\nB             while(page.taglst[i] == \"<br>\" && i < taglen)\n               {\nC                       ++totalBlank;\nD                       ++i;\n               }\nE             if(totalBlank > 10)\nF                      blankNum += totalBlank;\nG             totalBlank = 0;\n        }\n注意：以下代码中taglen是html文件中存在元素的个数，a.html中taglen的值是15，page.taglst[i]取的是a.html中的元素，例如page.taglst[1]的值是<html>\na.html的文件如下：\n<html>\n<title>test<\/title>\n<body>\n<div>aaaaaaa<\/div>\n<\/body>\n<\/html>\n<br>\n<br>\n<br>\n<br>\n<br>"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143258",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1,1",
    "optionC" : "1,0",
    "optionAnswer" : "B",
    "answer" : "&可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作。\n&&是表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true",
    "optionB" : "0,1",
    "type" : "1",
    "optionA" : "0,0",
    "question" : "以下的C程序代码片段运行后c和d的值分别是多少()\nint a =1,b =2;\nint c,d;\nc =(a&b)&&a;\nd =(a&&b)&a;"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c8d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "cba",
    "optionC" : "cab",
    "optionAnswer" : "A",
    "answer" : "本题考查的是在继承中派生类的对象调用构造函数的顺序，应该是先调用基类的构造函数，然后是成员中的对象对应类的构造函数，最后是派生类自己的构造函数。",
    "optionB" : "acb",
    "type" : "1",
    "optionA" : "abc",
    "question" : "建立派生类对象时，3种构造函数分别是a(基类的构造函数)、b(成员对象的构造函数)、c(派生类的构造函数)这3种构造函数的调用顺序为"
  },
  {
    "answer" : "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char *a, char *b) \n{\nif (a != b) {\nchar c = *a;\n*a = *b;\n*b = c;\n}\n}\n\nvoid dfs(char *str, int kth, int len)\n{\nif (kth == len) {\nprintf(\"%s\\n\", str);\nreturn;\n}\n\nfor (int i = 0; i <= kth; ++i) {\nswap(&str[i], &str[kth]);\ndfs(str, kth + 1, len);\nswap(&str[i], &str[kth]);\n}\n}\n\nint main(void)\n{\nchar str[] = \"abc\";\ndfs(str, 0, strlen(str));\n}",
    "ID" : "55f2e51ee4b0152a611433c9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "用c++写一个函数，如Foo(const char *str)，打印出str的全排列，如abc的全排列：abc, acb, bca, dac, cab,cba"
  },
  {
    "answer" : "解析：首先分析一下这个数组，假设其中某个位置的A[i] = i，那么可以肯定的值，之前的A[x] > x，之后的A[x] < x。还有一个显而易见的性质就是中间的A[i]=i一定是连续存在的，不可能跨区域存在，因为这个数组是升序的。\n我给出的方法是二分查找，具体的做法是：我们假设一个新数组B，其元素是A[i] - i的值，这样的话，B[i] = 0的时候A[i] = i，而且把B数组划分成了三个部分，左边的小于零的区域，中间的等于零的区域，右边的大于零的区域。\n我第一次的想法是：二分搜索这个想象中的新数组，找到值为零的下标，但是这个下标不一定是最左边的满足条件的下标，所以我们还需要写一个while来往左移动这个下标，直到找到最左边的符合条件的下标，如下代码（假设已经通过二分查找找到了符合条件的一个下标idx）：\n\nwhile(A[idx-1] == (idx-1))\n     idx--;\n这样的话其时间复杂度就是O(logn) + O(n)，还是属于On)的范畴。\n后来我想到，为什么只去随机命中一个目标下标呢！如果二分查找这个数据的边界的话，就能直接得到最左边符合条件的下标了！其实二分查找不仅仅适用于对一个元素的搜索，也可以用于两个、三个特定相对位置元素的搜索。每次查找的时候，假设当前位置是mid，那么只要判断当前A[mid] - mid是否小于零，以及后一个元素A[mid+1] - (mid+1) == 0就行了。\n\n#include  <iostream> \nusing namespace std; \n   \nint BinarySearch(int cc[], int len) \n{ \n   int l = 0, r = len, mid; \n   while (l <= r) \n   { \n      mid = l + ((r-l) >> 1); \n      if(mid == 0 && cc[mid] == mid)   \/\/ 若数组一开始就符合条件 \n         return 0; \n      \/\/ 若满足条件的下标不是从0开始，则边界是前一个<0，且后一个=0 \n      if (cc[mid]-mid < 0 && cc[mid+1]-(mid+1) == 0) \n         return mid+1; \n      \/\/ 二分查找边界：前一个<0，且后一个=0 \n      if (cc[mid] - mid >= 0) \n         r = mid-1; \n      else \n         l = mid+1; \n   } \n   return -1; \n} \n   \nint main() \n{ \n   \/\/ int cc[] = {0, 1}; \n   \/\/ int cc[] = {0, 1, 2, 3, 4, 5, 6, 7}; \n   \/\/ int cc[] = {-9, -8, -4, -2, 4, 5, 9}; \n   \/\/ int cc[] = {-5, -4, -3, 5, 6, 7}; \n   int len = sizeof(cc)\/sizeof(int); \n   int idx = BinarySearch(cc, len); \n   if(idx != -1) \n   { \n      while(cc[idx] == idx) \n      { \n         printf(\"%d \", idx); \n         idx++; \n      } \n   } \n   else \n   { \n      printf(\"Not found\\n\"); \n   } \n   \n   getchar(); \n   return 0; \n} \n\nOK! 由于程序是原生的二分查找，所以时间复杂度为O(logn)，没有占用额外的空间。并且不需要区分正整数还是负整数，数据类型也可以改成double没问题。",
    "ID" : "55f2e51de4b0152a6114336d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个排好升序的数组A[1]、A[2]、……、A[n]，其元素的值都两两不相等。请设计一高效的算法找出中间所有A[i] = i的下标。并分析其复杂度。（不分析复杂度不得分）"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114326e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "4 6",
    "optionC" : "6 5",
    "optionAnswer" : "D",
    "answer" : "本题主要考查了指向字符串的指针和字符数组,strl为一个字符指针,所以sizeof为4,str2为字符数组,其中包含6个字符,所以答案为4 6",
    "optionB" : "5 5",
    "type" : "1",
    "optionA" : "5 6",
    "question" : "在32位编译器上,设有定义\nchar * strl = \"Hello\",str2[ ] = \"Hello\";\n则以下语句\nprintf(\"%d %d\",sizeof(str),sizeof(str2));\n的输出结果是"
  },
  {
    "ID" : "55f2df83e4b0152a61142d40",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "11111001",
    "optionC" : "11111000",
    "optionAnswer" : "D",
    "answer" : "一般用取模的方式更符合计算机规则：（2^n-|x|），  8为二进制，100000000-00000111=11111001;",
    "optionB" : "1111001",
    "type" : "1",
    "optionA" : "1111000",
    "question" : " -7的二进制补码表示为："
  },
  {
    "answer" : "1、将140克盐放天平两边平分两份各70克；\n2、将一份70克盐平分两份各35克；\n3、将7克和2克砝码各方天平一侧，取一份35克盐向天平两端加知道左右平衡，此时与7克砝码一侧为15克盐，与2克砝码一侧为20克盐；\n4、此时20克盐加70克盐为90克，剩余合并为50克。",
    "ID" : "55f2e51de4b0152a6114337f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有7克，2克砝码各一个，天平一只，如何只用这些物品3次将140的盐分为50、90克各一份？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de811",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "19",
    "optionC" : "16",
    "optionAnswer" : "D",
    "answer" : "5*3+4=19",
    "optionB" : "35",
    "type" : "1",
    "optionA" : "23",
    "question" : "下列程序的输出是：（ ）#define add(a,b) a+b\nint main()\n{\n    printf(“ % d\\n”, 5 * add(3, 4));\n    return 0;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a6114323a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "o(N!)",
    "optionC" : "O(N^2)",
    "optionAnswer" : "A",
    "answer" : "可以配合自己画的流程图看\nx=1    O(1)\nx=2    O(1+O(foo(1)))=O(2)\nx=3    O(1+O(foo(2)))=O(3)\n。。。依次类推\nx=N    O(1+O(foo(N-1)))=N",
    "optionB" : "O(N^2)",
    "type" : "1",
    "optionA" : "O(N)",
    "question" : "下面函数的时间复杂度是\n\nlong foo(long x){\n    if(x<2) return 1;\n        return x*x*foo(x-1);\n}"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c1c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "嵌套函数",
    "optionC" : "递归函数",
    "optionAnswer" : "A",
    "answer" : "内联函数特征代码少，频繁调用，执行效率高。重载函数解决统一接口的问题；递\n归是子程序调用，程序调用要耗费很多空间和时间，循环\/迭代都比递归有效率得多，递归只是\n从形式上，逻辑比较简洁。嵌套函数即反复调用，速度较慢。所以选择A项。",
    "optionB" : "重载函数",
    "type" : "1",
    "optionA" : "内联函数",
    "question" : "一个函数功能不太复杂，但要求被频繁调用，则应把它定义为 （）"
  },
  {
    "ID" : "55f2e46ae4b0152a61143147",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "(**pp) = \\\\c\\\\;",
    "optionAnswer" : "A",
    "answer" : "【解析】\n相当于\n(char const) (* const) *pp\n所以\n**p是char型常量\n*p是char const *型常量\np是char const *const型变量",
    "optionB" : "(*pp)++",
    "type" : "1",
    "optionA" : "pp++",
    "question" : "给定声明 const char * const * pp; 下列操作或说明正确的是?"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7fb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "12",
    "optionC" : "22",
    "optionAnswer" : "D",
    "answer" : "p存放的是a的地址\nk 存放的是p指针的地址\np++ p指针存放的内容改变了，k的指向没有变，但K的值改变了。",
    "optionB" : "21",
    "type" : "1",
    "optionA" : "11",
    "question" : "turbo c环境下，下面程序运行的结果是()int main()\n{\n    printf(\"\\n\");\n    int a[5] = {1, 2, 3, 4, 5};\n    int *p, **k;\n    p = a;\n    k = &p;\n    printf(\"%d\", *(p++));\n    printf(\"%d\", **k);\n    return 0;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a6114321a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "定义了一个名为pt的指针变量，它可以指向每行有三个整数元素的二维数组",
    "optionC" : "定义了一个名为*pt、具有三个元素的整型数组",
    "optionAnswer" : "D",
    "answer" : "int (*pt)[3]，首先看括号内，*pt说明pt是一个指针，其指向的内容是int[3]，具有3个int元素的数组。\nD选项说，可以指向每行有三个整数元素的二维数组，即int[][3]。\nint(*pt)[3] = NULL;\nint arr[2][3] = {0};\npt = arr;\n",
    "optionB" : "定义了基类型为int的具有三个元素的指针数组pt",
    "type" : "1",
    "optionA" : "定义了基类型为int的三个指针变量",
    "question" : "若有定义int（*pt）[3]；则下列说法正确的是："
  },
  {
    "ID" : "55f2e469e4b0152a6114313b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "都可以修复编译错误",
    "optionC" : "都不能修复编译错误",
    "optionAnswer" : "D",
    "answer" : "这题选C GetValue() 没有返回类型",
    "optionB" : "改变成员函数\"GetValue\"的声明，以使其不是const的",
    "type" : "1",
    "optionA" : "改变成员变量\"vv\"为\"mutable int vv\"",
    "question" : "以下代码编译有错误，哪个选项能解决编译错误？\n\nclass A {\n    public:\n        int GetValue() const {\n            vv = 1;\n            return vv;\n         }\n    private:\n        int vv;\n};"
  },
  {
    "ID" : "55e6d85ae4b0152a610de80f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "hellotheword",
    "optionC" : "hello",
    "optionAnswer" : "B",
    "answer" : "a是指针的数组 \nchar** p = a; \/\/char** p = &a[0] \np++;\/\/p是指针自增+4，而a中元素是指针，每个正好四个字节，因此p++后恰好p= &a[1] *p=a[1];输出\"the\"，输出结果为B",
    "optionB" : "the",
    "type" : "1",
    "optionA" : "theworld",
    "question" : "下列程序的输出结果为：#include\nvoid main()\n{\n       char* a[ ] = { \"hello\", \"the\", \"world\"};\n       char** pa = a;\n       pa++;\n       cout<<”*pa<<endl;\n}"
  },
  {
    "answer" : "如果是有序的用二路归并求交集\n如果是无序的可以用map或hash",
    "ID" : "55f2e51de4b0152a61143372",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "A，B两个整数集合，设计一个算法求他们的交集，尽可能的高效。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143213",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "其他",
    "optionC" : "100",
    "optionAnswer" : "A",
    "answer" : "while（x）→当x为真（非0）时执行循环；\nx=x&(x-1);→&是位运算符，需要将x转化成二进制计算，当&两边都为1时,为1，否则为0，\n该题相当于求x的二进制式中含有1的个数，",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "8",
    "question" : "求下面函数的返回值。\n\nint func(x)\n {\n    int countx = 0;    \n     while (x)\n     {\n      countx ++;\n      x = x & (x - 1);\n     }\n     return countx;\n }\n\n假定x = 9999。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143210",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8 8",
    "optionC" : "100 100",
    "optionAnswer" : "A",
    "answer" : "string_a是一个char型的指针，在64位系统中sizeof（char*）=8\nstring_b是一个char型的数组，在64位系统中sizeof（char）=1，共100值因此为100",
    "optionB" : "100 8",
    "type" : "1",
    "optionA" : "8 100",
    "question" : "请问在64位平台机器下sizeof(string_a),sizeof(string_b)大小分别是（）?1.char *string_a=(char *)malloc(100*sizeof(char));\n2.char string_b[100];"
  },
  {
    "ID" : "55f2e4fee4b0152a6114320f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上都不对",
    "optionC" : "当函数代码较小并且被频繁调用的时候",
    "optionAnswer" : "C",
    "answer" : "内敛函数不适于while switch 这样复杂结构,且语句最好在1-5条这样的小型函数上. 递归不能定义为内联.",
    "optionB" : "当函数中有较多的静态变量的时候",
    "type" : "1",
    "optionA" : "当函数代码较长且多层嵌套循环的时候",
    "question" : "内联函数在以下场景中最有用的（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114320d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "22, 4, 100, 4",
    "optionC" : "22, 4, 4, 4",
    "optionAnswer" : "C",
    "answer" : "作为函数参数的数组名退化为指针",
    "optionB" : "4, 4, 4, 4",
    "type" : "1",
    "optionA" : "22, 22, 100, 100",
    "question" : "某32位系统下, C++程序如下所示，sizeof 的值应为？\n\nchar str[] = “http:\/\/www.renren.com”  （长度为21）\nchar *p = str ; \n请计算\n\nsizeof (str ) = ？（1）\nsizeof ( p ) = ？（2）\nvoid Foo ( char str[100]){\n    sizeof( str ) = ？（3）\n}\nvoid *p = malloc( 100 );\nsizeof ( p ) = ？（4）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c7d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数成员",
    "optionC" : "数据成员",
    "optionAnswer" : "A",
    "answer" : "类成员包括成员函数和数据成员，都可以使用访问权限public、private和protected来修\n饰,而普通的变量不能使用访问权限来说明。",
    "optionB" : "类成员",
    "type" : "1",
    "optionA" : "非类成员",
    "question" : "下列不具有访问权限属性的是（）"
  },
  {
    "answer" : "n-1",
    "ID" : "55f2e51de4b0152a61143353",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "（a1+a2+a3+…+an)\/b与a1\/b+a2\/b+…an\/b（除法为整除）最大差值为?"
  },
  {
    "answer" : "class Hanoi {\nprivate:\n  \n    int chk(vector<int>& arr, int k, const int from, const int pass, const int to){\n        if (k == 1){\n            if (from == arr[k - 1]) return 0;\n            if (to == arr[k - 1])   return 1;\n            return -1;\n        }\n  \n        if (arr[k - 1] == pass){\n            return -1;\n        }\n        if (arr[k - 1] == from){\n  \n            return chk(arr, k - 1, from, to, pass);\n        }\n        if (arr[k - 1] == to){\n            int tmp = chk(arr, k - 1, pass, from, to);\n            if (tmp == -1)\n                return -1;\n            return (1 << k - 1) + tmp;\n        }\n    }\npublic:\n    int chkStep(vector<int> arr, int n) {\n        \/\/ write code here\n        if (n <= 0)  return -1;\n        if (arr.size() != n)    return -1;\n        vector<int> cur(n, 1);\n  \n        if (arr[n - 1] == 2)    return -1;\n        return chk(arr, n, 1, 2, 3);\n    }\n};  从最后一个往前，chk(arr,k,from,pass,to)代表前k个塔移动到和arr一样时需要的步数。\nfrom代表第k个塔现在所处的位置，to代表第k个塔在当前状态（指第k+1个塔到第n个塔已依据arr排好）下经过最多的步数最后移动到哪。\n如果第k个塔的当前位置和arr第k个塔位置一致，不用移动第k个塔，但是第k-1个塔只能移动到pass这个地方；\n如果第k个塔和to一致，第k个塔移动到to需要1<<k-1个步骤，并且之后第1到k-2个塔初始状态都位于pass处，第k-2个塔最远能到达的位置就是第k-1个塔当前处在的位置；\n整个过程为O(n).",
    "ID" : "55f2e51ce4b0152a6114332d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一个int数组arr其中只含有1、2和3，分别代表所有圆盘目前的状态，1代表左柱，2代表中柱，3代表右柱，arr[i]的值代表第i+1个圆盘的位置。比如，arr=[3,3,2,1]，代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中柱上、第4个圆盘在左柱上。如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态。如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回-1。\n给定一个int数组arr及数组的大小n，含义如题所述，请返回一个int，代表所求的结果。\n测试样例：   输入：[3,3]    返回：3"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bf9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "3",
    "optionC" : " 变量p的地址值",
    "optionAnswer" : "D",
    "answer" : "*p代表引用a变量的值，p代表a的地址值。所以选择D项。",
    "optionB" : "无意义",
    "type" : "1",
    "optionA" : "变量a的地址值",
    "question" : "在int a=3,int *p=&a；中，*p的值是（）"
  },
  {
    "answer" : "#include<stdio.h>\n#include<string.h>\n#define N 100\n  \n\/\/LCS问题：即求两个字符串最长公共子串的问题，这里返回了公共字串，如果只求最长公共字串长度的话，之后有个简单的程序，其实就是里面的一部分\nchar *LCS(char *a,char *b)\n{\nint len_a = strlen(a);  \/\/获取字串的长度\nint len_b = strlen(b);\nchar *p;\nint c[N][N] = {0};      \/\/矩阵c记录两串的匹配情况\nint start,end,len,i,j;  \/\/start表明最长公共子串的起始点，end表明最长公共子串的终止点\nend = len = 0;          \/\/len表明最长公共子串的长度\nfor(i=0;i<len_a;i++)    \/\/串开始从前向后比较\n{\nfor(j=0;j<len_b;j++)\n{\nif(a[i] == b[j])\nif(i == 0 || j == 0)\nc[i][j] = 1;\nelse\nc[i][j] = c[i-1][j-1] + 1;\nif(c[i][j] > len)\n{\nlen = c[i][j];\nend = j;\n}\n}\n}\nstart = end - len + 1;\np = (char *)malloc(len+1); \/\/数组p记录最长公共子串\nfor(i=start;i<=end;i++)\np[i-start] = b[i];\np[len] = '\\0';\nfor(j=0;j<len_b;j++)\n{\nfor(i=0;i<len_a;i++)\nprintf(\"%2d\",c[i][j]);\nprintf(\"\\n\");\n}\nreturn p;\n}\nint main(int argc,char *argv[])\n{\nchar str1[N],str2[N];\nprintf(\"请输入字符串1：\");\ngets(str1);\nprintf(\"请输入字符串2：\");\ngets(str2);\nprintf(\"最长子串为：%s\\n\",LCS(str1,str2));\nreturn 0;\n}",
    "ID" : "55f2e51de4b0152a61143397",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "编写函数，获取两段字符串的最长公共子串的长度，例如： \nS1= GCCCTAGCCAGDE \nS2= GCGCCAGTGDE \n这两个序列的最长公共子串是GCCAG，也就是说返回值。 \n1）请先描述思路；\n2）编写完整代码实现，编程语言不限。"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c0c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "不确定",
    "optionC" : "float",
    "optionAnswer" : "B",
    "answer" : "考察数据的转换，j是double类型，运算只能作同类型的运算，所以要转换，而int能自动\n转换为double类型，所以结果是double类型。",
    "optionB" : "double",
    "type" : "1",
    "optionA" : "int",
    "question" : "设有定义int i;double j＝5;，则10+i+j值的数据类型是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f7",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "segmentation fault",
    "optionC" : "输出\"\"",
    "optionAnswer" : "D",
    "answer" : "调用getmemory(str)后，在test函数内的局部变量str并未产生变化。?strcpy?(?str?,”?hello?,?world?”);?写越界，造成segmentation fault。",
    "optionB" : "输出\"hello world\"",
    "type" : "1",
    "optionA" : "编译错误",
    "question" : "void getmemory(char *p)\n{\n    p=(char*)malloc(100);\n}\nvoid test(void)\n{\n   char * str = null;\n   getmemory(str);\n   strcpy(str,”hello,world”);\n   printf(str);\n}\n请问运行test函数会有什么样的结果？ "
  },
  {
    "ID" : "55f2e469e4b0152a6114313a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数不能自己调用自己",
    "optionC" : "函数在被调用之前必须先声明",
    "optionAnswer" : "C",
    "answer" : "函数可以没有参数的，  A排除\n函数的返回类型可以是void 不需要返回值，  B排除\n递归函数可以自己调用自己  D排除\n\n函数在被调用之前都必须先声明。  正确C",
    "optionB" : "每个函数都必须返回一个值",
    "type" : "1",
    "optionA" : "每个函数至少要有一个参数",
    "question" : "在下列关于C++函数的叙述中，正确的是（??????）"
  },
  {
    "answer" : "a)     Hadoop\n基于分布式文件系统HDFS的分布式批处理计算框架。适用于数据量大，SPMD(单程序多数据)的应用。\nb)     Spark\n基于内存计算的并行计算框架。适用于需要迭代多轮计算的应用。\nc)      MPI\n基于消息传递的并行计算框架。适用各种复杂应用的并行计算。支持MPMD( 多程序多数据) ，开发复杂度高",
    "ID" : "55f2e51de4b0152a61143345",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请简要描述一下Hadoop, Spark, MPI三种计算框架的特点以及分别适用于什么样的场景"
  },
  {
    "ID" : "55e6d85be4b0152a610de826",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "str1和str2地址相同，P1和P2地址不同。",
    "optionC" : "str1和str2地址不同，P1和P2地址不同。",
    "optionAnswer" : "A",
    "answer" : "在定义char数组时，会将常量字符串中的值拷贝到字符数组中，因而str1与str2指向的位置不同，但是定义的两个char*指针，p1,p2，都是指向常量区的同一个字符串，因而两者相同",
    "optionB" : "str1和str2地址相同，P1和P2地址相同。",
    "type" : "1",
    "optionA" : "str1和str2地址不同，P1和P2地址相同。",
    "question" : "在gcc编译器下，针对以下代码，const char str1[] = \"abc\";        \nconst char str2[] = \"abc\";\nconst char *p1 = \"abc\";\nconst char *p2 = \"abc\";\n那么针对printf(\"%d %d %d %d\\n\",str1, str2,p1,p2)的结果， 判断下列说法哪个是正确的：______。"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c77",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数体",
    "optionC" : "函数名称",
    "optionAnswer" : "D",
    "answer" : "虚函数在基类和派生类，具有相同的返回类型、形参类型和形参个数，而函数体可\n以根据不同的派生类或基类实现不同的操作，即不同函数体。",
    "optionB" : "参数个数",
    "type" : "1",
    "optionA" : "参数类型",
    "question" : "在派生类中定义虚函数时，可以与基类中相应的虚函数不同的是（）"
  },
  {
    "answer" : "ptr 定义在 buf 的前面。在栈上开变量的话，后开的内存地址较小，也就是 ptr 是恰好接在 buf 数组的后面。所以如果数组越界就可以修改 ptr 指向的内存地址。",
    "ID" : "55f2e51ee4b0152a6114339e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "在审计某一开源项目的代码时，假设有下面一个foo()子函数的实现。 从安全的角度看，会存在安全漏洞吗？有的话，请\n(1)描述漏洞细节，\n(2)说明可以利用的方法, \n(3) 还有该怎么修补漏洞。没有的话，也请说明为什么。\n\nint foo((void*funcp)()) {\n    char *ptr = pointer_to_an_array;\n    char buf[128];\n    gets(buf);\n    strncpy(ptr,buf,8)\n    (*funcp)();\n}"
  },
  {
    "answer" : "答：前一个循环一遍再判断，后一个判断以后再循环",
    "ID" : "55f2e51ee4b0152a611433c2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "do……while和while……do有什么区别？"
  },
  {
    "ID" : "55e6d85be4b0152a610de81b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "p=A或p=&A[0][0]",
    "optionC" : "p=A[0]或p=&A[0][0]",
    "optionAnswer" : "C",
    "answer" : "1，首先p是一个指针，A表示数组A的首个元素的地址，\n   A[0]表示数组A首个元素的值。\n   所以p=A[0]或p=A[0][0]都是不正确的，排除法可选D,\n2，另一方面，在C语言中，不管是几维数组，在内存中都是顺序存储的线性表，\n   A[0]，A[0][0],A[0][0][0]...都是表示数组A的第一个元素，\n   所以要得到A第一个元素的指针，p=&A[0][0]也是正确的",
    "optionB" : "p=A[0]或p=A[0][0]",
    "type" : "1",
    "optionA" : "p=A或p=A[0]",
    "question" : "要使指针变量p指向2维数组A的第1个元素，正确的赋值表达式是（）。"
  },
  {
    "ID" : "55e429cfe4b0152a610c8340",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "n的地址",
    "optionC" : "n的值",
    "optionAnswer" : "C",
    "answer" : "指针的定义",
    "optionB" : "p的地址",
    "type" : "1",
    "optionA" : "p的值",
    "question" : "int *p = &n;    那么*p的值是（）"
  },
  {
    "answer" : "由于有父节点指针，这道题目的难度一下子就降低了许多。int getHeight(TreeNode *node) {\n    int height = 0;\n    while (node) {\n        height++;\n        node = node->parent;\n    }\n    return height;\n}\n \nTreeNode* LowestCommonAncestor(TreeNode* first,TreeNode* second) {\n    int height1 = getHeight(first), height2 = getHeight(second), diff = height1 - height2;\n    if (diff < 0) {\n        diff = -diff;\n        while(diff--) {\n             second = second->parent;\n        }\n    } else {\n        while(diff--) {\n            first = first->parent;\n        }\n    }\n    while (first != second) {\n        first = first->parent;\n        second = second->parent;\n    }\n    return first;\n}\n思路二：若允许浪费空间，那么可以用两个Stack来存储从first和second到根结点的各个节点，然后出栈时比较地址是否一致，最后一个地址一致的节点为解。\n\n两种方法最坏时间复杂度均为O(n)。\n\n思路一：我们首先找到两个节点的高度差，然后从较靠近根结点的一层开始向上找，若父节点为同一节点则该节点为解。",
    "ID" : "55f2e51ce4b0152a61143338",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一颗二叉树，以及其中的两个node（地址均非空），要求给出这两个node的一个公共父节点，使得这个父节点与两个节点的路径之和最小。描述你程序的最坏时间复杂度，并实现具体函数，函数输入输出请参考如下的函数原型：strucy TreeNode{\n     TreeNode* left;   \/\/指向左子树\n     TreeNode* right;   \/\/指向右子树\n     TreeNode* father;   \/\/指向父亲节点\n};\nTreeNode* LowestCommonAncestor(TreeNode* first,TreeNode* second){\n}\nC++函数原型："
  },
  {
    "answer" : "假设有n个员工。\n选用数据结构，map[n][n]。\n1、其中map[i][j]=1代表i在j的前面，=0代表前后位置，=-1带表在后面。若出现已经=-1的情况下，在后面又要求=1，会形成环，则返回null。。\n2、这样就形成了一个图，然后进行拓扑排序即可。先找出所有入度为0的点，放在前面，然后去掉这些点和相应的边.如此得到最终结果。",
    "ID" : "55f2e51de4b0152a6114333f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "小米公司内部每个员工都会有一个专属的工作邮箱，邮箱的前缀是员工姓名的拼音全拼，例如张强的邮箱是zhangqiang@xiaomi.com,但同时公司里有很多同名的人，为了避免大家相互之间发错邮件，工程师们想了个规则来解决这个问题，即在这些同命人中，入职最早的邮箱前缀为姓名的拼音全拼，第二个入职的邮箱前缀为姓名的拼音全拼后面加“_a”，第三个入职的为姓名的拼音全拼后面加“_b”,以次类推，请按这个规则，如果公司里同时有3位名叫张强的员工，则他们的邮箱分别是zhangqiang@xiaomi.com，zhangqiang_a@xiaomi.com，zhangqiang_b@xiaomi.com...邮箱前缀是员工在公司里的重要标识之一，问题来了：现在小米要举行一次全员野外拉练活动，要求所有员工必须排成一队出去，并且，有的员工要求他必须排在某人的前面或后面，作为组织者的你，收到这样的需求之后，如何给出一个让每个人都满意的排队方式呢？\nJava：\n\nclass RequestItem\n{\n    public String member;\n    public boolean standFront; \/\/true表示要排在这个人的前面，false表示要排在这个人的后面\n}\nclass Request\n{\n    public String owner;    \/\/那个人提出的要求\n    List<RequestItem> requestItems;    \/\/他要排在哪些人的前面，哪些人的后面\n}\nList<String> getValidOrder(List<String>allMembers, List<Request> requests);\nallMembers就是所有员工的邮箱前缀，requests是一些人的排队要求。小米公司现有几千名员工，每个人最多有10个排队要求（要排在一个人的前面或者后面算一个排队要求），也有人没有什么要求。现在你的任务是完成上面的getValidOrder函数，如果有合法的排队序列，那么返回其中任何一个。否则返回null。"
  },
  {
    "ID" : "55f2e46ae4b0152a6114314d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "801010  810015",
    "optionC" : "801005   810014",
    "optionAnswer" : "C",
    "answer" : "1代表的是一个单位量  \np1+5=p1+5*1=p1+5*sizeof(unsigned char)=p1+5*1=0x801000+ox5=0x801005  \np2+5=p2+5*1=p2+5*sizeof(unsigned long)=p1+5*4=0x810000+20=0x810000+0x14=0x810014 \n最后要转换成16进制",
    "optionB" : "801010   810014",
    "type" : "1",
    "optionA" : "801005   810005",
    "question" : "unsigned char *p1;\nunsigned long *p2;\np1=(unsigned char *)0x801000;\np2=(unsigned long *)0x810000;\n请问p1+5= 什么？\np2+5= 什么？"
  },
  {
    "answer" : "abbc 和 babc 同的话， 即词语单个字符的ascii码和相同即词语相同。 把字符串比较转换成 int 型数字比较。\n数组中所有词转换成int 放入 int数组。 \n比较大小",
    "ID" : "55f2e51ee4b0152a611433b6",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "如果两个英文单词，组成它们的字符集合相同，而且相同字符出现的次数也相同，则称这两个词匹配：比如说：同”abbc”与词 ”babc”是匹配的。有一个词典，存储在字符串数组const char* dictionary[n]中，数组的每一个元素是一个词。对于任意给出的句子。句子中的单词使用空格分割。请实现以下函数，判断句子中是否有词和词典中的词匹配。 \nbool is_matching( const char* dictionary[],int n, const char* sentence);"
  },
  {
    "answer" : "答：extern\n可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。",
    "ID" : "55f2e51ee4b0152a611433bf",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "如何引用一个已经定义过的全局变量？"
  },
  {
    "answer" : "C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 \n对语言本身而言，C是C++的子集， C实现了C++中过程化控制及其它相关功能，而在C++中的C，相对于原来的C还有所加强，引入了重载、内联函数、异常处理等等，C++更是拓展了面向对象设计的内容，如类、继承、虚函数、模板和包容器类等等。 \n\n要用C模拟C++的多态性，可定义同一种函数指针类型和函数指针，运行过程中根据需要给函数指针赋函数地址。可以使用void *实现。",
    "ID" : "55f2e51de4b0152a61143377",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "C和C++有什么区别，能用C实现C++所有功能吗?C能实现多态吗?"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bfb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : " *A1.p=5;",
    "optionC" : "A1.*p=5;",
    "optionAnswer" : "C",
    "answer" : "A中p是指针即地址，错误；B选项中A1不是指针不能使用指向运算符->,错误\n；“*”比“.”级别要高，所以D选项*A1.p=5相当于(*A1).p=5;错误。另外涉及到指向成员函数\n时注意以下几点：\n　指向成员函数的指针必须于其赋值的函数类型匹配的三个方面：(1)参数类型和个数；(2)返回\n类型；(3)它所属的类类型。\n　成员函数指针的声明：指向short型的Screen类的成员的指针定义如下：\n　 short Screen::* ps_Screen;\nps_Screen可以用_height的地址初始化如下：short Screen::*ps_Screen=&Screen::_height;\n　类成员的指针必须总是通过特定的对象或指向改类型的对象的指针来访问。是通过使用两个指\n向成员操作符的指针(针对类对象和引用的.*，以及针对指向类对象的指针的->*)。",
    "optionB" : "A1->p=5;",
    "type" : "1",
    "optionA" : "A1.p=5;",
    "question" : "已知：p是一个指向类A数据成员m的指针，A1是类A的一个对象。如果要给m赋值为5，正确\n的是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a611431fe",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "把汇编语言翻译成机器语言",
    "optionC" : "把中间代码变换成依赖具体机器的目标代码",
    "optionAnswer" : "C",
    "answer" : "源码 ->（扫描）-> 标记 ->（语法分析）-> 语法树 ->（语义分析）-> 标识语义后的语法树 ->（源码优化）-> 中间代码 ->（代码生成）-> 目标机器代码 ->（目标代码优化）-> 最终目标代码",
    "optionB" : "把高级语言翻译成汇编语言",
    "type" : "1",
    "optionA" : "把高级语言翻译成机器语言",
    "question" : "代码生成阶段的主要任务是："
  },
  {
    "ID" : "55f2e46ae4b0152a61143148",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "12yz",
    "optionC" : "a2yz",
    "optionAnswer" : "C",
    "answer" : "本题考查字符串处理函数strcpy和strcat,执行完strcpy(a+1,b+2);后,a变为a2,执行完strcat( a,c+1 )后,a变为a2yz,所以答案为C选项。",
    "optionB" : "bc2yz",
    "type" : "1",
    "optionA" : "al2xyz",
    "question" : "有以下程序(strcpy 为字符串复制函数,strcat为字符串连接函数)\n\n#include <stdio.h>\n#include <string.h>\nmain( )\n{ \n    char a[10] = \"abc\" ,b[10] = \"012\",c[10] = \"xyz\";\n    strcpy( a+1,b+2);\n    puts( strcat( a,c+1));\n}\n 程序运行后的输出结果是?"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c62",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Sum(“AB”,”CD”);",
    "optionC" : "Sum(15.2f,16.0f);",
    "optionAnswer" : "D",
    "answer" : "由Q Sum(Q x,Q y)可知形参和函数返回值都是同一种数据类型。A、B、C三项都正确\n。而D项用字符串作为实参，字符串的操作与数值类型不同，要用特殊方法进行字符串的连接和\n运算。",
    "optionB" : "Sum(5.0,6.7)；",
    "type" : "1",
    "optionA" : "Sum(10,2);",
    "question" : "设有函数模板template <class Q> Q Sum(Q x,Q y) {return (x)+(y);}则下列语句中对该函数模板错误的使用是（）"
  },
  {
    "ID" : "55f2e46ae4b0152a6114314e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "256",
    "optionC" : "128",
    "optionAnswer" : "B",
    "answer" : "答案解析：首先要知道大小端模式，80X86下是小端模式；当然可以编写下测试就可以了，short占2个字节，设左高地址，右低地址；\n  a[1]           a[0]\n1111 1111     0000 0000\nshort占用的是这a[1]、a[0]两个字节，最高位是1是一个负数，在计算机中采用补码表示，那么二进制表示为：1000 0001 0000 0000，转化为十进制就是-256.",
    "optionB" : "-256",
    "type" : "1",
    "optionA" : "-128",
    "question" : "union Test\n {\n    char a[4];\n    short b;\n };\n Test test;\n test.a[0]=256;\n test.a[1]=255;\n test.a[2]=254;\n test.a[3]=253;\n printf(\"%d\\n\",test.b);\n问题：在80X86架构下，输出什么值？"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c02",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "const char * const p=“ABCD”；",
    "optionC" : "char const *p=“ABCD”；",
    "optionAnswer" : "D",
    "answer" : "const char *p说明禁止通过p修改所指向的数据。char * const p则说明不能修改\n指针p的地址。因此const char * const p=“ABCD”；它禁止修改指针p本身，又禁止修改p所指\n向的数据。",
    "optionB" : "char *const p=“ABCD”；",
    "type" : "1",
    "optionA" : "const char *p=“ABCD”；",
    "question" : "要禁止修改指针p本身，又要禁止修改p所指向的数据，这样的指针应定义为（）"
  },
  {
    "answer" : "当A1A2垂直B1B2时B1B2最长\n\n说明:\n设两个圆心分别为O1,O2\n因为：两点确定一条直线，A1A2的中垂线必过圆心，故O1O2垂直平分A1A2， \n设B1A1中点为C1，B2A1中点为C2 : 且O1C1垂直B1B2,O2C2垂直B1B2 \n所以就有了：\nB1B2 = 2*C1A1+2*C2A1 = 2*C1C2\n故B1B2最长为C1C2最长，\n又由于,O1C1垂直B1B2,O2C2垂直B1B2,故C1C2O2O1至少为梯形（假定），且O1O2长度固定\n沿着C1做一平行线D1D2与O1O2平行，故D1D2C2至少为一垂直三角形，C2为90度，\n通过锤子三角形定义，得出，当C1C2平行于D1D2时C1C2有最大值。\n又由于:故O1O2垂直平分A1A2，、\n得出 当A1A2垂直B1B2时B1B2最长 ",
    "ID" : "55f2e51de4b0152a6114338c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "两个圆相交，交点是A1，A2。现在过A1点做一直线与两个圆分别相交另外一点B1，B2.问在什么情况下，B1B2最长?"
  },
  {
    "answer" : "设a,b,c,ab,ac,bc,abc为分别答对这些题目的人\na+b+c+ab+ac+bc+abc = 25\nb+bc=2*(c+bc)\na = ab+ac+abc\nb+c = a\n3*a-1+bc = 25\n3*a-1 <= 25\na < 9\nbc = b - 2c\n4a-1 > 25\na > 7\na = 8,bc = 2\nc = 2,b = 6",
    "ID" : "55f2e51de4b0152a6114338f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一次数学比赛，共有A，B和C三道题目。所有人都至少解答出一道题目，总共有25人。\n在没有答出A的人中，答出B的人数是答出C的人数的两倍；单单答出A的人，比其他答出A的人总数多1；在所有只有答出一道题目的人当中，答出B和C的人数刚好是一半。\n求只答出B的人数。"
  },
  {
    "ID" : "55f2e46ae4b0152a61143151",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "编译错误",
    "optionC" : "128  128",
    "optionAnswer" : "B",
    "answer" : "强制转换的截后8位，正数用源码表示，负数用补码表示，第一位是符号。",
    "optionB" : "128 - 128",
    "type" : "1",
    "optionA" : "128  127",
    "question" : "经过强制类型转换以后，变量a，b的值分别为多少？\nshort a =128；\nbyte b =(byte) a；"
  },
  {
    "answer" : "分页存储管理基本思想：\n用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。\n分段存储管理基本思想：\n将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。\n段页式存储管理基本思想：\n分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。\n在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。\n段页式系统中，作业的地址结构包含三部分的内容：段号 页号 页内位移量\n程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。\n为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。",
    "ID" : "55f2e51de4b0152a6114336b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "windows内存管理的机制以及优缺点"
  },
  {
    "answer" : "#include <cstdio>\n#include <algorithm>\n \nint a[500500] = {0};\nint dp[500500] = {0};\n \nint main(){\n    freopen(\"numtri.in\",\"r\",stdin);\n    int row_num = 0;\n    scanf(\"%d\", &row_num);\n    int elem_num = row_num * (row_num + 1) \/ 2; \/\/ 数字金字塔中的元素个数\n    for(int i = 0;i <elem_num;i++) {\n        scanf(\"%d\",&a[i]);\n    }\n    for(int i=0; i<row_num; i++) {\n        dp[elem_num-1-i]=a[elem_num-1-i];\n    }\n    int n;\n    for(int i=row_num-2; i>=0; i--){\n        n = i * (i + 1) \/ 2;\n        for(int j=0; j<=i; j++) {\n            dp[n+j] = a[n+j] + std::max(dp[n+j+i+1], dp[n+j+i+2]);\n        }\n    }\n \n    freopen(\"numtri.out\",\"w\",stdout);\n    printf(\"%d\\n\",dp[0]);\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a6114334f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "假设有如下所示的一个数字金字塔，现在，要求写一个程序来查找从顶点到底部任意处结束的路径，使路径经过的数字的和最大，并输出该路径的最大和。比如以下金字塔的和最大路径的和为7+3+8+7+5=30。\n\n7\n3 2\n8 1 0\n2 7 4 4\n4 5 2 6 5"
  },
  {
    "ID" : "55f2e469e4b0152a6114313d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "堆和栈都可以动态分配",
    "optionC" : "堆和栈都可以静态分配",
    "optionAnswer" : "C",
    "answer" : "选C，静态分配是指在编译阶段就能确定大小，由编译器进行分配，堆不可以进行静态分配，堆的申请都是在执行过程中进行的。\nA，堆和栈的大小都可以设置，栈一般只有几KB。\nB，堆在动态分配时，要申请连续的内存空间，释放后会产生碎片。\nD，堆是使用malloc()、calloc()、realloc()等函数动态分配的，而使用alloca()函数可以动态分配栈的内存空间，释放的时候由编译器自己释放。",
    "optionB" : "在堆上频繁的调用new\/delete容易产生内存碎片，栈没有这个问题",
    "type" : "1",
    "optionA" : "堆的大小仅受操作系统的限制，栈的大小一般一般较小",
    "question" : "C++中关于堆和栈的说法，哪个是错误的:"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143267",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "7",
    "optionC" : "10",
    "optionAnswer" : "D",
    "answer" : "本题考查函数的递归调用,执行f(9)后,f(9)= 9-(7-(5-(3-f(1))))=7,所以答案为D选项。",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "9",
    "question" : "有以下程序\n\n#include <stdio.h>\nint fun( int x )\n{ \n    int p;\n    if (x == 0｜｜ x == 1 ) \n        return(3);\n    p = x - fun( x – 2 );\n    return(p);\n｝\nmain(){\n    printf (\"%d\\n\",fun(9));\n}\n程序运行后的输出结果是"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c0f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "返回类型",
    "optionC" : "指针参数",
    "optionAnswer" : "B",
    "answer" : "静态成员函数是普通的函数前加入static,它具有函数的所有的特征：返回类型、\n形参，所以使用(P107)静态成员函数，指针可以作为形参，也具有返回值。静态成员是类具有的\n属性，不是对象的特征，而this表示的是隐藏的对象的指针，因此静态成员函数没有this 指针\n。静态成员函数当在类外定义时，要注意不能使用static关键字作为前缀。由于静态成员函数在\n类中只有一个拷贝（副本），因此它访问对象的成员时要受到一些限制：静态成员函数可以直接\n访问类中说明的静态成员，但不能直接访问类中说明的非静态成员；若要访问非静态成员时，必\n须通过参数传递的方式得到相应的对象，再通过对象来访问。",
    "optionB" : "this指针",
    "type" : "1",
    "optionA" : "返回值",
    "question" : "静态成员函数没有（）"
  },
  {
    "ID" : "55e429cfe4b0152a610c8342",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "将文件指针定位到文件末尾",
    "optionC" : "计算文件wj.txt的起始地址",
    "optionAnswer" : "A",
    "answer" : "该程序是计算文件的字节数",
    "optionB" : "计算文件wj.txt的终止地址",
    "type" : "1",
    "optionA" : "计算文件wj.txt内容的字节数",
    "question" : "以下程序的功能是（）\n#include<stdio.h>  \nint main(void)  \n{  \n    FILE *fp;  \n    long int n;  \n    fp = fopen(\"wj.txt\",\"rb\");  \n    fseek(fp , 0 , SEEK_END);  \n    n = ftell(fp);  \n    fclose(fp);  \n    printf(\"%ld\",n);  \n}  "
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c73",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "寄存器变量",
    "optionC" : "静态变量",
    "optionAnswer" : "B",
    "answer" : "变量存储类可分为两类：全局变量和局部变量。\n（1）全局变量：在函数外部定义的变量称为全局变量，其作用域为：从定义变量的位置开始\n到源程序结束。全局变量增加了函数之间数据联系的渠道，全局变量作用域内的函数，均可使用\n、修改该全局变量的值，但是使用全局变量降低了程序的可理解性，软件工程学提倡尽量避免使\n用全局变量。\n（2）局部变量：在函数内部定义的变量称为局部变量，其作用域为：从定义变量的位置开始\n到函数结束。局部变量包含自动变量（auto）静态变量（static）以及函数参数。\nauto变量意味着变量的存储空间的分配与释放是自动进行的。说明符auto可以省略。函数中\n的局部变量存放在栈空间。在函数开始运行时，局部变量被分配内存单元，函数结束时，局部变\n量释放内存单元。因此，任两个函数中的局部变量可以同名，因其占有不同的内存单元而不影响\n使用。这有利于实现软件开发的模块化。\nstatic变量是定义在函数体内的变量，存放在静态存储区，不用栈空间存储，其值并不随存\n储空间的释放而消失。",
    "optionB" : "局部变量",
    "type" : "1",
    "optionA" : "全局变量",
    "question" : "所有在函数中定义的变量，都是（）"
  },
  {
    "answer" : "Java code：\n\npublic static int[] intersection(int[] a,int[] b){\n  int aLen = a.length;\n  int bLen = b.length;\n  int aIndex = 0;\n  int bIndex = 0;\n  int cIndex = 0;\n  int[] c = new int[aLen];\n\n  Arrays.sort(a);\n  Arrays.sort(b);\n\n  while(aIndex != aLen && bIndex != bLen){\n    if(a[aIndex] == b[bIndex]){\n      c[cIndex++] = a[aIndex];\n\n     aIndex++;\n     bIndex++;\n    }else if(a[aIndex ] < b[bIndex]){\n     aIndex++; \n    }else{\n     bIndex++;\n    }\n  }\n\n  if(cIndex != aLen){\n    c = Arrays.copyOf(c ,cIndex);\n  }\n\n  return c;\n}\n",
    "ID" : "55f2e51de4b0152a6114337a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "程序设计：给定2个大小分别为n, m的整数集合，分别存放在两个数组中 int A[n], B[m]，输出两个集合的交集。"
  },
  {
    "ID" : "55e6d85ae4b0152a610de807",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "表达式不合法输出无定值",
    "optionC" : "F'9'",
    "optionAnswer" : "B",
    "answer" : "本题考查字符变量以及printf( )函数相关知识,字符变量c1被赋值为'C'+'8'－'3',即ASSCII码的运算,67十54－49=72,即H;字符变量 c2被赋值为'9'－'0',但输出时,需要注意的是c1以字符变量输出,而c2是以十进制整型变量输出。因此B选项正确。",
    "optionB" : "H 9",
    "type" : "1",
    "optionA" : "H'9'",
    "question" : "若有以下程序main( ) \n{ \n    char c1,c2;\n    c1 ='C'+'8'－'3';\n    c2 ='9'－'0';\n    printf(\"%c %d\\n\",c1,c2);\n}\n则程序的输出结果是"
  },
  {
    "answer" : "public class QueueWithTwoStack { static Stack<Integer> s1 = new Stack<Integer>(); static Stack<Integer> s2 = new Stack<Integer>(); public boolean add(int v){ if(s2.isEmpty()){ while(!s1.isEmpty()){ s2.push(s1.pop()); } s1.push(v); return true; }else { if(s1.size() < 20){ s1.push(v); return true; }else{ if (s2.isEmpty()) { while(!s1.isEmpty()){ s2.push(s1.pop()); } s1.push(v); return true; }else{ System.out.println(\"queue is full\"); return false; } } } } public int remove(){ if(!s2.isEmpty()) return s2.pop(); else { while(!s1.isEmpty()){ s2.push(s1.pop()); } return s2.pop(); } } public static void main(String[] args) { QueueWithTwoStack myQueue = new QueueWithTwoStack(); for(int i = 0; i < 21; i ++){ if(myQueue.add(i)) System.out.print(i + \" \"); } System.out.println(); for(int i = 0; i < 10; i ++){ System.out.print(myQueue.remove() + \" \");\/\/前10个 } if(myQueue.add(21)) System.out.print(21 + \" \"); if(myQueue.add(22)) System.out.print(22 + \" \"); if(myQueue.add(23)) System.out.print(23 + \" \"); for(int i = 0; i < 14; i ++){ System.out.print(myQueue.remove() + \" \");\/\/后13个 } } }",
    "ID" : "55f2e51de4b0152a61143396",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "用你熟悉的语言编写程序用两个栈（Stack）模拟队列（Queue）的先进先出操作，仅实现add、remove方法即可。\n1）请先描述思路； 2）编写完整代码实现，编程语言不限。"
  },
  {
    "ID" : "55e6d85be4b0152a610de821",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "3",
    "optionC" : "2",
    "optionAnswer" : "B",
    "answer" : " a=i++. a----0 \nb=++a. b----1. a----1\n c=a+b. c-----2\na?b:c     a为1取b  也就是1",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "有变量int i = 0; int a = i++; int b=++a; int c = a+b; 请问表达式 a?b:c 的值是"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c8c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "模板类",
    "optionC" : "函数",
    "optionAnswer" : "A",
    "answer" : "类模板就是把类中的数据分离出来，作为一个类的描述。C++编译器根据类模板和特定伪数据类型来产生一个类，类模板就是一个抽象的类。",
    "optionB" : "对象",
    "type" : "1",
    "optionA" : "类",
    "question" : "类模板的使用实际上是将类模板实例化为一个具体的 ______。"
  },
  {
    "answer" : "<pre class=\"prettyprint lang-cpp\">string Zipper(string s){ string s1=\"\"; string s2=\"\"; int i=0,j=0,k=0,count=0; while(s[i]){ s1[i++]=s[j++]; if(s[j]==\" \")j++; } for(i=0;i&lt;s1.length();i++){ if(s1[i]==' '){ for(k=count;k&lt;i;k++) s2[k]=s1[i-1-K]; s2[i]=\" \"; count=i+1; } } }<\/pre> <br \/>",
    "ID" : "55f2e51de4b0152a6114337d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定字符串s, 要求把s中多于一个的连续空压缩成一个空格，并将连续的非空格字符串倒序打印出来，例如，给定\"abc def efg\"，打印\"cba fed gfe\""
  },
  {
    "answer" : "解答：（1）动态链接库(Dynamic Linked Library)：Windows为应用程序提供了丰富的函数调用，这些函数调用都包含在动态链接库中。其中有3个最重要的DLL，Kernel32.dll、User32.dll和GDI32.dll。有两种使用方式：一种是静态加载，即在应用程序启动时被加载；一种是动态加载，即是该动态链接库在被使用时才被应用程序加载。优点如下：\na. 共享：多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可；\nb. 开发模块好：要求设计者对功能划分的比较好。\n缺点是不能解决引用计数等问题。\n（2）静态库(Static Library)：函数和数据被编译进一个二进制文件(通常扩展名为.LIB)。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件(.EXE文件)。静态链接库作为代码的一部分，在编译时被链接。优缺点如下：\n代码的装载速度快，因为编译时它只会把你需要的那部分链接进去，应用程序相对比较大。但是如果多个应用程序使用的话，会被装载多次，浪费内存。",
    "ID" : "55f2e51ee4b0152a611433a7",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "动态链接库和静态链接库的优缺点"
  },
  {
    "ID" : "55f2e4fee4b0152a61143226",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "n, n+1, n+1",
    "optionC" : "n, n, n",
    "optionAnswer" : "D",
    "answer" : "先看代码\n for(i = ___; i < N; i++) {\n    swap(___, i);\n    run(n + 1);\n    swap(___, i);\n  }\n为了防止内存溢出，我直接排除法选择了c。只是个做题技巧，程序没多看",
    "optionB" : "n+1, n, n",
    "type" : "1",
    "optionA" : "n+1, n, n+1",
    "question" : "下列代码试图打印数字1-9的全排列组合。\n\n#include \"stdio.h\"\n#define N 9\nint x[N];\nint count = 0;\n \nvoid dump() {\n  int i = 0;\n  for (i = 0; i < N; i++) {\n    printf(\"%d\", x[i]);\n  }\n  printf(\"\\n\");\n}\n \nvoid swap(int a, int b) {\n  int t = x[a];\n  x[a] = x[b];\n  x[b] = t;\n}\n \nvoid run(int n) {\n  int i;\n  if (N - 1 == n) {\n    dump();\n    count ++;\n    return;\n  }\n  for (i = ___; i < N; i++) {\n    swap(___, i);\n    run(n + 1);\n    swap(___, i);\n  }\n}\n \nint main() {\n  int i;\n  for (i = 0; i < N; i++) {\n    x[i] = i + 1;\n  }\n  run(0);\n  printf(\"* Total: %d\\n\", count);\n}\n其中run函数中缺失的部分应该依次为："
  },
  {
    "ID" : "55f2e46ae4b0152a6114315f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "未知",
    "optionC" : "2",
    "optionAnswer" : "C",
    "answer" : "a[q-p]=a[2]=2;这题是要告诉我们指针的运算特点",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "question" : "int a[3];\na[0] = 0; a[1] = 1; a[2] = 2;\nint *p, *q;\np = a;\nq = &a[2];\n \n则a[q - p] = ?"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c23",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "一个对象调用不同名称的对象",
    "optionC" : "一个对象调用不同名称的函数",
    "optionAnswer" : "B",
    "answer" : "多态性有两种静态多态性和动态多态性，静态多态性是指调用同名函数，由于参数\n的不同调用不同的同名函数；动态多态性是指不同对象调用同名函数时，由于对象不同调用不同\n的同名函数。 多态性肯定具有相同的函数名，所以选择B项。",
    "optionB" : "不同的对象调用相同名称的函数",
    "type" : "1",
    "optionA" : "不同的对象调用不同名称的函数",
    "question" : "所谓多态性是指 （）"
  },
  {
    "ID" : "55e429cfe4b0152a610c8337",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "None of the above",
    "optionC" : "Port numbers below 1024 are called well-known ports and are reserved for standard services. For example,port 21 is reserved for FTP protocol, and port 25 is for SMTP protocol.",
    "optionAnswer" : "C",
    "answer" : "C是正确的",
    "optionB" : "TCP supports multicasting.",
    "type" : "1",
    "optionA" : "TCP provides a way for applications to send encapsulated IP datagrams and send them without having to establish a connection.",
    "question" : "Which statement(s) below regarding TCP(Transmission Control Protocol) is(are) correct?"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bfe",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "20和5",
    "optionC" : "4和20",
    "optionAnswer" : "C",
    "answer" : "a=4,因为后减，b的值与a、bb相关，b＝4*5=20，而与aa没有任何关系。",
    "optionB" : "5和4",
    "type" : "1",
    "optionA" : "3和15",
    "question" : "假定一个类的构造函数为A(int aa,int bb) {a=aa--;b=a*bb;},则执行A x(4,5)；语句后\n，x.a和x.b的值分别为（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c83",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "标识成员是属于哪个类的",
    "optionC" : "给定作用域的大小的",
    "optionAnswer" : "D",
    "answer" : "“::”左边一般为类名，右边一般为成员变量和成员函数，它的功能就是标识是属于哪个类的；如果左边什么都不加，表示全局变量。",
    "optionB" : "指出作用域的范围的",
    "type" : "1",
    "optionA" : "标识作用域的级别的",
    "question" : "作用域运算符“：：”的功能是（  ）"
  },
  {
    "answer" : "第一次握手：建立连接时，客户端调用发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n第二次握手：服务器端收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n完成三次握手，客户端与服务器开始传送数据；",
    "ID" : "55f2e51de4b0152a61143346",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请解释tcp连接建立过程，如果可能，请结合相应系统调用函数解释交互过程。"
  },
  {
    "ID" : "55f2e46ae4b0152a61143161",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "语法错误",
    "optionC" : "100",
    "optionAnswer" : "A",
    "answer" : "预定义在代码编译时直接替换，i=5*x+x(x=5)",
    "optionB" : "50",
    "type" : "1",
    "optionA" : "30",
    "question" : "#define DOUBLE(x) x+x\ni = 5*DOUBLE(5)\ni 是多少？"
  },
  {
    "answer" : "\/\/反转链表\nListNode* ResverseList(ListNode* head)\n{\nif (head == nullptr || head->m_pNext == nullptr)\n{\nreturn head;\n}\n\nListNode *pre, *curr,*nextNode;\npre = nullptr;\ncurr = head;\nwhile (curr != nullptr)\n{\nnextNode = curr->m_pNext;\ncurr->m_pNext = pre;\npre = curr;\ncurr = nextNode;\n}\nreturn pre;\n}\n\/\/合并两个从大到小的链表，为一个从小到大的链表\nListNode* MergeTwoOpp(ListNode* pHead1, ListNode* pHead2)\n{\nif(pHead1 == nullptr)\nreturn ResverseList(pHead2);\nif(pHead2 == nullptr)\nreturn ResverseList(pHead1);\n\nListNode* pNode = nullptr;\n\/\/ListNode* pPrev1 = nullptr;\nListNode* pNext1 = nullptr,* pNext2 = nullptr;\n\nif(pHead1->m_nValue > pHead2->m_nValue)\n{\npNode = pHead1;\npHead1 = pHead1->m_pNext;\npNext1 = pHead1;\npNode->m_pNext =nullptr;\n}\nelse\n{\npNode = pHead2;\npHead2 = pHead2->m_pNext;\npNext2 = pHead2;\npNode->m_pNext =nullptr;\n}\n\n\/\/ListNode* pNode = pOppHead;\n\nwhile(pHead1 != nullptr && pHead2 != nullptr)\n{\nif(pHead1->m_nValue > pHead2->m_nValue)\n{\npNext1 = pHead1->m_pNext;\npHead1->m_pNext = pNode;\npNode = pHead1;\npHead1 = pNext1;\n}\nelse\n{\npNext2 = pHead2->m_pNext;\npHead2->m_pNext = pNode;\npNode = pHead2;\npHead2=pNext2;\n}\n}\nListNode* pOppNode = pNode;\n\nif (pHead1 != nullptr)\n{\nListNode * p1 = ResverseList(pHead1);\npOppNode = p1;\nwhile (p1->m_pNext != nullptr)\np1 = p1->m_pNext;\np1->m_pNext = pNode;\n}\nif (pHead2 != nullptr)\n{\nListNode * p2 = ResverseList(pHead2);\npOppNode = p2;\nwhile (p2->m_pNext != nullptr)\np2 = p2->m_pNext;\np2->m_pNext = pNode;\n}\nreturn pOppNode;\n}",
    "ID" : "55f2e51ee4b0152a611433b5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请实现一个函数，把两个从大到小的有序链表合并成一个链表，新的链表是一个从小到大的有序链表。\nstruct list\n{\n    int value;\n    list* next;\n};\nlist * merge (list *list1_head, list*list2_head);"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c86",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "A Obj;",
    "optionC" : "int fun(A);",
    "optionAnswer" : "B",
    "answer" : "抽象类可以定义指针和引用",
    "optionB" : "A *p;",
    "type" : "1",
    "optionA" : "A fun(int);",
    "question" : "假设A为抽象类，下列声明（）是正确的"
  },
  {
    "ID" : "55f2e4fee4b0152a61143215",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "这是不正确的，它没有释放任何成员变量。",
    "optionC" : "无法编译通过",
    "optionAnswer" : "C",
    "answer" : "代码可以看出this指针内容为const，不允许进行修改，故编译不成功。\n~MyClass() { delete this;  }\n如果为此句代码，则能通过编译，不过会导致栈溢出，因为不断的调用析构函数。",
    "optionB" : "它会导致栈溢出",
    "type" : "1",
    "optionA" : "正确，我们避免了内存泄漏",
    "question" : "如果有一个类是 myClass , 关于下面代码正确描述的是:\n\nmyClass::~myClass(){\ndelete this;\nthis = NULL;\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a61143233",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "11",
    "optionC" : "10",
    "optionAnswer" : "C",
    "answer" : "5-（-11）*2\/4=5-(-22)\/4=5-(-5)=-10",
    "optionB" : "6",
    "type" : "1",
    "optionA" : "5",
    "question" : "下面代码的输出结果是?\n\nint main(){\n        int z,x = 5,y = -10,a = 4,b = 2;\n        z = x++ - --y * b\/a;\n        printf(\"%d\\n\",z);\n        return 0;\n}"
  },
  {
    "ID" : "55e6d85be4b0152a610de825",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "7个字节",
    "optionC" : "6个字节",
    "optionAnswer" : "C",
    "answer" : "C语言中的字符串用指向该串首个字符的指针表示。\n不保存长度信息，用'\\0'来标识字符串的终止。\n因此相当于 char arrays[] = {'C', 'h', 'i', 'n', 'a', '\\0'}。",
    "optionB" : "5个字节",
    "type" : "1",
    "optionA" : "4个字节",
    "question" : "在C语言中，设有数组定义：char arrays[]=\"China\"；则数组array所占用的空间为（）"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114326c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "12",
    "optionC" : "11",
    "optionAnswer" : "C",
    "answer" : "fun1的功能是：从数组s的第N-1位开始向前找（从0开始），找到s中不大于参数a的元素，如果存在，返回元素的索引，否则返回-1；\nfun2的功能是：从数组s的第j+1位开始向后找（从0开始），找出不小于参数a的元素，如果存在返回元素的索引，否则返回s的数组个数；\n\n这里s的元素个数为8，第0位为空，1-7位分别是：\n1: D;\n2: F;\n3: H;\n4: J;\n5: L;\n6: N;\n7: P;\n\n所以fun1返回的值为5，s[5]='L',不大于‘M’。\nfun2的返回值为6，s[6]=‘N’,不小于'M'.\n\n5+6=11；",
    "optionB" : "10",
    "type" : "1",
    "optionA" : "9",
    "question" : "阅读程序，请选择输出结果\n\n#include <iostream>\nusing namespace std;\n \n#define N 7\nint fun1(char s[], char a, int n)\n{\n    int j;\n    j = n;\n    while (a < s[j] && j > 0) j--;\n    return j;\n}\n \nint fun2(char s[], char a, int n)\n{\n    int j;\n    j = 1;\n    while (a > s[j] && j <= n)\n        j++;\n    return j;\n}\nint main()\n{\n    char s[N + 1];\n    int k, p;\n    for (k = 1; k <= N; k++)\n        s[k] = 'A' + 2 * k + 1;\n    p = fun1(s, 'M', N);\n    cout << p + fun2(s, 'M', N) << endl;\n     \n    return 0;\n}"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c18",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "拷贝构造函数",
    "optionC" : "友元函数",
    "optionAnswer" : "C",
    "answer" : "构造函数、析构函数、拷贝构造函数都是特殊的成员函数，友元则不是成员函数。\n所以选择C项。",
    "optionB" : "析构函数",
    "type" : "1",
    "optionA" : "构造函数",
    "question" : "下列不是描述类的成员函数的是（）"
  },
  {
    "answer" : "char *Delete(char str1[],char str2[])\n{\n     int i=0;\n     char *p1=str1;\n     while(*p1 !='\\0')\n     {       \n        char *p2=str2;\n        while(*p2 !=*p1 && *p2!='\\0')\n         {\n             p2++;\n}   \n  if(*p2 =='\\0')\nstr1[i++]=*p1;\n             p1++;\n      }\n    str1[i]='\\0';\nreturn str1;\n}",
    "ID" : "55f2e51de4b0152a61143359",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "删除字符串中指定的字符，如字符串”abcdeas\"，需要删除的字符为“ade\",则得到的结果为”bcs”"
  },
  {
    "answer" : "二分查找完整代码：\n#include<iostream>\nusing namespace std;\n\nvoid * bsearch(const void *key, const void *base, size_t nel, size_t width, int (*cmp)(const void *, const void *)){\n    void *mid = NULL;\n    int sign;\n    while (nel > 0) {\n        \n        mid = (char *)base + width*(nel\/2);\n        sign = cmp(key, mid);\n        if (sign == 0) return mid;\/\/找到 \n        if (nel == 1) break;\n        else if (sign < 0)\n            nel \/= 2;\/\/下取整 \n        else {\n            base = mid;\n            nel -= nel\/2;\/\/上取整 \n        }\n        \n    }\n    return NULL;\n}\n\nint compare(const void *val1, const void *val2) {\n    int iVal1 = *(int*)val1;\n    int iVal2 = *(int*)val2;\n    if (iVal1 > iVal2) {\n        return 1;\n    }\n    else if (iVal1 == iVal2) {\n        return 0;\n    }\n    return -1;\n}\n\n测试用例：\nint main(){\n\n    int a[10]={1, 2, 5, 8, 10, 11,12,13,14,15};\n    int key = 5;\n    \n    void* res = bsearch(&key, a, 10, sizeof(int), compare);\n    if(res != NULL){\n        cout << \"索引位置：\" << (int *)res - a;\n    }\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a61143348",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "二分查找是常用的编程方法，请用完整代码实现该函数（不许调用库函数）\nvoid *bsearch(const void *key, const void *base, size_t nel, size_t width, int (*compar) (const void *, const void *));"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f7",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "*(a[1]+1)",
    "optionC" : "*(&a[1]+1)",
    "optionAnswer" : "C",
    "answer" : "在二维数组中a[1]表示的是a[1][0]的地址，数组在内存中连续存储，所以a[1]+1表示的是a[1][1]的地址，所以D可以取得正确的值；\n指针操作*(a+1)与a[1]等价，所以B也可以取得正确的值；\n二维数组在内存中是行优先存储的，所以A中a[0][0]的地址加5可以取得正确值；\nC选项错误，应改为*(&a[1][0]+1)，因为a[1]就表示a[1][0]的地址。",
    "optionB" : "*(*(a+1)+1)",
    "type" : "1",
    "optionA" : "*(&a[0][0]+5)",
    "question" : "int a[3][4]，下面哪个不能表示 a[1][1]?"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c04",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "register",
    "optionC" : "cpu",
    "optionAnswer" : "A",
    "answer" : "extern用于声明外部变量的。register声明寄存器类型变量。无cpu类型。它们都不能声\n明类成员。public声明为公有访问权限，所以选择A项",
    "optionB" : "extern",
    "type" : "1",
    "optionA" : "public",
    "question" : "在类中说明的成员可以使用关键字的是（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c63",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "既调用类A中函数，也调用类B中的函数",
    "optionC" : "根据p所指的对象类型而确定调用类A中或类B中的函数func()",
    "optionAnswer" : "A",
    "answer" : "指向类成员指针的使用，A::func()是明确调用A类的func函数，所以不管p指向基\n类或者派生类对象，都执行基类虚函数。注意p->A::func()和p->fun();进行区分。如果使用p-\n>fun()，因为p指向派生类对象，由动态多态性可知要调用派生类的虚函数。",
    "optionB" : "调用类B中的函数func()",
    "type" : "1",
    "optionA" : "调用类A中的函数func()",
    "question" : "类B是类A的公有派生类，类A和类B中都定义了虚函数func(),p是一个指向类A对象的指针，则p->A::func()将（"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143271",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "11,16",
    "optionC" : "16,12",
    "optionAnswer" : "C",
    "answer" : "这类题目考察的是内存对齐：\n结构体(struct)(或联合体(union))的数据成员，每个数据成员的对齐按照编译选项指定的数据成员自身长度中，最长的那个。\nA：\n4（int）+4（short不够4，补2）+4(int)+4(char 不够4，补3) = 16\nB：\n4（int）+4(char 为1，short为2 ，补1)+4（int） = 12",
    "optionB" : "13,12",
    "type" : "1",
    "optionA" : "16,16",
    "question" : "在32位系统环境，编译选项为4字节对齐，那么sizeof(A)和sizeof(B)是： \n\nstruct A\n{\n int a;\n short b;\n int c;\n char d;\n};\nstruct B\n{\n int a;\n short b;\n char c;\n int d;\n};"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c13",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "基类的公有成员在派生类中仍然是公有的",
    "optionC" : "赋值兼容规则也适用于多重继承的组合",
    "optionAnswer" : "D",
    "answer" : "继承方式有三种：公有、私有和保护。多继承中，多个基类具有同名成员，在它们\n的子类中访问这些成员，就产生了二义性，但进行访问时，不能存在二义性。赋值兼容规则是指\n派生类对象可以当作基类对象使用，只要存在继承关系，所以单继承或多继承都适用。基类中的\n公有成员采用私有继承时，在派生类中变成了私有成员，所以D项错误。",
    "optionB" : "对基类成员的访问必须是无二义性的",
    "type" : "1",
    "optionA" : "派生类一般都用公有派生",
    "question" : "下面叙述不正确的是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143201",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "抽象类",
    "optionC" : "友元",
    "optionAnswer" : "B",
    "answer" : "c用宏定义，c++用inline",
    "optionB" : "内联函数",
    "type" : "1",
    "optionA" : "虚函数",
    "question" : "对于一个频繁使用的短小函数,在C语言中用宏实现,在C++中应用什么实现?"
  },
  {
    "ID" : "55e6d85ae4b0152a610de80b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "注释头文件",
    "optionC" : "防止头文件被重复引用",
    "optionAnswer" : "C",
    "answer" : "(1)答：防止头文件被重复引用 \n(2)答：前者用来包含开发环境提供的库头文件，后者用来包含自己编写的头文件。 \n(3)答：函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern \"C\"修饰的变量和函数是按照C语言方式编译和连接的。由于编译后的名字不同，C++程序不能直接调用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。 \n(4)答：实型",
    "optionB" : "标记为特殊的头文件",
    "type" : "1",
    "optionA" : "定义常量",
    "question" : "头文件中的 ifndef\/define\/endif 干什么用？"
  },
  {
    "ID" : "55e429cfe4b0152a610c833a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1",
    "optionC" : "0",
    "optionAnswer" : "B",
    "answer" : "运行可知",
    "optionB" : "-1",
    "type" : "1",
    "optionA" : "-2",
    "question" : "Initialize integer i as 0, what's the value of i after the following operation?  i += i > 0 ? i++ : i --;  "
  },
  {
    "answer" : "1，静态成员函数不可以是虚函数，因为静态成员函数全局通用，不受限于某个具体对象\n2，构造函数不可以是虚函数，虚函数主要是针对对象而言，而构造函数是在对象创建之前，所以构造函数的虚函数是没有意义的\n3，内联函数不可以是虚函数，因为内联函数不能再运行中动态确定其位置",
    "ID" : "55f2e51ee4b0152a611433d2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "什么函数不能声明为虚函数？"
  },
  {
    "ID" : "55f2e4fee4b0152a61143224",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "程序错误",
    "optionC" : "100    500",
    "optionAnswer" : "B",
    "answer" : "vector erase以后，itor已经指向下一个元素了，不应该执行itor++，\n否则会跳过下一个元素，即连续两个300时跳过了第二个300. \n\n正确代码应该是\n\nint main(void)  \n{  \n    vector<int>array;  \n    array.push_back(100);  \n    array.push_back(300);  \n    array.push_back(300);  \n    array.push_back(500);  \n    vector<int>::iterator itor;  \n    for(itor=array.begin();itor!=array.end();)  \n    {  \n        if(*itor==300)  \n        {  \n            itor = array.erase(itor);  \n        }  \n        else\n             itor++;\n    }  \n    for(itor=array.begin();itor!=array.end();itor++)  \n    {  \n        cout<<*itor<<\" \";  \n    }  \n    return 0;  \n}  ",
    "optionB" : "100    300     500",
    "type" : "1",
    "optionA" : "100   300   300   500",
    "question" : "下列代码的输出为：\n\n#include \"iostream\"  \n#include \"vector\"  \nusing namespace std;  \n   \nint main(void)  \n{  \n    vector<int>array;  \n    array.push_back(100);  \n    array.push_back(300);  \n    array.push_back(300);  \n    array.push_back(500);  \n    vector<int>::iterator itor;  \n    for(itor=array.begin();itor!=array.end();itor++)  \n    {  \n        if(*itor==300)  \n        {  \n            itor = array.erase(itor);  \n        }  \n    }  \n    for(itor=array.begin();itor!=array.end();itor++)  \n    {  \n        cout<<*itor<<\" \";  \n    }  \n    return 0;  \n}  "
  },
  {
    "answer" : "public void relocateList(ListNode head) {\/\/ 头结点\n ListNode p1 = new ListNode(0);\n ListNode p2 = new ListNode(0);\n ListNode pre = null;\n ListNode pTemp = null;\n \n p1.next = head.next;\n p2.next = head.next;\n \/\/ 单链表为空或有3个元素以内（少于4个），直接返回此单链表即可\n if (head.next == null || head.next.next == null || head.next.next.next == null|| head.next.next.next.next==null)\n return;\n \n int length = 0, start2 = 0;\n \/\/ 取得单链表长度\n while (p2.next != null) {\n length++;\n p2.next = p2.next.next;\n }\/\/ while(p2.next!=null)\n start2 = length \/ 2;\n p2.next = head.next;\n while (start2 > 0 && p2.next != null) {\n pre = p2.next;\n p2.next = p2.next.next;\n start2--;\n }\/\/ while(start2>0)\n \n \/\/ 合并左右半区\n pre.next = null;\/\/ 得到左半区\n start2 = length \/ 2;\n while (start2 > 0) {\n \/\/ 左半区操作不用另考虑，右半区的结点插入过来即可\n pre = p1.next;\/\/ 插入结点时要用到pre\n p1.next = p1.next.next;\n \n \/\/ 处理右半区结点，头插法\n pTemp = p2.next;\n p2.next = p2.next.next;\n pTemp.next = p1.next;\n pre.next = pTemp;\n \/\/ p1.next = p1.next.next;\n \n start2--;\n }\/\/ while(start2>0)\n if (p2.next != null) {\n pTemp.next=p2.next;\n }\/\/ if(p2.next!=null)\n }",
    "ID" : "55f2e51de4b0152a61143341",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N\/2个节点算作左半区，后N\/2个节点算作右半区； 如果N为奇数，那么前N\/2个节点算作左半区，后N\/2+1个节点算作右半区； 左半区从左到右依次记为L1->L2->...，右半区从左到右依次记为R1->R2->...。请将单链表调整成L1->R1->L2->R2->...的样子。 例如： 1->2->3->4 调整后：1->3->2->4 1->2->3->4->5 调整后：1->3->2->4->5 要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)"
  },
  {
    "ID" : "55f2e4fee4b0152a6114323d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "%",
    "optionC" : "sizeof",
    "optionAnswer" : "C",
    "answer" : "大部分的操作符是可以被重载的，例外的只有“.”、“::”、“?:”和“sizeof”。没有什么非禁止operator?:重载的理由，只不过没有必要而已。另外，expr1?expr2:expr3的重载函数无法保证expr2和expr3中只有一个被执行。\n而“sizeof”无法被重载是因为不少内部操作，比如指针加法，都依赖于它。",
    "optionB" : "<",
    "type" : "1",
    "optionA" : "=",
    "question" : "下面哪个操作符不能重载（）"
  },
  {
    "answer" : "1",
    "ID" : "55f2e51ce4b0152a61143336",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "123456789101112...2014除以9的余数是"
  },
  {
    "answer" : "1） 通过修改A B掩码使得它们能互相通信的话，只需要AB 同在一个子网。因此A 和B 的掩码为255.255.252.0   ， C不变\n2）A的IP 地址修改为与B 同一个网段，如192.168.2.3",
    "ID" : "55f2e51de4b0152a61143399",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "（系统运维选做）有主机A、B、C通过eth0和同一个交换机相连，A的IP地址为192.168.1.2，子网掩码255.255.255.0，B的IP地址为192.168.2.2，子网掩码255.255.255.0，C的IP地址为192.168.4.2，子网掩码255.255.255.0。现希望A和B能够通信，A和C、B和C不能通信。\n1）假设能更改A和B的子网掩码，要如何设置A和B的子网掩码？\n2）如果不能更改子网掩码，需要在A和B做什么设置？\n3）A和B通信时，C是否能够通过sniffer截获A和B通信的报文，如果只能截获一部分报文，是哪一类报文？ \n4）C可以仅通过sniffer得知A和B的IP地址和MAC地址吗？如果能，如何获得？"
  },
  {
    "answer" : "void memcpy(const char* src,char* dest){   \n int len=strlen(src);    \ndest=(char*)malloc(len+1);    \nchar* d=dest;    \nchar* s=src;    \nwhile(len--!=0)\n{        \n*d=*s;        \nd++;       \n s++;    \n}\n*d=’\\0’;\n}",
    "ID" : "55f2e51ce4b0152a61143329",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "请找出下面用于拷贝内存的代码中的逻辑错误，并修正。void memcpy(const char* src,char* dest){\n    int len=strlen(src);\n    dest=(char*)malloc(len);\n    char* d=dest;\n    char* s=src;\n    while(len--!=0){\n        *d=*s;\n        d++;\n        s++;\n    }\n}"
  },
  {
    "ID" : "55f2e4fde4b0152a611431eb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "40",
    "optionC" : "30",
    "optionAnswer" : "C",
    "answer" : "因为指针变量p的初始值指向数组a,所以执行for循环语句后,数组a中的元素的值不变。因此C选项正确。",
    "optionB" : "20",
    "type" : "1",
    "optionA" : "10",
    "question" : "#include <stdio.h>\nmain( )\n{\n    int a [ ] ＝｛10,20,30,40｝,﹡p ＝ a,i;\n    for(i ＝ 0;i <＝ 3;i + +)\n    {\n        a [i]＝﹡p;p + +;\n    }\n    printf(\"%d＼n\",a [2]);\n} \n程序运行后的输出结果是？"
  },
  {
    "answer" : "假设每个网页有价值为wi.\nwi的值为浮点数,通过堆实现.\nwi为整数,则通过桶式排序记录每个价值对应的网页数量",
    "ID" : "55f2e51ee4b0152a611433a1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "百度Spider如何在不超过抓取限额的情况下使得抓取的网页价值之和最大，要求一个最佳抓取方案。请详细描述你的算法思路（可以用伪代码），并分析时间复杂度和空间复杂度。"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143273",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8,80",
    "optionC" : "10,10",
    "optionAnswer" : "B",
    "answer" : "char *p[10] 是指针数组,数组里存放了10个指针,在64位系统下指针占8个字节,所以sizeof(p) = 10 * 8 = 80.\nchar (*p1)[10]是数组指针,p1是一个指向存放10个char类型的数组的指针,所以sizeof(p1) = 8.",
    "optionB" : "80,8",
    "type" : "1",
    "optionA" : "4,40",
    "question" : "在64位系统下，分别定义如下两个变量：char *p[10]; char(*p1)[10];请问，sizeof(p)和sizeof (p1)分别值为____。"
  },
  {
    "answer" : "先来个3*3\n\n8 1 6\n3 5 7\n4 9 2\n\n\n\nn奇数幻方口诀：\n1. 数字1放在第一行中间\n2. 依次放在上一个数的右上角\n2.1如果右边出去了就回到左边（3，4）\n2.2 如果上面出去了就放下面（1，2）\n2.3 如果右上角有了就放在这个数的下面（参考5，6）\n\n5*5\n17 24 1 8 15\n23 5 7 14 16\n4 6 13 20 22\n10 12 19 21 3\n11 18 25 2 9\n",
    "ID" : "55f2e51de4b0152a61143376",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个奇数n，比如n=3，生成1到n平方的数，如1到9，填入九宫格，使得横竖斜的和都相等。"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143251",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "11",
    "optionC" : "1",
    "optionAnswer" : "B",
    "answer" : "就是a[1][1]",
    "optionB" : "9",
    "type" : "1",
    "optionA" : "7",
    "question" : "以下程序的输出结果是________。\n\nvoid fut(int**s,int p[2][3]) {\n    **s=p[1][1];\n}\nvoid main( ) {\n    int a[2][3]={1,3,5,7,9,11},*p;\n    p=(int*)malloc(sizeof(int));\n    fut(&p,a);\n    cout<< *p;\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143263",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "1000+10i+5j",
    "optionC" : "1000+5i+j",
    "optionAnswer" : "C",
    "answer" : "因为是5列10行的数组，而且分配内存地址是连续的，如果按行存储的，则每增加1行地址就会增加5，然后加上所在的列就是当前的地址，所以就是1000+5i+j",
    "optionB" : "1000+i+j",
    "type" : "1",
    "optionA" : "1000+10i+j",
    "question" : "有一个二维数组A[10][5]，每个数据元素占1个字节，且A[0][0]的存储地址是1000，则A[i][j]的地址是多少 ？"
  },
  {
    "answer" : "整个数组最大值要么在左，要么在右。\n若在左，要得到结果，则要求分开后右边数组的最大值尽量小，显然max(a,b,c) >= a (or b, c),因而右边数组只包含最右元素时右边的最大值最小。\n若在右，类似。\n对两种情况加个判断，得到最优解。\n\nclass Solution {\npublic:\n \/**\n *  求左部分中的最大值减去右部分最大值的绝对值\n *  vec: 输入数组\n *  len vec的长度\n *  返回：左部分中的最大值减去右部分最大值的绝对值    *\/\n \n int getMaxABSLeftAndRight(vector<int> vec, int len) {\n if (len == 0) {\n return 0;\n }         \n int max = vec[0];    \n for (int i = 1; i < len; i++) {\n if (vec[i] > max) {\n max = vec[i];\n }\n }         \n return max - (vec[0] < vec[len - 1] ? vec[0] : vec[len - 1]);\n }\n};",
    "ID" : "55f2e51de4b0152a61143340",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个长度为N的整型数组arr，可以划分成左右两个部分： 左部分arr[0..K]，右部分arr[K+1..arr.length-1]，K可以取值的范围是[0,arr.length-2] 求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？ 例如： [2,7,3,1,1] 当左部分为[2,7]，右部分为[3,1,1]时，左部分中的最大值减去右部分最大值的绝对值为4; 当左部分为[2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6; 最后返回的结果为6。 注意：如果数组的长度为N，请尽量做到时间复杂度O(N)，额外空间复杂度O(1)"
  },
  {
    "answer" : "WM_QUIT通知程序退出，一般情况下在主线程中会有一个循环如下：\n    while(GetMessage(......))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    如果GetMessage获得的是WM_QUIT消息，GetMessage便会返回FALSE，导致while循环退出，一般情况下，程序也会退出。windows窗口不会受到WM_QUIT消息。\n     \n    普通Windows窗口能收到的最后一条消息时WM_DESTROY。",
    "ID" : "55f2e51ce4b0152a6114333b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "WM_QUIT消息的用途是什么？一个普通的Windows窗口能收到的最后一条消息是什么？"
  },
  {
    "ID" : "55f2e46ae4b0152a61143150",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0X0000001",
    "optionC" : "0xFE79DBF7",
    "optionAnswer" : "A",
    "answer" : "换成二进制求异或",
    "optionB" : "0xAC308800",
    "type" : "1",
    "optionA" : "0x524953f7",
    "question" : "整数int i = 0xFE78DA45; int k = 0xAC3189B2;则i^k的值为（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de802",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8",
    "optionC" : "2",
    "optionAnswer" : "A",
    "answer" : "数组为3行4列如下\n3 4 0 0\n2 8 6 0\n0 0 0 0\na[1][2]求的是第二行第三列的值，所以为6",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "6",
    "question" : "假定一个二维数组的定义语句为“int a[3][4]={{3,4},{2,8,6}};”，则元素a[1][2]的值为"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114326d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Long long",
    "optionC" : "Unsigned int",
    "optionAnswer" : "D",
    "answer" : "long long是8个",
    "optionB" : "Int C long",
    "type" : "1",
    "optionA" : "short int",
    "question" : "在 32 位操作系统中，下列类型占用 8 个字符的为______。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143220",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int ((int *)[10])*p",
    "optionC" : "int (*(*p)[10])(int *)",
    "optionAnswer" : "C",
    "answer" : "先看未定义标识符p，p的左边是*，*p表示一个指针，跳出括号，由于[]的结合性大于*，所以*p指向一个大小为10的数组，即(*p)[10]。左边又有一个*号，消释数组的元素，*(*p)[10]表示*p指向一个大小为10的数组，且每个数组的元素为一个指针。跳出括号，根据右边（int *）可以判断（*(*p)[10]）是一个函数指针，该函数的参数是int*,返回值是int。所以选C。",
    "optionB" : "int [10]*p（int *）",
    "type" : "1",
    "optionA" : "（int *p[10]）（int*）",
    "question" : "声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c25",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "友元函数时",
    "optionC" : "对象时",
    "optionAnswer" : "C",
    "answer" : "建立对象时，自动构造函数的初始化对象，是系统自动调用的。而成员函数、友元\n函数，需要用户直接调用，因此选择C项。",
    "optionB" : "数据成员时",
    "type" : "1",
    "optionA" : "成员函数时",
    "question" : "类的构造函数被自动调用执行的情况是在定义该类的（）"
  },
  {
    "answer" : "#include <iostream>\nusing namespace std;\n#define MAXN 100\n  \nvoid dfs(int pi,int curSum,bool res[],int n,int half,int &num,int left[])\n{\n    for(int i=pi+1;i<=n;i++) { \n        res[i]=true; \n        if(curSum+left[i]=1;i--)\n            left[i]=i+left[i+1]; \n    dfs(0,0,res,n,half,cnt,left);\n    return cnt;\n}\nint main()\n{\n    int n=20;\n    int num=cal_num(n);\n    printf(\"num=%d\\n\",num);\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a6114338b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "将一个集合拆分成两个不相交的子集，两个子集元素之和相等，如{1, 2, 3, 4, 5, 6, 7}，拆分成： {2, 5, 7}, {1, 3, 4, 6} 给出一个集合，求所有符合上面要求的拆分，效率最高分越高，函数原型为int cal_num(int n);"
  },
  {
    "answer" : ">6",
    "ID" : "55f2e51ce4b0152a61143333",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "下面代码输出什么   #include<stdio.h>\nint main( )\n{\n    unsigned int a = 6;\n    int b = -20;\n    (a + b > 6) ? printf(\">6\") : printf(\"<=6\");\n    return 0;\n}"
  },
  {
    "ID" : "55e429cfe4b0152a610c833c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "O(n*n)",
    "optionC" : "O(nlgn)",
    "optionAnswer" : "C",
    "answer" : "快排的复杂度为C",
    "optionB" : "O(n)",
    "type" : "1",
    "optionA" : "O(lgn)",
    "question" : "The best time complexity of quick sort algorithm is:"
  },
  {
    "answer" : "调用一个DLL中的函数有两种方法： 1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向系统提供了载入DLL时所需的信息及DLL函数定位。 2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或LoadLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了。",
    "ID" : "55f2e51ce4b0152a6114333a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "调用动态连接库的函数有哪几种方法？"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bfc",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "（*x）.a()",
    "optionC" : "x->a",
    "optionAnswer" : "B",
    "answer" : "对象访问成员的方式为：对象名.成员。指针可以有两种：(*对象指针).成员或者对\n象指针->成员。A选项是访问数据成员，B项是访问成员函数。",
    "optionB" : "x.a()",
    "type" : "1",
    "optionA" : "x.a",
    "question" : "假定AA为一个类，a()为该类公有的函数成员，x为该类的一个对象，则访问x对象中函数\n成员a()的格式为（）"
  },
  {
    "ID" : "55f2e469e4b0152a61143140",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "局部对象的析构函数",
    "optionC" : "局部对象的构造函数",
    "optionAnswer" : "A",
    "answer" : "全局对象的构造函数会在main 函数之前执行。",
    "optionB" : "全局对象的析构函数",
    "type" : "1",
    "optionA" : "全局对象的构造函数",
    "question" : "main 函数执行以前，还会执行什么代码？"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114326f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "12 16",
    "optionC" : "9 9",
    "optionAnswer" : "A",
    "answer" : "答案解析：类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐.\n那么类A的大小等于4个字节 + 4个字节（考虑对齐） + 4个字节（指向虚函数的指针）=12字节；\n类B的大小就是等于类A的大小12个字节.\n因为在基类中存在虚函数时，派生类会继承基类的虚函数，因此派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域），而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。所以类B大小为12B",
    "optionB" : "8 8",
    "type" : "1",
    "optionA" : "12 12",
    "question" : "在32位操作系统gcc编译器环境下，下面程序的运行结果为（）\n\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    int b;\n    char c;\n    virtual void print() {\n        cout << \"this is father’s fuction! \" << endl;\n    }\n};\nclass B: A {\npublic:\n    virtual void print() {\n        cout << \"this is children’s fuction! \" << endl;\n    }\n};\nint main(int argc, char * argv[]) {\n    cout << sizeof(A) << \"\" << sizeof(B) << endl;\n    return 0;\n}"
  },
  {
    "ID" : "55e429cfe4b0152a610c833e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "90",
    "optionC" : "93",
    "optionAnswer" : "B",
    "answer" : "93 的二进制 为01011101\n-8 的原码为10001000 补码为11111000\n取与为 01011000 为88",
    "optionB" : "88",
    "type" : "1",
    "optionA" : "85",
    "question" : "运算（93&-8）的结果为?"
  },
  {
    "ID" : "55f2e469e4b0152a61143144",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "I'm a Child， I like football!",
    "optionC" : "I'm a Child， I like basketball!",
    "optionAnswer" : "C",
    "answer" : "I’m a Child, I like basketball!\n这题动态联编，Intro()和Hobby()都是虚函数且通过指针调用，基类指针会向派生类中寻找，找到后执行派生类的函数，所以输出的结果是I’m a Child, I like basketball!",
    "optionB" : "I'm a Parent， I like basketball!",
    "type" : "1",
    "optionA" : "I'm a Parent， I like football!",
    "question" : "下列代码的输出为：\n\nclass CParent \n{\n    public: virtual void Intro()\n    {\n        printf( \"I'm a Parent, \" ); Hobby();\n    }\n    virtual void Hobby()\n    {\n        printf( \"I like football!\" );\n    }\n}; \nclass CChild : public CParent { \n    public: virtual void Intro()\n    {\n        printf( \"I'm a Child, \" ); Hobby();\n    }\n    virtual void Hobby()\n    {\n       printf( \"I like basketball!\\n\" );\n    }\n}; \nint main( void )\n{\n    CChild *pChild = new CChild(); \n    CParent *pParent = (CParent *) pChild; \n    pParent->Intro(); \n    return(0);\n}"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c85",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数的类模板参数须通过构造函数实例化",
    "optionC" : "根据建立对象时的实际数据类型，编译器把类模板实例化为模板类",
    "optionAnswer" : "B",
    "answer" : "普通类可以从类模板派生，但不能从普通类派生出类模板",
    "optionB" : "类模板从普通类派生，也可以从类模板派生",
    "type" : "1",
    "optionA" : "一个普通基类不能派生类模板",
    "question" : "关于类模板，描述错误的是（  ）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de804",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "public或private的类成员",
    "optionC" : "public的类成员",
    "optionAnswer" : "C",
    "answer" : "public: 公有访问，类外部可访问；\nprivate：私有访问，类本身成员函数可访问；\nprotected：保护访问，类本身以及派生子类可访问",
    "optionB" : "private或protected的类成员",
    "type" : "1",
    "optionA" : "所有类成员",
    "question" : "类定义的外部，可以被访问的成员有（ ）。"
  },
  {
    "answer" : "答：能，局部会屏蔽全局。要用全局变量，需要使用\"::\"\n局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。",
    "ID" : "55f2e51ee4b0152a611433be",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "局部变量能否和全局变量重名？"
  },
  {
    "ID" : "55f2e469e4b0152a61143130",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Compile error",
    "optionC" : "Garbage value",
    "optionAnswer" : "C",
    "answer" : "P++后，不指向i的地址，所以未知",
    "optionB" : "12",
    "type" : "1",
    "optionA" : "11",
    "question" : "What is output if you compile and execute the following c code?\n\nvoid main()\n{\n    int i = 11;\n    int const *p = &i;\n    p++;\n    printf(\"%d\",*p);\n}"
  },
  {
    "answer" : "or (int i = len-1; i>=0; i--){\n if (array[i] == i){\n \/\/i--;\n continue;\n }\n int k = array[i];\n while (array[k] != k&&array[k] != i)\n {\n k = array[k];\n }\n  \n swap_with_zero(array, len, i);\n swap_with_zero(array, len, k);\n }",
    "ID" : "55f2e51de4b0152a61143382",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "长度为n的数组乱序存放着0至n-1. 现在只能进行0与其他数的交换，完成以下函数"
  },
  {
    "ID" : "55f2e4fee4b0152a61143231",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "9",
    "optionC" : "36",
    "optionAnswer" : "C",
    "answer" : "将宏表达式展开：c = 6*6\/2*2=36.",
    "optionB" : "18",
    "type" : "1",
    "optionA" : "3",
    "question" : "下面程序的输出是：\n#define f(x) x*x\nmain (){\n  int a=6,b=2,c;\n  c=f(a)\/f(b);\n  printf(\"%d\",c);\n}"
  },
  {
    "answer" : "int rand7()\n{\n    int n=25;\n    while(n>21){\n        n=5*(rand5()-1)+rand5();\n    }\n    return (n%7)+1;\n}",
    "ID" : "55f2e51ee4b0152a611433e5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定能随机生成整数 1 到 5 的函数,写出能随机生成整数 1 到 7 的函数。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143225",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "I'm a Child， I like football!",
    "optionC" : "I'm a Child， I like basketball!",
    "optionAnswer" : "C",
    "answer" : "输出：I’m a Child, I like basketball!\n这题动态联编，Intro()和Hobby()都是虚函数且通过指针调用，基类指针会向派生类中寻找，找到后执行派生类的函数，所以输出的结果是I’m a Child, I like basketball!",
    "optionB" : "I'm a Parent， I like basketball!",
    "type" : "1",
    "optionA" : "I'm a Parent， I like football!",
    "question" : "下列代码的输出为：class CParent \n{\n    public: virtual void Intro()\n    {\n        printf( \"I'm a Parent, \" ); Hobby();\n    }\n    virtual void Hobby()\n    {\n        printf( \"I like football!\" );\n    }\n}; \nclass CChild : public CParent { \n    public: virtual void Intro()\n    {\n        printf( \"I'm a Child, \" ); Hobby();\n    }\n    virtual void Hobby()\n    {\n       printf( \"I like basketball!\\n\" );\n    }\n}; \nint main( void )\n{\n    CChild *pChild = new CChild(); \n    CParent *pParent = (CParent *) pChild; \n    pParent->Intro(); \n    return(0);\n}"
  },
  {
    "answer" : "const在前内容不能变,const在指针后则指针不能变",
    "ID" : "55f2e51ee4b0152a611433db",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "说明以下包含 const 修饰符的语句的意义\na). double * ptr=&value；\nb). const double * ptr=&value;\nc). double *constptr =&value;\nd).const double *const ptr=&value;"
  },
  {
    "ID" : "55f2e46ae4b0152a61143159",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0",
    "optionC" : "72",
    "optionAnswer" : "B",
    "answer" : "b << 8 = 0x5200\nval = 0x5200 | 0x48 = 0x5248 = 21064 ",
    "optionB" : "21064",
    "type" : "1",
    "optionA" : "20992",
    "question" : "以下代码执行后，val的值是___:\n\nunsigned long val = 0;\nchar a = 0x48;\nchar b = 0x52;\nval = b << 8 | a;"
  },
  {
    "ID" : "55f2e4fee4b0152a61143217",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "6，2",
    "optionC" : "5，2",
    "optionAnswer" : "C",
    "answer" : "答案：C\n解释：当输入2时， fun(2)返回2，很容易明白。\n      当输入4时，fun(4)返回： fun(3)+fun(2) = fun(2)+fun(1)+2 = 2+1+2 = 5",
    "optionB" : "4，2",
    "type" : "1",
    "optionA" : "5，1",
    "question" : "如下程序的输出结果是\n\n#include<iostream>\nusing namespace std;\n \nlong fun(int n)\n{\n    if (n > 2)\n        return (fun(n - 1) + fun(n - 2));\n    else\n        return (n);\n}\nint main()\n{\n    int i;\n    cout << \"Needs an integer: \";\n    cin >> i; cout << endl;\n    cout << fun(i) << endl;\n}\n当分别输入4 2时，输出结果分别是？"
  },
  {
    "ID" : "55e429cfe4b0152a610c8338",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "DES",
    "optionC" : "RC4",
    "optionAnswer" : "A",
    "answer" : "MD5是不可逆加密，不可以用来加密文本，DES和RC4是对称加密，RSA是不对称加密，都可以用于文本加密。",
    "optionB" : "RSA",
    "type" : "1",
    "optionA" : "MD5",
    "question" : "Which of the following method(s) CANNOT be used for Text-encryption:"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c65",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "f1和f2都不是静态函数",
    "optionC" : "f1是静态函数，f2不是静态函数",
    "optionAnswer" : "C",
    "answer" : "普通成员函数可以调用静态函数，相反静态函数不能调用普通成员函数，这与普通\n函数与常成员函数相同。因此选择C项。",
    "optionB" : "f1不是静态函数，f2是静态函数",
    "type" : "1",
    "optionA" : "f1和f2都是静态函数",
    "question" : "已知f1和f2是同一类的两个成员函数，但f1不能直接调用f2，这说明（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c5f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "pa是一个具有5个元素的指针数组，每个元素是一个int型指针",
    "optionC" : "pa［5］表示某个数组的第5个元素的值",
    "optionAnswer" : "D",
    "answer" : "指针数组：数组元素都是相同类型的指针，相同类型的指针是说指针所指向的对象\n类型是相同的。例如，语句int *pa［5］;定义了一个指针数组。在指针数组的定义中有两个运\n算符：*和［］，运算符［］的优先级高于*，所以*pa［5］等价于*(pa［5］)，pa［5］表示一\n个数组，而*表示后面的对象为指针变量，合在一起*pa［5］表示一个指针数组。该数组包含5个\n元素，每个元素都是指向int型的指针。所以选择D选项。",
    "optionB" : "pa是一个指向某个数组中第5个元素的指针，该元素是int型变量",
    "type" : "1",
    "optionA" : "pa是一个指向数组的指针，所指向的数组是5个int型元素",
    "question" : "对于int *pa［5］;的描述，正确的是（）"
  },
  {
    "answer" : "Dec-37",
    "ID" : "55f2e51de4b0152a61143352",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "12个元素的排序数组进行二分查找，每个元素被查找的概率是相等的，平均比较次数为"
  },
  {
    "ID" : "55f2e469e4b0152a61143136",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "与编译器相关",
    "optionC" : "{0，不确定}，{1，不确定}",
    "optionAnswer" : "B",
    "answer" : "如果初始化时指定的的元素个数比数组大小少，?剩下的元素都回被初始化为???0?。",
    "optionB" : "{0，0，0，0}，{1，0，0，0}",
    "type" : "1",
    "optionA" : "{0，0，0，0}，{1，1，1，1}",
    "question" : "给定如下代码： int x[4]={0}; int y[4]={1}; 数组x和y的值为（）"
  },
  {
    "ID" : "55f2e46ae4b0152a6114315c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "宏替换不占用程序运行时间",
    "optionC" : "宏名必须用大写字母表示",
    "optionAnswer" : "D",
    "answer" : "A：预处理指令指示在程序正式编译前就由编译器进行的操作,可放在程序中任何位置。\nB：源文件的每一行只能有一条预处理命令，如果指令一行放不下，可以通过反斜杠“\/”进行控制。\nC：宏名通常由大写字母表示，而非必须\nD：宏是在预编译期间进行的，将代码中的指定字符转换，转换结束后，再进行编译，所以不占用程序运行时间",
    "optionB" : "在源文件的一行上可以有多条预处理命令",
    "type" : "1",
    "optionA" : "预处理命令行必须位于源文件的开头",
    "question" : "下列叙述正确的是："
  },
  {
    "ID" : "55e6d85ae4b0152a610de815",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "virtual void print()\\;",
    "optionC" : "virtual void print(){};",
    "optionAnswer" : "B",
    "answer" : "纯虚函数格式：virtual <类型> <函数名> (<参数表>) = 0;",
    "optionB" : "virtual void print()=0;",
    "type" : "1",
    "optionA" : "void virtual print()=0;",
    "question" : "下列为纯虚函数的正确声明的是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114321b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8",
    "optionC" : "4",
    "optionAnswer" : "D",
    "answer" : "C本题考查位运算< <、\/,以及逻辑运算符||。b < <2为8,3 3||b为1,所以结果为8,所以D选项正确。",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "0",
    "question" : "若有定义语句，int b = 2，则表达式(b< <2)\/(3||b)的值是？"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c16",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "寄存器变量",
    "optionC" : "静态变量",
    "optionAnswer" : "B",
    "answer" : "形参或函数中定义的变量都是局部变量。在函数外定义的变量是全局变量。形参只能用局\n部变量，频繁使用的变量可以声明为寄存器变量，形参不能使用静态变量或寄存器变量。",
    "optionB" : "局部变量",
    "type" : "1",
    "optionA" : "全局变量",
    "question" : "在函数定义中的形参属于（）"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8bfd",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "10，30，60",
    "optionC" : "20，40，60",
    "optionAnswer" : "B",
    "answer" : "如果数组元素都是相同类型的指针，则称这个数组为指针数组。指针数组一般用于处理二\n维数组。声明的格式为：<数据类型><(*变量名)><［元素个数］>。\np表示指向数组n的行指针。如果将指针的初始化(*p)［3］=b;地址的等价形式：\np+i p［i］*(p+i)都表示b数组第i+1行的第1个元素的首地址。\n*(p+i)+jp［i］+j &p［i］［j］都表示b数组第i+1行、第j+1列元素的地址。\n值的等价形式：\n*(*(p+i)+j) *(p［i］+j) p［i］［j］都表示b数组第i+1、第j+1列元素的值。\n所以题目分别访问p［0］［0］，p［0］［1］，p［0］［2］。",
    "optionB" : "10，20，30",
    "type" : "1",
    "optionA" : "10，30，50",
    "question" : "下列程序的输出结果是（）\n#include <iostream.h>\nvoid main(){\n    int n[][3] ={10,20,30,40,50,60};\n    int (*p)[3];\n    p=n;\n    cout<<p[0][0]<<\"，\"<<*(p[0]+1)<<\"，\"<<(*p)[2]<<endl;\n}"
  },
  {
    "answer" : "\/\/递归式求最大最小值，时间复杂度O(n) \nvoid findminmax(treenode* tree, int& maxval, int& minval) {\n    if (maxval < tree->val) {\n        maxval = tree->val;\n    }\n    if (minval > tree->val) {\n        minval = tree->val;\n    }\n    if (tree->left != NULL)\n        findminmax(tree->left, maxval, minval);\n    if (tree->right != NULL)\n        findminmax(tree->right, maxval, minval);\n}",
    "ID" : "55f2e51ee4b0152a611433a5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "写一个函数，输入一个二叉树，树中每个节点存放了一个整数值，函数返回这棵二叉树 中相差最大的两个节点间的差值绝对值。请注意程序效率。"
  },
  {
    "ID" : "55f2e469e4b0152a61143128",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "重载函数名可以不同",
    "optionC" : "重载函数必须有不同的形参列表",
    "optionAnswer" : "C",
    "answer" : "重载：必须同名函数；必须参数表不同（包含参数个数不同；参数类型不同；或参数个数与类型都不同）",
    "optionB" : "重载函数形参个数必须不同",
    "type" : "1",
    "optionA" : "重载函数必须具有不同的返回值类型",
    "question" : "下面有关重载函数的说法中正确的是"
  },
  {
    "ID" : "55f2e4fee4b0152a61143247",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "C A B deC",
    "optionC" : "A B C deC",
    "optionAnswer" : "A",
    "answer" : "构造函数的执行先执行父类，再执行子类。析构顺序想反\n\nA B的析构函数不是虚函数，所以不会执行子类的虚函数。 ",
    "optionB" : "C A B deA",
    "type" : "1",
    "optionA" : "A B C deA",
    "question" : "下面这段代码会打印出什么？\n\nclass A\n{\npublic:\n    A()\n    {\n        printf(\"A \");\n    }\n    \/*virtual*\/\n    ~A()\n    {\n        printf(\"deA \");\n    }\n};\n \nclass B\n{\npublic:\n    B()\n    {\n        printf(\"B \");\n    }\n    ~B()\n    {\n        printf(\"deB \");\n    }\n};\n \nclass C: public A, public B\n{\npublic:\n    C()\n    {\n        printf(\"C \");\n    }\n    ~C()\n    {\n        printf(\"deC \");\n    }\n};\nint main()\n{\n    A *a = new C();\n    delete a;\n    return 0;\n}"
  },
  {
    "answer" : "#include <iostream>\nusing namespace std;\nint sum(int n,int m)\n{\n    int res=1;\n    int A[100];\n    A[0]=1;\n    A[1]=0;\n    A[2]=0;\n    if(n<3)\n        return res;\n    for(int i=3;i<=n;i++)\n    {   \n        A[i]=(res-A[i-1]-A[i-2])*m;\n        res+=A[i];\n        if(i>=5)\n            res-=A[i-5];\n    }\n    return res;\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    cout<<sum(n,m)<<endl;\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a61143354",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "某星球上出现了一种怪物， 这种怪物是单亲繁殖，从出生起第3个月起每个月就能繁衍一批后代共m个，但是这种怪物很短命，生存第5个月后就会毙命。目前该星球有一个这样的怪物，请编写程序计算n个月后怪物的总数。(这里我们假定第5个月怪物繁衍后再毙命)"
  },
  {
    "ID" : "55e429cfe4b0152a610c8339",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Many clustered index",
    "optionC" : "clustered index and many non-clustered indexes",
    "optionAnswer" : "D",
    "answer" : "一张表不能有多个丛聚索引",
    "optionB" : "A clustered index",
    "type" : "1",
    "optionA" : "No indexes",
    "question" : "A table CANNOT have one or more of the following index configurations."
  },
  {
    "ID" : "55f2e4fee4b0152a611431f2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "无数次",
    "optionC" : "6",
    "optionAnswer" : "C",
    "answer" : "如果循环体中X得值不改变，!x一直为true，则只需要考虑y的值就可以了，一共6次。",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "0",
    "question" : "for(int x = 0 , y = 0; !x && y <= 5 ; y++)语句执行循环的次数是多少次？"
  },
  {
    "answer" : "N2",
    "ID" : "55f2e51ee4b0152a611433d3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "冒泡排序算法的时间复杂度是什么？"
  },
  {
    "ID" : "55f2e4fee4b0152a61143239",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "求字符串存放的位置",
    "optionC" : "求字符串的长度",
    "optionAnswer" : "C",
    "answer" : "int fun (char *s)\n{\nchar *p=s;\/*将S的地址给p；\nwhile(*p++);\/*没有遇到\/0的时候p一直增加\nreturn p-s-1;\/*原始地址与增加后的地址的差减掉\/0的长度\n}",
    "optionB" : "复制一个字符串",
    "type" : "1",
    "optionA" : "计算字符串的位(bit)数",
    "question" : "下面函数的功能是int fun (char *s)\n{\n    char *p=s;\n    while(*p++);\n    return p-s-1;\n}"
  },
  {
    "answer" : "int rand10()\n{\n    int n=49;\n    while(n>40){\n        n=7*(rand7()-1)+rand7();\n    }\n    return n%10+1;\n}",
    "ID" : "55f2e51ee4b0152a611433e2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "已知rand7()可以产生1~7的7个数(均匀概率),利用rand7() 产 生 rand10() 1~10(均匀概率)。"
  },
  {
    "ID" : "55e6d85ae4b0152a610de805",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "9",
    "optionC" : "4",
    "optionAnswer" : "C",
    "answer" : "把MyClass a[4]，*p[5]；分开写；\nMyClass a[4]；\nMyClass *p[5]；\n则a[4]是类数组，有4个对象，调用构造函数4次\n*p[5]是指针数组，也就是5个元素存放的是指向MyClass类型的对象的指针，没有初始化的指针为空，不指向任何对象，也不调用构造函数。",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "2",
    "question" : "若MyClass为一个类，执行\nMyClass a[4]，*p[5]；\n语句时会自动调用该类构造函数的次数是"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c22",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "数据块",
    "optionC" : " 函数体",
    "optionAnswer" : "A",
    "answer" : "类即数据和操作的组合体，数据是类的静态特征，操作是类具有的动作。",
    "optionB" : "对象",
    "type" : "1",
    "optionA" : "类",
    "question" : "所谓数据封装就是将一组数据和与这组数据有关操作组装在一起，形成一个实体，这实体\n也就是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114320a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "6",
    "optionC" : "5",
    "optionAnswer" : "B",
    "answer" : "函数原型exec((vl，v2)，(v3，v4)，v5，v6);\n用括号括起来的两个形参组成是一个逗号运算符组成的表达式\nC语言中逗号运算符返回最后一个参数作为表达式的值\n所以(vl，v2)和(v3，v4)是两个逗号表达式，相当于两个实参\n所以一共4个实参",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "3",
    "question" : "函数调用exec((vl，v2)，(v3，v4)，v5，v6);中，实参的个数是："
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c81",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数的功能",
    "optionC" : "函数参数类型",
    "optionAnswer" : "D",
    "answer" : "函数原型的格式是?\n返回值类型?函数名（参数列表）；?\n这里面a返回值类型，b参数个数和c参数类型都可以确定了?\n函数原型也叫函数声明，还叫引用说明。其目的是实现先调用函数，后定义函数。",
    "optionB" : "函数参数的个数",
    "type" : "1",
    "optionA" : "函数的返回类型",
    "question" : "在?C++?中，函数原型不能标识?(??)??"
  },
  {
    "answer" : "举例： ask not what your country  can do for you ,but what you can do for your  country\n最长的重复子序列：can do for you\n思路：使用后缀数组解决\n分析：\n1、由于要求最长公共子序列，则需要 找到字符串的所有子序列 ，即通过产生字符串的后缀数组实现。\n2、由于要求最长的重复子序列，则需要对所有子序列进行排序，这样可以把 相同的字符串排在一起 。\n3、 比较 相邻字符串 ，找出两个子串中，相同的字符的个数。\n注意，对于一个子串，一个与其重复最多的字符串肯定是紧挨着自己的两个字符串。\n步骤：\n1、对待处理的字符串 产生后缀数组\n2、 对后缀数组排序\n3、依次 检测相邻两个后缀的公共长度\n4、 取出最大 公共长度 的前缀\n\n举例： 输入字符串 banana\n1、字符串产生的后缀数组：\na[0]:banana\na[1]:anana\na[2]:nana\na[3]:ana\na[4]:na\na[5]:a\n2、对后缀数组进行快速排序，以将后缀相近的（变位词）子串集中在一起\na[0]:a\na[1]:ana\na[2]:anana\na[3]:banana\na[4]:na\na[5]:nana\n之后可以依次检测相邻两个后缀的公共长度并取出最大公共的前缀\n代码：\n\/*给定出一个字符串，输出最长的重复子字符串*\/\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nconst int MaxCharNum = 5000000;\nbool StrCmp(char* str1,char* str2);\nvoid GenSuffixArray(char* str,char* suffixStr[]);\nint ComStrLen(char* str1,char* str2);\nvoid GenMaxReStr(char* str);\nint main()\n{\nchar str[MaxCharNum];\ncin.getline(str,MaxCharNum);\/\/遇到回车结束\nGenMaxReStr(str);\nsystem(\"pause\");\nreturn 1;\n}\nvoid GenMaxReStr(char* str)\n{\nint len = strlen(str);\nint comReStrLen = 0;\nint maxLoc = 0;\nint maxLen = 0;\nchar* suffixStr[MaxCharNum];\nGenSuffixArray(str,suffixStr);\/\/产生后缀数组\n\/\/对后缀数组进行排序\nsort(suffixStr,suffixStr+len,StrCmp);\n\/\/统计相邻单词中相同的字符数，并输出结果\nfor (int i = 0;i < len-1;i++ )\n{\ncomReStrLen = ComStrLen(suffixStr[i],suffixStr[i+1]);\nif (comReStrLen > maxLen)\n{\nmaxLoc = i;\nmaxLen = comReStrLen;\n}\n}\n\/\/输出结果\nfor (int i = 0;i < maxLen;i++)\n{\ncout<<suffixStr[maxLoc][i];\n}\ncout<<endl;\n}\n\/*为字符串产生其后缀数组，并存放到数组suffixStr中*\/\nvoid GenSuffixArray(char* str,char* suffixStr[])\n{\nint len = strlen(str);\nfor (int i = 0;i < len;i++)\n{\nsuffixStr[i] = &str[i];\n}\n}\n\/*返回str1和str2的共同前缀的长度*\/\nint ComStrLen(char* str1,char* str2)\n{\nint comLen = 0;\nwhile(*str1 && *str2)\n{\nif (*str1 == *str2)\n{\ncomLen++;\n}\nstr1++;\nstr2++;\n}\nreturn comLen;\n}\n\/\/字符串升序排序\nbool StrCmp(char* str1,char* str2)\n{\nif (strcmp(str1,str2) >=0 )\n{\nreturn false;\n}\nreturn true;\n}\n程序输入：ask not what your country can do for you,but what you can do for your country\n输出：can ",
    "ID" : "55f2e51ee4b0152a611433e4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个字符串,求出其最长的重复子串。"
  },
  {
    "ID" : "55f2e4fde4b0152a611431ec",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "123444",
    "optionC" : "122444",
    "optionAnswer" : "C",
    "answer" : "首先程序中存在三个MyClass对象。\n前两个对象构造时分别输出1,2\n第三个对象是这样构造的MyClass obj3 = obj1;这里会调用拷贝构造函数，输出2\n然后三个对象依次析构，输出444\n所以最终输出122444",
    "optionB" : "11314444",
    "type" : "1",
    "optionA" : "11214444",
    "question" : "#include<iostream>\nusing namespace std;\nclass MyClass\n{\npublic:\n    MyClass(int i = 0)\n    {\n        cout << i;\n    }\n    MyClass(const MyClass &x)\n    {\n        cout << 2;\n    }\n    MyClass &operator=(const MyClass &x)\n    {\n        cout << 3;\n        return *this;\n    }\n    ~MyClass()\n    {\n        cout << 4;\n    }\n};\nint main()\n{\n    MyClass obj1(1), obj2(2);\n    MyClass obj3 = obj1;\n    return 0;\n}\n运行时的输出结果是（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de806",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "5",
    "optionC" : "8",
    "optionAnswer" : "A",
    "answer" : "本题主要考查了函数的递归调用,解题思路只需要将参数带入函数中,首先是执行f(a,9),递归执行(a,8)直到(a,2),得到a[0]=8,然后判断a[0]是否大于a[1 ],本题实际上就是求出数组a元素的最大值。答案为9,选项A正确。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "9",
    "question" : "若有以下程序#include <stdio.h>\nint f(int a［ ］,int n)\n{\n    if(n > 1)\n    {\n        int t;\n        t=f(a, n-1);\n        return t > a[ n -1 ] ？ t：a［n-1］;\n    }\n    else\n        return a[0];\n}\nmain()\n{ \n    int a［ ］= {8,2,9,1,3,6,4,7,5};\n    printf(\"%d\\n\", f(a, 9));\n}\n则程序的输出结果是?"
  },
  {
    "answer" : "1-999,999：10的5次方 * 6=600,000\n1,000,000 ： 1次\n\n加起来一共600,001次",
    "ID" : "55f2e51ee4b0152a611433b0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "从1到1000000的所有自然数，数字“1”一共出现了多少次？例：自然数101中，数字“1”出现了2次，自然数1011中，数字“1”出现了3次，请写明计算过程及结果。"
  },
  {
    "ID" : "55f2e4fee4b0152a61143202",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Oxf8b821c0",
    "optionC" : "Oxf8b82198",
    "optionAnswer" : "A",
    "answer" : "假设每行有n个元素：\n[9][9] - [4][4] = 21c-140=5n+5\n[7][7] - [4][4]=x- 140 =3n+3\n[7][7] = 140+3\/5*（ 21c-140 ）= 1c4",
    "optionB" : "Oxf8b821a6",
    "type" : "1",
    "optionA" : "Oxf8b821c4",
    "question" : "二维数组X按行顺序存储，其中每个元素占1个存储单元。若X[4][4]的存储地址为Oxf8b82140,X[9][9]的存储地址为Oxf8b8221c,则X[7][7]的存储地址为()"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c6b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "#error",
    "optionC" : "#define",
    "optionAnswer" : "C",
    "answer" : "#if条件编译，＃include文件包含，＃error错误处理。",
    "optionB" : "#include",
    "type" : "1",
    "optionA" : "#if",
    "question" : "在编译指令中，宏定义使用哪个指令（）"
  },
  {
    "answer" : "int Find_Second_Max(int data[],int n)\n{\n    if(n<2) return -1;\n    int max_num = max(data[0],data[1]);\n    int sec_num = min(data[0],data[1]);\n    for(int i=2;i<n;i++)\n    {\n        if(data[i]>=max_num);\n        {\n            sec_num = max_num;\n            max_num = data[i];\n        }\n        else if(data[i] > sec_num)\/\/排除等于情况\n            sec_num = data[i];\n    }\n    return sec_num;\n}",
    "ID" : "55f2e51ee4b0152a6114339f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "写一个函数找出一个整数数组中，第二大的数"
  },
  {
    "ID" : "55f2e46ae4b0152a61143162",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "强度削弱是指执行时间较短的指令等价的替代执行时间较长的指令",
    "optionC" : "For循环的循环控制变量通常很适合调度到寄存器访问",
    "optionAnswer" : "A",
    "answer" : "死代码的含义是指永远不会被执行到的代码段，而不是直接抛弃被注释的代码\n比如while(false){}",
    "optionB" : "函数内联可以避免函数调用中压栈和退栈的开销",
    "type" : "1",
    "optionA" : "死代码删除指的是编译过程直接抛弃掉被注释的代码",
    "question" : "程序的完整编译过程分为是：预处理，编译，汇编等，如下关于编译阶段的编译优化的说法中不正确的是（）?"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143257",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "出现错误",
    "optionC" : "5",
    "optionAnswer" : "C",
    "answer" : "选择c，&a表示一个指向大小为5数组的指针，那么&a+1就是表示一个指向大小为5的下一个数组的指针，也就是数组a最后一个元素的下一个位置，那么int*p=(int*)(&a+1)进行强制类型转换，将指向数组的指针转换为指向第二个数组中首元素的指针，所以p-1则是指向第一个数组中最后一个元素的指针，所以输出是5",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "question" : "以下代码输出什么____.  \n\nmain()\n{\n   int a[5]={1,2,3,4,5};\n   int *p=(int *)(&a+1);\n   printf(\"%d\",*(p-1));\n}"
  },
  {
    "ID" : "55f2e4fee4b0152a611431ff",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "*(*F)(int, int)(int)",
    "optionC" : "int (*(*F)(int, int))",
    "optionAnswer" : "A",
    "answer" : "首先，一个函数指针，指向的函数有两个int形参，这个就是(*F)(int, int)，这返回的是一个指针\n返回一个函数指针，返回的指针指向一个有一个int形参且返回int的函数；把上面的结果当成一个指针，相当于再做一次上面的步骤，所以结果为：int (*(*F)(int, int))(int)",
    "optionB" : "int (*F)(int, int)",
    "type" : "1",
    "optionA" : "int (*(*F)(int, int))(int)",
    "question" : "定义一个函数指针，指向的函数有两个int形参并且返回一个函数指针，返回的指针指向一个有一个int形参且返回int的函数？"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c26",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "在定义该函数时所指定的数据类型",
    "optionC" : "调用该函数时的主调用函数类型",
    "optionAnswer" : "D",
    "answer" : "函数的返回值类型由定义函数时的指定的数据类型决定的。A项的表达式的值要转换\n成函数的定义时的返回类型。",
    "optionB" : "调用该函数时系统随机产生的类型",
    "type" : "1",
    "optionA" : "return语句中的表达式类型",
    "question" : "决定C++语言中函数的返回值类型的是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143205",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "3628800",
    "optionC" : "55",
    "optionAnswer" : "C",
    "answer" : "考的是递归，挺简单的：1+2+…+10=55;",
    "optionB" : "10",
    "type" : "1",
    "optionA" : "0",
    "question" : "给定fun函数如下，那么fun(10)的输出结果是（）\n\nint fun(int x)\n{\n    return (x == 1) ? 1 : (x + fun(x - 1));\n}"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143278",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "这种变量只能是基本类型(如int,char)不能是C++类型",
    "optionC" : "该变量不能在类的成员函数中引用",
    "optionAnswer" : "A",
    "answer" : "Static全局变量和普通全局变量：\n针对：一个工程里有多个cpp文件时\n相同点：存储方式相同，都是静态存储；\n不同点：作用域不同。\n普通全局变量---作用域是整个源程序（含有多个源文件），在各个源文件中都有效\nStatic全局变量----作用域是当前源文件",
    "optionB" : "该变量的值是不可改变的",
    "type" : "1",
    "optionA" : "只能在该cpp所在的编译模块中使用该变量",
    "question" : "在一个cpp文件里面,定义了一个static类型的全局变量,下面一个正确的描述是:"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "A test C test",
    "optionC" : "B test C test",
    "optionAnswer" : "A",
    "answer" : "(( B  *)(& c ))-> func (); 是多态行为 \n(( B ) c ). func (); 不是多态行为。 ",
    "optionB" : "B test B test",
    "type" : "1",
    "optionA" : "C test B test",
    "question" : "<p class=\"p0\">\n    #include \"stdio.h\"\n \nclass A\n{\npublic:\n    virtual void Test()\n    {\n        printf(\"A test\\n\");\n    }\n};\nclass B: public A\n{\npublic:\n    void func()\n    {\n        Test();\n    }\n    virtual void Test()\n    {\n        printf(\"B test\\n\");\n    }\n};\nclass C: public B\n{\npublic:\n    virtual void Test()\n    {\n        printf(\"C test\\n\");\n    }\n};\nvoid main()\n{\n    C c;\n    ((B *)(&c))->func();\n    ((B)c).func();\n}\n \n \n<\/p>\n\n该程序的执行结果"
  },
  {
    "ID" : "55e6d85ae4b0152a610de813",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类模板中的成员函数全部都是模板函数",
    "optionC" : "类模板的参数必须是虚拟类型的",
    "optionAnswer" : "D",
    "answer" : "A：下面列举的几种情况不能省略模板实参：\n1）从模板函数实参表获得的信息有矛盾之处。\n2）需要获得特定类型的返回值，而不管参数的类型如何。\n3）虚拟类型参数没有出现在模板函数的形参表中。\n4）函数模板含有常规形参。\nB：类模板与模板类的概念\n⑴ 什么是类模板 一个类模板（也称为类属类或类生成类）允许用户为类定义一种模式，使得类中的某些数据成员、默写成员函数的参数、某些成员函数的返回值，能够取任意类型（包括系统预定义的和用户自定义的）。\n  如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。\n⑵ 模板类是类模板实例化后的一个产物。可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。\n类模板的重点是模板。表示的是一个模板，专门用于产生类的模子。 模板类的重点是类。表示的是由一个模板生成而来的类。 \nC：类模板有三种类型模板参数：类型模板参数、无类型模板参数和模板模板参数(以模板作为模板的参数)。并不局限于虚拟类型，非虚拟类型也可以作为类模板参数。",
    "optionB" : "类模板与模板类所指的是同一概念",
    "type" : "1",
    "optionA" : "模板的实参在任何时候都可以省略",
    "question" : "下列关于模板的说法正确的是"
  },
  {
    "ID" : "55e6d85ae4b0152a610de80a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "49",
    "optionC" : "25",
    "optionAnswer" : "B",
    "answer" : "在 C\/C++ 中，宏定义只是做简单的字符替换；\n在 #define add(a,b) a+b 中， a+b 没有括号，所以 3* add(4,7) 实际的替换情况是： 3*4+7=19 ；若 a+b 有括号， #define add(a,b) （ a+b ）则结果为： 3* （ 4+7 ） =33 ；",
    "optionB" : "19",
    "type" : "1",
    "optionA" : "33",
    "question" : "输出以下结果：#define add(a,b) a+b\nint main() { \n printf(\"%d\\n\",3 * add(4,7)); \n return 0;\n}"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7ec",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "40",
    "optionC" : "30",
    "optionAnswer" : "C",
    "answer" : "因为指针变量p的初始值指向数组a,所以执行for循环语句后,数组a中的元素的值不变。因此C选项正确。",
    "optionB" : "20",
    "type" : "1",
    "optionA" : "10",
    "question" : "#include <stdio.h>\nmain( )\n{\n    int a [ ] ＝｛10,20,30,40｝,﹡p ＝ a,i;\n    for(i ＝ 0;i <＝ 3;i + +)\n    {\n        a [i]＝﹡p;p + +;\n    }\n    printf(\"%d＼n\",a [2]);\n} \n程序运行后的输出结果是？"
  },
  {
    "answer" : "10盏，1，4，9，16，25，36，49，64，81，100\n按照同学来看，每个同学只会按是自己的倍数的灯。\n那么我们转换成灯来看的话，每个灯只会被是自己的因子的同学按。\n那么一个初始化为灭的灯，如何最后变成一盏亮的灯呢？\n很明显，只有它有奇数个因子的时候，才有可能。\n那么什么时候一个数可以有奇数个因子呢？\n对于任意一个数N ，都可以分解成 N = a * b的乘积，即任意一个数都可以分解成 M个(a * b) 的乘积。\n所以若想满足存在奇数个因子，a 必须等于 b.\n即 N = a2,所以只有平方数最后才满足要求，故可以在0(n)的时间复杂度解决该问题。 ",
    "ID" : "55f2e51de4b0152a61143349",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有编号1~100个灯泡，起初所有的灯都是灭的。有100个同学来按灯泡开关，如果灯是亮的，那么按过开关之后，灯会灭掉。如果灯是灭的，按过开关之后灯会亮。\n现在开始按开关。\n第1个同学，把所有的灯泡开关都按一次(按开关灯的编号： 1,2,3,......100)。\n第2个同学，隔一个灯按一次(按开关灯的编号： 2,4,6,......,100)。\n第3个同学，隔两个灯按一次(按开关灯的编号： 3,6,9,......,99)。\n......\n问题是，在第100个同学按过之后，有多少盏灯是亮着的？这些灯的编号是多少？要求给出解题思路或给出伪码。"
  },
  {
    "answer" : "思路： \nF0=an;\nF1=anx+an-1\nFn=xF(n-1)+an-1\n代码：    \n\nfunction sum(int a[], int n, int x){\n    s=a[n]\n    for(int i=1; i<=n; i++){\n        s += x*s + a[n-i]\n    }\n    return s;\n}",
    "ID" : "55f2e51de4b0152a61143363",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "计算机中处理乘法的指令要比加法复杂的多， 因为在一些关键系统中我们常常会考虑如何尽可能减少乘法的运算。\n现在有如下的表达式\ny= anxn+an-1xn-1 +…..+a1x +a0\n其中an, an-1, ….a1, a0是常数， 给一个x， 要求尽快算出y的值。请尝试写出这样的一个函数。"
  },
  {
    "ID" : "55f2e469e4b0152a6114312f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "car.taxi",
    "optionC" : "1234",
    "optionAnswer" : "B",
    "answer" : "A 关键字; C数字开头;D：有.",
    "optionB" : "$Usdollars",
    "type" : "1",
    "optionA" : "new",
    "question" : "下列标识符合法的有（ ）"
  },
  {
    "ID" : "55f2e469e4b0152a61143139",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上全错",
    "optionC" : "这样做是错误的",
    "optionAnswer" : "A",
    "answer" : "C++的多态肯定是使用父类的指针指向子类的对象，所以肯定是释放子类的对象，如果不使用虚函数的话， 父类的指针就只能够释放父类的对象。",
    "optionB" : "释放子类指针时能正确释放父类对象",
    "type" : "1",
    "optionA" : "释放父类指针时能正确释放子类对象",
    "question" : "C++将父类的析构函数定义为虚函数，下列正确的是哪个？"
  },
  {
    "ID" : "55f2e4fee4b0152a6114323c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "24字节",
    "optionC" : "20字节",
    "optionAnswer" : "B",
    "answer" : "解释 ：\n(1) ch 一个字节 ，但要字节对齐，所以是4个字节\n（2）* ptr 指针 在32为机器侠，是4个字节\n（3）union 取最长的变量的字节数， 是4个字节\n（4）*next 也是指针， 4个字节\n加起来是16个字节。",
    "optionB" : "16字节",
    "type" : "1",
    "optionA" : "12字节",
    "question" : "下面结构体\n\nstruct s1 {\n    char ch, *ptr;\n    union {\n        short a, b;\n        unsigned int c:2, d:1;\n    }\n    struct s1 *next;\n};\n的大小是_____："
  },
  {
    "ID" : "55e6d85ae4b0152a610de814",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "该类的静态数据成员变量的值不可修改",
    "optionC" : "该类的静态方法只能访问该类的静态成员变量",
    "optionAnswer" : "D",
    "answer" : "静态数据成员变量的值可以修改",
    "optionB" : "静态成员变量可被该类的所有方法访问",
    "type" : "1",
    "optionA" : "该类的对象共享其静态成员变量的值",
    "question" : "下列关于一个类的静态成员的描述中，不正确的是"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143268",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "-1",
    "optionC" : "1",
    "optionAnswer" : "D",
    "answer" : "本题考查位运算中按位取反,0按位取反就是－1,所以选项D正确。",
    "optionB" : "0",
    "type" : "1",
    "optionA" : "8",
    "question" : "有以下程序\n\n#include <stdio.h>\nmain(){\n    int i=0;\n    i=～i;\n    printf(\"%d\\n\",i);\n｝\n程序运行后的输出结果是?"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c74",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "a.operator++()",
    "optionC" : "operator++(a,1)",
    "optionAnswer" : "D",
    "answer" : "运算符的重载，前缀先让变量变化。调用＋＋a，等价为a.operator++(),注意无参\n的形式。后缀的话a++,等价于a.operator(0),带形参，形参名可省。",
    "optionB" : "operator++(a)",
    "type" : "1",
    "optionA" : "a.operator++(1)",
    "question" : "如果表达式++a中的“++”是作为成员函数重载的运算符，若采用运算符函数调用格式，则可表示为（）"
  },
  {
    "ID" : "55f2e469e4b0152a61143133",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "用法正确",
    "optionC" : "函数内，外的都有问题",
    "optionAnswer" : "A",
    "answer" : "函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，因为还有'\\0'，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。",
    "optionB" : "函数外的有问题",
    "type" : "1",
    "optionA" : "函数内的有问题",
    "question" : "以下代码中的两个sizeof用法有问题吗？\nvoid UpperCase( char str[] ) \/\/ 将 str 中的小写字母转换成大写字母\n{\n    for ( size_t i = 0; i < sizeof(str) \/ sizeof(str[0]); ++i )\n        if ( 'a' <= str && str <= 'z' )\n            str -= ('a' - 'A' );\n}\nchar str[] = \"aBcDe\";\ncout < < \"str字符长度为: \" < < sizeof(str) \/ sizeof(str[0]) < < endl;\nUpperCase( str );\ncout < < str < < endl;"
  },
  {
    "answer" : "平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。",
    "ID" : "55f2e51ee4b0152a611433d0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "什么是平衡二叉树？"
  },
  {
    "answer" : "1)单台缓存服务器故障,整个分布式缓存集群,可以继续提供服务:\n    热备;\n2)通过一定的分配策略,可以保证充分利用每个缓存服务的存储空间,及负载均衡;\n    当部分服务器故障或系统扩容时,该分配策略可以保证较小的缓存文件重分配开销:\n    单号后三位，用户号后三位，用户账户hash后三位等等；  \n\n3)当不同缓存服务器的存储空间存在差异时,分配策略可以满足比例分配：\n    监控。",
    "ID" : "55f2e51ee4b0152a611433ac",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "在现代系统的设计过程中,为了减轻请求的压力,通常采用缓存技术。为了进一步提升 缓存的命中率,通常采用分布式缓存方案。即前端的调度模块,将针对不同内容的用户请求 分配不同的缓存服务器向用户提供服务。请给出一个分布式缓存方案,满足如下要求:\n1)单台缓存服务器故障,整个分布式缓存集群,可以继续提供服务;\n2)通过一定的分配策略,可以保证充分利用每个缓存服务的存储空间,及负载均衡。当 部分服务器故障或系统扩容时,该分配策略可以保证较小的缓存文件重分配开销。\n3)当不同缓存服务器的存储空间存在差异时,分配策略可以满足比例分配"
  },
  {
    "ID" : "55e6d85be4b0152a610de81e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "多态是为了接口重用，封装和继承是为了代码重用",
    "optionC" : "子类重新定义父类虚函数的方法叫做重载",
    "optionAnswer" : "C",
    "answer" : "子类重新定义父类虚函数的方法叫做覆写",
    "optionB" : "构造函数不可以是虚函数，析构函数可以是虚函数",
    "type" : "1",
    "optionA" : "面向对象的基本特性是封装，继承和多态",
    "question" : "以下关于面向对象的描述错误的是："
  },
  {
    "ID" : "55f2e4fee4b0152a61143250",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "hellothird",
    "optionC" : "first second",
    "optionAnswer" : "D",
    "answer" : "case语句后面没有break，顺序执行。",
    "optionB" : "hello",
    "type" : "1",
    "optionA" : "second third",
    "question" : "以下程序的输出结果是：\n\n#include <iostream.h>\nvoid main() {\n    int x=3,y=3;\n    switch(x%2) {\n        case 1:\n            switch (y) {\n        case 0:cout<<\"first\";\n        case 1:cout<<\"second\";break;\n        default: cout<<\"hello\";\n    }\n    case 2:cout<<\"third\";\n    }\n}"
  },
  {
    "answer" : "12",
    "ID" : "55f2e51ce4b0152a61143327",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "把4000个节点组成一棵二叉树，最小高度是"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c19",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类A的成员函数可以访问类B的对象的任何成员",
    "optionC" : "类C的成员函数可以访问类B的对象的任何成员",
    "optionAnswer" : "C",
    "answer" : "友元说明方法如下：\nfriend?<类名>;\/\/友元类类名\n使用友元可以访问所有成员：\n(1)友元关系不能被继承。\n(2)友元关系是单向的，不具有交换性。所以，B项和D项错误。\n(3)友元关系不具有传递性。所以，A项错误。",
    "optionB" : "类C一定是类A的友元",
    "type" : "1",
    "optionA" : "类A一定是类C的友元",
    "question" : "已知类A是类B的友元，类B是类C的友元，则（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114322e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "200，50",
    "optionC" : "200，-100",
    "optionAnswer" : "B",
    "answer" : "Derived Obj;\nBase *pObj = &Obj;\nprintf(\"%d,\", pObj->Bar((char)(100)))\nprintf(\"%d,\", pObj->Bar(100));\n第一个Bar（char）是非虚函数，因此是静态绑定，静态绑定是指指针指向声明时的对象，pObj声明时为Base类，因此调用的是Base类的Bar（char）\n第二个Bar（char）是虚函数，因此是动态绑定，动态绑定是指指针指向引用的对象，pObj引用Derived对象，因此调用的是Derived类的Bar（int）",
    "optionB" : "100，50",
    "type" : "1",
    "optionA" : "100，-100",
    "question" : "下列一段C++代码的输出是?#include \"stdio.h\"\nclass Base\n {\n public:\n     int Bar(char x)\n     {\n         return (int)(x);\n     }\n     virtual int Bar(int x)\n     {\n         return (2 * x);\n     }\n };\n class Derived : public Base\n {\n public:\n     int Bar(char x)\n     {\n         return (int)(-x);\n     }\n     int Bar(int x)\n     {\n         return (x \/ 2);\n     }\n };\n int main(void)\n {\n     Derived Obj;\n     Base *pObj = &Obj;\n     printf(\"%d,\", pObj->Bar((char)(100)));\n     printf(\"%d,\", pObj->Bar(100));\n }"
  },
  {
    "ID" : "55e429cfe4b0152a610c8336",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "None of the above.",
    "optionC" : "Multiple threads mar cause deadlock,while multiple processes won't cause deadlock.",
    "optionAnswer" : "B",
    "answer" : "B是对的，AC都有错",
    "optionB" : "Changes to the main thread(cancellation，priority change，etc.) may affect the behavior of the other threads of the process; Changes to the parent process does not affect child processes.",
    "type" : "1",
    "optionA" : "Threads share the same address space of the parent process;Processes share the same address space of the parent process.",
    "question" : "Which statement(s) is(are) correct about thread and process？"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114327a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int* (*fun)(int *)",
    "optionC" : "int* fun(int *)",
    "optionAnswer" : "B",
    "answer" : "int (*func)(int*)",
    "optionB" : "int (*fun)(int *)",
    "type" : "1",
    "optionA" : "int (*fun)(int)",
    "question" : "在游戏设计中，经常会根据不同的游戏状态调用不同的函数，我们可以通过函数指针来实现这一功能，请声明一个参数为int *，返回值为int的函数指针。"
  },
  {
    "answer" : "最长公共子序列",
    "ID" : "55f2e51de4b0152a61143387",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个 query 和一个 text,均由小写字母组成。要求在 text 中找出以同样的顺序连 续出现在 query 中的最长连续字母序列的长度。例如, query 为“acbac”,text 为 “acaccbabb”,那么 text 中的“cba”为最长的连续出现在 query 中的字母序列,因此, 返回结果应该为其长度 3。请注意程序效率。"
  },
  {
    "ID" : "55f2e46ae4b0152a61143156",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类的内联函数必须在类体外通过关键字inline定义",
    "optionC" : "类的内联函数必须在类体内定义",
    "optionAnswer" : "B",
    "answer" : "内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。\n内联函数从 源代码 层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用 函数体 替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看 编译器 对该函数定义的具体处理。 \n正确答案选B，C和D都不完全，如果将C和D中的“必须”换成“可以”，那么C和D也是对的。",
    "optionB" : "内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方",
    "type" : "1",
    "optionA" : "内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方",
    "question" : "下列说法正确的是："
  },
  {
    "answer" : "典型的贝叶斯公式，p(甲|废品) = p(甲 && 废品) \/ p(废品) = （0.4 × 0.01） \/（0.4 × 0.01 + 0.6 × 0.02） = 0.25",
    "ID" : "55f2e51ee4b0152a611433b8",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "一个汽车公司的产品，甲厂占40%，乙厂占60%，甲的次品率是1%，乙的次品率是2%，现在抽出一件汽车时次品，问是甲生产的可能性？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de801",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "6",
    "optionC" : "5",
    "optionAnswer" : "B",
    "answer" : "函数原型exec((vl，v2)，(v3，v4)，v5，v6);\n用括号括起来的两个形参组成是一个逗号运算符组成的表达式\nC语言中逗号运算符返回最后一个参数作为表达式的值\n所以(vl，v2)和(v3，v4)是两个逗号表达式，相当于两个实参\n所以一共4个实参",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "3",
    "question" : "函数调用exec((vl，v2)，(v3，v4)，v5，v6);中，实参的个数是："
  },
  {
    "answer" : "public class IsACouldRevertToB { public static boolean didACouldRevertToB(char[] A,char[] B){ if(B==null || B.length != A.length) return false; boolean re = true; int hash = 0; for(int i = 0; i < A.length; i++) { hash |= (1<<(A[i]-'A')); } for(int i = 0; i < B.length; i++) { hash &= (1<<(B[i]-'A')); if(hash==0){ re = false; break; } } \/\/ System.out.println(hash); return re; } public static void main(String[] args) { \/\/ TODO Auto-generated method stub String A = \"ABCD\"; String B = \"defe\"; didACouldRevertToB(A.toCharArray(),B.toCharArray()); } }",
    "ID" : "55f2e51ee4b0152a611433b3",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "字符串ABCD，可以由字符串BCDA或者CDAB通过循环移位而得到。请编程实现以下检测：字符串S1是否可以由字符串S2通 过循环移位而得到。 语言不限（推荐C\/C++,不推荐写伪码）"
  },
  {
    "ID" : "55f2dfa6e4b0152a61142e2d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Many clustered index",
    "optionC" : "clustered index and many non-clustered indexes",
    "optionAnswer" : "D",
    "answer" : "一张表不能有多个丛聚索引",
    "optionB" : "A clustered index",
    "type" : "1",
    "optionA" : "No indexes",
    "question" : "A table CANNOT have one or more of the following index configurations."
  },
  {
    "answer" : "\/\/step1. add same node to nodes in list\n\/\/step2. init the random pointer\n\/\/step3. split the list to two parts, return newNode\n \nNode *deepCopy (Node *head) {\n                    Node *p = head, *q = head->next, *newNode = NULL;\n     \n    \/\/step 1\n    while (p != NULL) {    \n        newNode = (Node *)malloc(sizeof(Node));\n        newNode->next = p->next;\n        p->next = newNode;\n        newNode->value = p->value;\n        newNode->random = NULL;\n \n        p = q;\n        q = q->next;\n    }\n \n    \/\/step 2\n    p = head;\n    q = p->next;\n    while (q != NULL) {\n        if (p->random != NULL)\n            q->random = q->random->next;\n        if (q->next == NULL)\n            break;\n        p = q->next;\n        q = p->next;\n    }  \/\/step 3\n    newNode = head->next;\n    p = head; q = p->next;\n    while (q != NULL) {\n        p->next = q->next;\n        if (q->next == NULL)\n            break;\n        q->next = p->next->next;\n \n        p = p->next;\n        q = q->next;\n    }\n    return newNode;\n}",
    "ID" : "55f2e51ce4b0152a6114332f",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "假设有如下一个链表：struct Node\n{\n    int value ;\n    struct Node *next ;\n    struct Node *random ;\n}\n其中，random指向该链表的任意一个节点或者NULL，请编程实现该链表的深拷贝。Node *deepCopy (Node *head)"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c1b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "派生类是基类的特殊化",
    "optionC" : "派生类是基类定义的延续",
    "optionAnswer" : "B",
    "answer" : "派生类的成员一个是来自基类，一个来自本身，所以派生类是基类的扩展，也是基\n类的具体化和特殊化，派生类是对基类扩展。B项基类不能继承派生类成员，所以错误。",
    "optionB" : "基类继承了派生类的属性",
    "type" : "1",
    "optionA" : "派生类是基类的具体化",
    "question" : "对基类和派生类的关系描述中，错误的是（）"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c76",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "公有继承的公有成员",
    "optionC" : "公有继承的保护成员",
    "optionAnswer" : "D",
    "answer" : "公有成员可以在类外访问，保护类型成员可以在派生类中访问，但不能在类外访问\n，在main函数中访问，说明a是公有成员。只有公有继承时a才能是公有的，所以D项正确。",
    "optionB" : "公有继承的私有成员",
    "type" : "1",
    "optionA" : "私有继承的公有成员",
    "question" : "在main函数中可以用p.a的形式访问派生类对象p的基类成员a，其中a是（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de808",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "5.168",
    "optionC" : "5.169",
    "optionAnswer" : "C",
    "answer" : "本题考查强制类型转换与输出格式。%f的输出格式是以带小数点的数学形式输出浮点数。首先计算x * 1000,结果为5168.94然后+0.5,结果为5169.44,然后进行强制类型转换,转换成整型为5169,然后除以双精度数据1000,结果也为双精度数据5.169,输出时按照%f的格式输出,所以输出结果为5.169000。",
    "optionB" : "5.175",
    "type" : "1",
    "optionA" : "5.17",
    "question" : "若有以下程序段double x =5.16894;\nprintf(\"%f\\n\",(int)(x * 1000+0.5)\/(double)1000 );\n则程序段的输出结果是"
  },
  {
    "answer" : "非递归可运行代码：\n\ntypedef struct node {\n    struct node *next;\n    int data;\n} node;\nvoid createList(node **head, int data)\n{\n    node *pre, *cur, *new;\n    pre = NULL;\n    cur = *head;\n    while (cur != NULL) {\n        pre = cur;\n        cur = cur->next;\n    }\n    new = (node *)malloc(sizeof(node));\n    new->data = data;\n    new->next = cur;\n    if (pre == NULL)\n    *head = new;\n    else\n    pre->next = new;\n}\nvoid printLink(node *head)\n{\n    while (head->next != NULL) {\n        printf(\"%d \", head->data);\n        head = head->next;\n    }\n    printf(\"%dn\", head->data);\n}\nint linkLen(node *head)\n{\n    int len = 0;\n    while (head != NULL) {\n        len ++;\n        head = head->next;\n    }\n    return len;\n}\nnode* reverseK(node *head, int k)\n{\n    int i, len, time, now;\n    len = linkLen(head);\n    if (len < k) {\n        return head;\n        } else {\n        time = len \/ k;\n    }\n    node *newhead, *prev, *next, *old, *tail;\n    for (now = 0, tail = NULL; now < time; now ++) {\n        old = head;\n        for (i = 0, prev = NULL; i < k; i ++) {\n            next = head->next;\n            head->next = prev;\n            prev = head;\n            head = next;\n        }\n        if (now == 0) {\n            newhead = prev;\n        }\n        old->next = head;\n        if (tail != NULL) {\n            tail->next = prev;\n        }\n        tail = old;\n    }\n    if (head != NULL) {\n        tail->next = head;\n    }\n    return newhead;\n}\nint main(void)\n{\n    int i, n, k, data;\n    node *head, *newhead;\n    while (scanf(\"%d %d\", &n, &k) != EOF) {\n        for (i = 0, head = NULL; i < n; i ++) {\n            scanf(\"%d\", &data);\n            createList(&head, data);\n        }\n        printLink(head);\n        newhead = reverseK(head, k);\n        printLink(newhead);\n    }\n    return 0;\n}\n",
    "ID" : "55f2e51ee4b0152a611433ad",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "k链表翻转。给出一个链表和一个数k，比如链表1→2→3→4→5→6，k=2，则翻转后2→1→4→3→6→5，若k=3,翻转后3→2→1→6→5→4，若k=4，翻转后4→3→2→1→5→6，用程序实现。"
  },
  {
    "answer" : "答：和while(1)相同。",
    "ID" : "55f2e51ee4b0152a611433c1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "语句for( ;1;)有什么问题？它是什么意思？"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143276",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "6，8，8",
    "optionC" : "6，8，4",
    "optionAnswer" : "D",
    "answer" : "sizeof对数组求长度为数组的真实长度，字符串数组的长度要加上最后的'\\0'字符。\n64位机器的指针占8个字节。",
    "optionB" : "6，6，4",
    "type" : "1",
    "optionA" : "5，5，8",
    "question" : "在linux下64位c程序，请计算输出的三个sizeof分别是（）\n\nvoid func(char str_arg[100])\n{\n     cout<<sizeof(str_arg)<<endl;\n}\nint main(int argc,char* argv[])\n{\n     char str[]=\"Hello\";\n     char *p=str;\n     cout<<sizeof(str)<<endl;\n     cout<<sizeof(p)<<endl;\n     func(\"test\");\n     return 0;\n}"
  },
  {
    "answer" : "网络号和主机号",
    "ID" : "55f2e51ee4b0152a611433d6",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "IP地址的编码分为哪俩部分？"
  },
  {
    "answer" : "if (fabs(x) < 0.00001f)",
    "ID" : "55f2e51ee4b0152a611433d4",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "写出float x 与“零值”比较的if语句。"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143277",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "a.y[3]=11",
    "optionC" : "a.y[2]=11",
    "optionAnswer" : "D",
    "answer" : "小端是数据地位存储在内存低位,所以y[0]=0x44",
    "optionB" : "a.y[1]=11",
    "type" : "1",
    "optionA" : "a.y[0]=11",
    "question" : "在小端序的机器中,如果 \n\nunion X{\n    int x;\n    char y[4];\n};\n如果:\nX a;\na.x=0x11223344;\/\/16 进制 则:______"
  },
  {
    "ID" : "55f2e469e4b0152a61143132",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "要正确的实现虚函数，只能用一个基类的指针或者引用来指向派生类对象",
    "optionC" : "和类的静态成员函数与非类的成员函数相比，虚函数的效率较低",
    "optionAnswer" : "A",
    "answer" : "虚函数的作用是实现了多态性?",
    "optionB" : "虚函数的作用就是实现“动态联编”，也就是在程序的运行阶段动态地选择合适的成员函数",
    "type" : "1",
    "optionA" : "虚函数的作用是实现了继承性",
    "question" : "下面有关虚函数的描述，说法错误的是？"
  },
  {
    "ID" : "55f2e46ae4b0152a61143164",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "无任何作用",
    "optionC" : "指向独立的数据空间",
    "optionAnswer" : "C",
    "answer" : "1.这个叫柔性数组，它的作用跟指针差不多，但是指针占空间，而它不占空间，这就意味着可以节省空间。\n2.该数组的内存地址就和它后面的元素地址相同，意味着无需初始化，数组名就是后面元素的地址，直接就能当指针使用。例如，制作动态buffer，可以这样分配空间malloc(sizeof(structXXX) + buff_len); 直接就把buffer的结构体和缓冲区一块分配了。这样使用释放一次即可，如果使用指针，则需要释放两次。\n3.也可以写成data[1]或data[]，是考虑到可移植性的原因，因为有些编译器不支持0数组。",
    "optionB" : "数据分割位",
    "type" : "1",
    "optionA" : "维护数据包空间的连续性",
    "question" : "定义网络传输数据包为 \nclass packet{\n     int size;\n     void data[0];\n}\n其中data的作用是？"
  },
  {
    "answer" : "int find(node * root, int val) {\n    int ret = 1;\n \n    if (root->get_data() == val) {\n        return ret;\n    } else {\n        int  ret1 = 1 + find(root->get_left(), val);\n        int  ret2 = 1 + find(root->get_right(), val);\n        if (ret1 > ret2)\n            ret = ret2;\n        else\n            ret = ret1;\n \n        return ret;\n    }\n}",
    "ID" : "55f2e51de4b0152a61143362",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给出二叉树接口为\n\nclass node\n{\n    node *get_left();\n    node *get_right();\n    int get_data();\n}\n找出值为val的最浅节点所在层数。\n\nint find(node *root, int val)."
  },
  {
    "ID" : "55e6d85ae4b0152a610de80e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "++（a-b--）",
    "optionC" : "c+++c+++c++",
    "optionAnswer" : "C",
    "answer" : "因为9是一个常量，常量不能自增自减，而（ x+y ）和下面的（ a -b ）都是作为一种只读内存区存在的，所以都不能进行自增自减操作。题目其实不严谨，c中c如果作为一个变量那么是正确的，但是如果c的类型是数组也不正确。",
    "optionB" : "（x+y）++",
    "type" : "1",
    "optionA" : "9++",
    "question" : "下列表达式正确的是："
  },
  {
    "ID" : "55f2e4ffe4b0152a6114326b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "执行2次",
    "optionC" : "执行1次",
    "optionAnswer" : "A",
    "answer" : "这是一个死循环，for中两个分好中间为判断条件，为真则执行。这里为1，相当于true，也就是死循环。等价于for(;;)也等价于while(1)",
    "optionB" : "编译错误",
    "type" : "1",
    "optionA" : "死循环",
    "question" : "语句for( ;1;)是什么意思？"
  },
  {
    "answer" : "4个球队单循环一共赛6场。\n可能出线的最低分应该是小组第二名两平一负得2分，即第一名三场全胜得9分，剩下三名皆两平一负得2分，其中进球多的那只出线。",
    "ID" : "55f2e51ee4b0152a611433af",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "4个足球队打小组单循环，计分方式：胜3分平1分负0分，如果计分相同，则净胜球多的队伍排名靠前，如果净胜球还一样，则进球多的球队排名靠前。小组前两名出线。问可能出线的最低分数是多少。请说明推理过程。 备注：单循环赛是指所有参加比赛的队两两之间都比赛一次，最后按各队在全部比赛中的积分，得失分率排列名次。"
  },
  {
    "answer" : "栈：栈存在于RAM中。栈是动态的，它的存储速度是第二快的。stack\n堆：堆位于RAM中，是一个通用的内存池。所有的对象都存储在堆中。heap\n\n2 申请方式\nstack【栈】: 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 。\nheap【堆】: 需要程序员自己申请，并指明大小，在c中malloc函数 如p1 = (char *)malloc(10); 在C++中用new运算符 如p2 = (char *)malloc(10); 但是注意：p1、p2本身是在栈中的。\n\n3 申请后系统的响应\n栈【stack】：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。\n堆【heap】：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序；另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。\n\n4 申请大小的限制\n栈【stack】：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。\n堆【heap】：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。\n\n5 申请效率的比较\n栈【stack】：由系统自动分配，速度较快。但程序员是无法控制的。\n堆【heap】：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便.  另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。\n6 堆和栈中的存储内容\n栈【stack】：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。\n堆【heap】：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 7 存取效率的比较 char s1[] = \"aaaaaaaaaaaaaaa\";  char *s2 = \"bbbbbbbbbbbbbbbbb\";  aaaaaaaaaaa是在运行时刻赋值的； 而bbbbbbbbbbb是在编译时就确定的； 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。",
    "ID" : "55f2e51ee4b0152a611433da",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "阐述栈和堆在生命周期、速度、内存性能等方面的不同点。假如现在有一个缓冲 区域绝大多数只需要 1KB 空间，极少数极端情况下需要 100MB，怎么样合理分配内 存？"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c5e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "所有特性，但不允许增加新的特性或重定义基类的特性",
    "optionC" : "所有特性，并允许增加新的特性或重定义基类的特性",
    "optionAnswer" : "A",
    "answer" : "派生类有两类成员：一是基类，二是自身类。派生类中的成员不能访问基类中的私",
    "optionB" : "部分特性，但不允许增加新的特性或重定义基类的特性",
    "type" : "1",
    "optionA" : "部分特性，并允许增加新的特性或重定义基类的特性",
    "question" : "C++的继承性允许派生类继承基类的（）"
  },
  {
    "ID" : "55f2e46ae4b0152a6114315d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "依赖倒置原则（Dependecy-Inversion Principle）",
    "optionC" : "抽象类原则（Abstract-Class principle）",
    "optionAnswer" : "C",
    "answer" : "面向对象的五大基本原则\n\n单一职责原则（SRP）\n开放封闭原则（OCP） \n里氏替换原则（LSP） \n依赖倒置原则（DIP） \n接口隔离原则（ISP）",
    "optionB" : "开放封闭原则（Open-Closed principle）",
    "type" : "1",
    "optionA" : "单一职责原则（Single-Resposibility Principle）",
    "question" : "下面不是面向对象的基本原则的是？"
  },
  {
    "answer" : "#两个指针，分别从头和从尾遍历数组，详见代码，已测试通过\n\n#include <stdio.h>\n#include <stdlib.h>\n#define bool int\n#define false 0\n#define true 1\nvoid Reorder(int *pData, unsigned int length, bool (*func)(int));\nbool isEven(int n);\nvoid ReorderOddEven_1(int *pData, unsigned int length)\n{\n    if(pData == NULL || length == 0)\n        return;\n    int *pBegin = pData;\n    int *pEnd = pData + length - 1;\n    while(pBegin < pEnd)\n    {\n        \/\/ 向后移动pBegin，直到它指向偶数\n        while(pBegin < pEnd && (*pBegin & 0x1) != 0)\n            pBegin ++;\n        \/\/ 向前移动pEnd，直到它指向奇数\n        while(pBegin < pEnd && (*pEnd & 0x1) == 0)\n            pEnd --;\n        if(pBegin < pEnd)\n        {\n            int temp = *pBegin;\n            *pBegin = *pEnd;\n            *pEnd = temp;\n        }\n    }\n}\nvoid Reorder(int *pData, unsigned int length, bool\n  (*func)(int))\n{\n    if(pData == NULL || length == 0)\n        return;\n    int *pBegin = pData;\n    int *pEnd = pData + length - 1;\n    while(pBegin < pEnd)\n    {\n        \/\/向后移动pBegin\n        while(pBegin < pEnd &&!func(*pBegin))\n            pBegin ++;\n        \/\/ 向前移动pEnd\n        while(pBegin < pEnd &&func(*pEnd))\n            pEnd --;\n        if(pBegin < pEnd)\n        {\n            int temp = *pBegin;\n            *pBegin = *pEnd;\n            *pEnd = temp;\n        }\n    }\n}\nbool isEven(int n)\n{\n    return (n & 1) == 0;\n}",
    "ID" : "55f2e51ee4b0152a611433a2",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "仅用O(1)的空间，将整数数组按奇偶数分成2部分，数组左边是奇数、右边是偶数。（要求：给出完整代码，尽量高效，简洁）"
  },
  {
    "answer" : "这道题想等概率产生0、1，就需要找到两个独立事件，这个两个独立事件发生的概率相同，已知随机数生成器可以以p产生0，以1-p产生1，所以有下面4个独立事件，用随机数生成器产生00，01，10，11，各自的概率分别为p*p，p*(1-p)，(1-p)*p，(1-p)*(1-p)可以发现生成01，10的概率相同，因此只保留这两种情况敏感词舍弃，然后将01映射为0，10映射为1，则等概率0，1随机数生成器可得到",
    "ID" : "55f2e51ee4b0152a611433ae",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一个随机数发生器，以概率P产生0，概率(1-P)产生1，请问能否利用这个随机数发生器，构造出新的发生器，以1\/2的概率产生0和1。请写明结论及推理过程。"
  },
  {
    "answer" : "public static void main(String[] args) {\n        String s1 = \"asdfghjqweryuiase\";\n        String s2 = \"astyfrtfghjqwsa\";\n        System.out.print(findMaxSame(s1, s2));\n    }\n    private static String findMaxSame(String s1, String s2) {\n        int l1 = s1.length();\n        String maxSame = \"\";\n        String subString = \"\";\n        for (int i = 0; i < l1; i++) {\n            for (int j = i + 1; j < l1; j++) {\n                subString = s1.substring(i, j);\n                if (s2.indexOf(subString) >= 0) {\n                    maxSame = subString.length() > maxSame.length() ? subString : maxSame;\n                } else {\n                    break;\n                }\n            }\n        }\n        return maxSame;\n    }",
    "ID" : "55f2e51ee4b0152a611433bb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给两个字符串，输出其最长共同字符串的长度：如\nS1: asdfghjqweryuiase \nS2: astyfrtfghjqwsa \n其最长共同字符串为fghjqw 长度为6，给出代码。"
  },
  {
    "answer" : "首先,为了保证成功,两颗棋子不能全碎. 那么经过计算,第一次应该在16层尝试.如棋子碎则从1-15层继续尝试.这样最多尝试16次可以得到结果. 如16层棋子未碎,则第二次应该在16+16-1=31层尝试.这样可以保证最多尝试次数仍然为16次.往下类似. 这样得到最终结果是: 第一颗棋子应该依次在16,31,45,58,70,81,91这七层尝试.如在其中某层碎了则继续用第2颗在相邻两次尝试楼层中间继续尝试.这样最多只需要16次尝试可以确定此临界值.",
    "ID" : "55f2e51ee4b0152a611433c8",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有一幢100层高的大楼，给你两个完全相同的玻璃围棋子。假设从某一层开始，丢下玻璃棋子就会破碎。那么怎么利用手中的两颗棋子，用一种什么样的最优策略，知道这个临界的层高呢？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "两个都是判断以后再循环",
    "optionC" : "前一个判断以后再循环，后一个循环一遍再判断",
    "optionAnswer" : "B",
    "answer" : "do……while先做一次do代码块中的内容，即先做一次循环，然后判断while条件\n\nwhile……do与之相反，先判定while条件，如果成立，则进行循环 ",
    "optionB" : "前一个循环一遍再判断，后一个判断以后再循环",
    "type" : "1",
    "optionA" : "两个都是循环一遍再判断",
    "question" : "do……while和while……do有什么区别？"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c8b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "抽象类",
    "optionC" : "派生类",
    "optionAnswer" : "D",
    "answer" : "如果父类的函数（方法）根本没有必要或者无法实现，完全要依赖子类去实现的话，可以把此函数（方法）设为virturl 函数名=0 。我们把这样的函数（方法）称为纯虚函数。 如果一个类包含了纯虚函数，称此类为抽象类。",
    "optionB" : "纯基类",
    "type" : "1",
    "optionA" : "基类",
    "question" : "若一个类中含有纯虚函数，则该类称为（   ）"
  },
  {
    "ID" : "55f2e4fde4b0152a611431ee",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "register \"C\"",
    "optionC" : "explict \"C\"",
    "optionAnswer" : "B",
    "answer" : "void f(void)用c++ compiler来编译，在产生的obj文件中的名字变成了 \n\n$f@@@_@0 \n\nvoid f(voi)用c compiler编译，obj中变成了 \n\n_f \n\n如果是extern \"C\" void f(void)，仍然用c++编译器编译，变成 \n\n_f \n\n所以extern \"C\"是强迫c++编译器对函数名进行修饰的时候采用c命名约定。 \n\n这样，在c++写的程序中就可以使用已经用c编译器编译好的obj或者lib了。",
    "optionB" : "extern \"C\"",
    "type" : "1",
    "optionA" : "static \"C\"",
    "question" : "C++里面如何声明const void f(void)函数为C程序中的库函数。"
  },
  {
    "ID" : "55b22670e4b0bb7ded0a8c5c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "函数",
    "optionC" : "静态变量",
    "optionAnswer" : "B",
    "answer" : "变量存储类可分为两类：全局变量和局部变量。\n（1）全局变量：在函数外部定义的变量称为全局变量，其作用域为：从定义变量的位置开始到\n源程序结束。使用全局变量降低了程序的可理解性，软件工程学提倡尽量避免使用全局变量。\n（2）局部变量：在函数内部定义的变量称为局部变量，其作用域为：从定义变量的位置开始到\n函数结束。局部变量包含自动变量（auto）静态变量（static）以及函数参数。形参不能是静态\n的。所以选择B项。",
    "optionB" : "局部变量",
    "type" : "1",
    "optionA" : "全局变量",
    "question" : "C++语言中所有在函数中定义的变量，连同形式参数，都属于（）"
  },
  {
    "ID" : "55f2e4fee4b0152a61143230",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "14",
    "optionC" : "13",
    "optionAnswer" : "A",
    "answer" : "本题考查几点，一是静态变量，只分配一次，在下一次使用它时仍维持上次调用产生的结果，a=2,然后a++之后变成3，下次调用时仍维持3；二是全局变量和局部变量的生存期，i=0为全局变量，i=2为局部变量。",
    "optionB" : "12",
    "type" : "1",
    "optionA" : "11",
    "question" : "下面程序的输出结果是()\n\n#include <iostream>\nusing namespace std;\nint i = 0;\nint fun( int n )\n{\n    static int a = 2;\n    a++;\n    return(a * n);\n}\n \n \nint main()\n{\n    int k = 5;\n    {\n        int i = 2;\n        k += fun( i );\n    }\n    k += fun( i );\n    cout << k;\n    return(0);\n}"
  },
  {
    "ID" : "55f2e4fde4b0152a611431ea",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "printf(\"\\\"My salary was increased by 15%%!\\\"\\n\");",
    "optionC" : "printf(\"My salary was increased by 15'%'!\\n\");",
    "optionAnswer" : "D",
    "answer" : "A： 没\\!这转义符，编译时报错\nB，C： 一看前面输出时就少了双引号\n\nD是对的，里面%%是输出的%，虽然有些编译器\\%也能输出%，但貌似标准c不支持",
    "optionB" : "printf(\"My salary was increased by 15%!\\n\");",
    "type" : "1",
    "optionA" : "printf(\"\\\"My salary was increased by 15\/%\\!\\\"\\n\");",
    "question" : "\"My salary was increased by 15%!\"\n下列哪个选项可以准确的显示出上述语句？"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143274",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "int f(int x，float y)",
    "optionC" : "float f(int x，float y)",
    "optionAnswer" : "A",
    "answer" : "考察函数重载\n   函数名相同，但：函数参数个数不同，或者函数参数类型不同 或者个数和类型都不同。  ",
    "optionB" : "int f(float a，int b)",
    "type" : "1",
    "optionA" : "int f(int x，int y)",
    "question" : "在C++语言中，若类C中定义了一个方法int f(int a，int b)，那么方法( )不能与该方法同时存在于类C中。"
  },
  {
    "ID" : "55b22670e4b0bb7ded0a8c5d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "不受保护",
    "optionC" : "受保护",
    "optionAnswer" : "A",
    "answer" : "私有继承下，基类中的公有或保护成员在派生类中也是私有的，所以选择A选项。",
    "optionB" : "保持不变",
    "type" : "1",
    "optionA" : "受限制",
    "question" : "在私有继承的情况下，基类成员在派生类中的访问权限（）"
  },
  {
    "ID" : "55f2e4fee4b0152a6114324e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "变量A与a按位相与作为函数Set（）的参数。",
    "optionC" : "a是类A的对象引用，用来作函数Set（）的形参；",
    "optionAnswer" : "C",
    "answer" : "a是类A的对象引用，用来作函数Set（）的形参",
    "optionB" : "将a的地址值赋给变量Set；",
    "type" : "1",
    "optionA" : "指向类A的指针为a;",
    "question" : "已知：类A中一个成员函数说明如下：void Set(A&a);其中，A&a的含意是"
  },
  {
    "ID" : "55e6d85be4b0152a610de824",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "32",
    "optionC" : "24",
    "optionAnswer" : "C",
    "answer" : "指针在64位系统中占用8个字节，A类中有3个指针，故占用24个字节。B类继承自A类且无成员变量和虚函数表，占用字节和A相同。",
    "optionB" : "16",
    "type" : "1",
    "optionA" : "8",
    "question" : "在64位系统中，有如下类：class A\n{\npublic:\n    void *p1;\nprivate:\n    void *p2;\nprotected:\n    void *p3;\n};\nclass B: public A {};\n那么sizeof(B)的数值是（）"
  },
  {
    "answer" : "0,1背包问题，时间复杂度O(n*max)\nint getFirstUnFormedNum(vector<int> arr, int len) {      \nint i,j;          \nint mi = arr[0],sum = 0;          \nfor (i = 0;i<len;i++)          \n{              \nsum sum  +=  arr [ i ];              \nif   ( arr [ i ]< mi )                  \nmi  =  arr [ i ];          \n}          \nvector <int>  dp ( sum + 1 , 0 );          \nfor   ( i  =   0 ; i < len ; i ++)              \nfor   ( j  =  sum ; j >= arr [ i ]; j --)              \n{                  \nif   ( dp [ j - arr [ i ]]+ arr [ i ]> dp [ j ])                      \ndp [ j ]   =  dp [ j - arr [ i ]]+ arr [ i ];                  \nelse                      \ndp [ j ]   =  dp [ j ];              \n}          \nfor   ( i  =  mi ; i <= sum ; i ++)          \n{              \nif   ( i  !=  dp [ i ])                \nreturn  i ;          \n}          \nreturn  i ;      \n} ",
    "ID" : "55f2e51de4b0152a61143343",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定一个全是正数的数组arr，定义一下arr的最小不可组成和的概念： 1，arr的所有非空子集中，把每个子集内的所有元素加起来会出现很多的值，其中最小的记为min，最大的记为max； 2，在区间[min,max]上，如果有一些正数不可以被arr某一个子集相加得到，那么这些正数中最小的那个，就是arr的最小不可组成和； 3，在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和； 举例： arr = {3,2,5} arr的min为2，max为10，在区间[2,10]上，4是不能被任何一个子集相加得到的值中最小的，所以4是arr的最小不可组成和； arr = {3,2,4} arr的min为2，max为9，在区间[2,9]上，8是不能被任何一个子集相加得到的值中最小的，所以8是arr的最小不可组成和； arr = {3,1,2} arr的min为1，max为6，在区间[2,6]上，任何数都可以被某一个子集相加得到，所以7是arr的最小不可组成和； 请写函数返回arr的最小不可组成和。"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c24",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "引进了类和对象的概念",
    "optionC" : "规定函数说明符必须用原型",
    "optionAnswer" : "D",
    "answer" : "C++是一面向对象的语言，面向对象的特征，抽象、多态、继承和封装。",
    "optionB" : "允许函数重载，并允许设置缺省参数",
    "type" : "1",
    "optionA" : "增加了一些新的运算符",
    "question" : "C++对C语言做了很多改进，即从面向过程变成为面向对象的主要原因是（）"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f1",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "2，4",
    "optionC" : "1，3",
    "optionAnswer" : "A",
    "answer" : "答案A(1, 4)\n解释：首先看看各个容器的erase(pos)实现吧：\n1. vector，erase(pos)，直接把pos+1到finish的数据拷贝到以pos为起点的区间上，也就是vector的长度会逐渐变短，同时iter会逐渐往后移动，直到iter == cont.end()，由于容器中end()返回的迭代器是最后一个元素的下一个（这个地方没有任何值），现在考虑这个状态前一个状态，此时要删除的点是iter, tempIt = iter, ++iter会指向此时的end()，但是执行erase(tempIt)之后，end()向前移动了！！！问题来了，此时iter空了！！！不崩溃才怪。\n\n2. list，erase(pos)，干的事情很简单，删除自己，前后的节点连接起来就完了，所以iter自增的过程不会指空，不会崩溃喽。\n\n3. map，erase(pos)，干的事情太复杂，但是我们需要知道的信息其实很少。该容器底层实现是RBTree，删除操作分了很多种情形来讨论的，目的是为了维持红黑树性质。但是我们需要知道的就是每个节点类似于list节点，都是单独分配的空间，所以删除一个节点并不会对其他迭代器产生影响，对应到题目中，不会崩溃喽。\n\n4. deque，erase(pos)，与vector的erase(pos)有些类似，基于结构的不同导致中间有些步骤不太一致。先说说deque的结构（这个结构本身比较复杂，拣重要说吧，具体看STL源码），它是一个双向开口的连续线性空间，实质是分段连续的，由中控器map维持其整体连续的假象。其实题中只要知道它是双向开口的就够了（可以在头部或尾部增加、删除）。在题中有erase(pos)，deque是这样处理的：如果pos之前的元素个数比较少，那么把start到pos-1的数据移到起始地址为start+1的区间内；否则把pos后面的数据移到起始地址为pos的区间内。在题中iter一直往后移动，总会出现后面数据比前面少的时候，这时候问题就和1一样了，必须崩溃！",
    "optionB" : "2，3",
    "type" : "1",
    "optionA" : "1，4",
    "question" : "CONTAINER::iterator iter , tempIt;\nfor (iter = cont.begin() ; iter != cont.end() ; )    　　\n{\n    tempIt = iter;\n    ++iter;\n    cont.erase(tempIt);\n    　　\n}\n \n假设cont是一个CONTAINER的示例，里面包含数个元素，那么当CONTAINER为： 1、vector 2、list 3、map 4、deque 会导致上面的代码片段崩溃的CONTAINER类型是？"
  },
  {
    "answer" : "队列先进先出，栈后进先出",
    "ID" : "55f2e51ee4b0152a611433c5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "队列和栈有什么区别？"
  },
  {
    "answer" : "答：首先，1000亿条记录全部放到内存肯定不够，那就是分成小文件了，然后整合；\n公共的时间段，因为精确到分钟，我们把这每一分钟建成一个小文件，每个小文件肯定会有许多重复的ip，url；\n现在统计每个小的文件中url的访问量和ip的访问次数，方法就是建立索引；\n（建立索引的目的是为了减少查询次数，但是随着索引级数增多也会造成花更多的时间在建立索引上）；\n建立url的索引，假如是www.nowcoder.com\/question,可以分别给www.nowcoder.com和question建立索引，那么来了一条url，先看一级索引是不是匹配，匹配再看二级索引，相同的话就是我们要的url目标；\nip的索引也是一样，ip分成4段建立索引；\n所以这里影响效率的就是在索引建立这块，索引建立好那就是查询的事了的，就会变得非常快。\n假定给定了某个时间段，找出url的访问量，那么先找到给定的时间段，对应着刚开始分割的小的文件（每一个分钟）中搜索，通过索引找到相同的url之后，开始统计，直到搜索完所有的给定时间段内的所有的小的文件；\n求ip的访问次数也是一样，按照给定的时间段，找到对应的小的文件，通过索引找到相同的ip后统计，直到搜索完了给定时间段内的所有的小的文件。",
    "ID" : "55f2e51de4b0152a6114333d",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "有1000亿条记录，每条记录由url,ip,时间组成，设计一个系统能够快速查询以下内容\n1.给定url和时间段（精确到分钟）统计url的访问次数\n2.给定ip和时间段（精确到分钟）统计ip的访问次数"
  },
  {
    "answer" : "1．对于每盏灯，拉动的次数是奇数时，灯就是亮着的，拉动的次数是偶数时，灯就是关着的。\n2．每盏灯拉动的次数与它的编号所含约数的个数有关，它的编号有几个约数，这盏灯就被拉动几次。 \n3．1——100这100个数中有哪几个数，约数的个数是奇数。我们知道一个数的约数都是成对出现的，只有完全平方数约数的个数才是奇数个。 所以这100盏灯中有10盏灯是亮着的。 它们的编号分别是： 1、4、9、16、25、36、49、64、81、100。",
    "ID" : "55f2e51de4b0152a61143367",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "现在有100个灯泡，每个灯泡都是关着的，第一趟把所有的灯泡灯泡打开，第二趟把偶数位的灯泡制反（也就是开了的关掉，关了的打开），第三趟让第3,6,9....的灯泡制反.......第100趟让第100个灯泡制反，问经过一百趟以后有多少灯泡亮着。"
  },
  {
    "ID" : "55f2e4fee4b0152a611431f5",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8,val1会被覆盖",
    "optionC" : "8,val2会被覆盖",
    "optionAnswer" : "C",
    "answer" : "sizeof(src) 应该是一个指针的大小吧 ?在64位平台下才是8吧 还有栈上内存序号是从小到大分配的吧 ?val1才是在数组dst的后面吧",
    "optionB" : "其他三项都不对",
    "type" : "1",
    "optionA" : "16,val2会被覆盖",
    "question" : "int function(const int src[16]){\n    int val1=0;\n    int dst[16]={0};\n    int val2=0;\n    const int *psrc=src;\n    \/\/问题1：如下代码行输出什么？\n    fprintf(stdout,\"size of src=%lu\\n\",sizeof(src));\n    \/\/问题2：如下代码有什么副作用？\n    for(int i=0;i<=16;i++){\n     dst[i]=*psrc+i;\n     psrc++;\n    }\n    return 0;\n}\n在gcc编译器下，以下说法正确的是"
  },
  {
    "answer" : "解答：（1）轮询调度的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。只有在当前任务主动放弃CPU控制权的情况下（比如任务挂起），才允许其他任务（包括高优先级的任务）控制CPU。其优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。但不利于后面的请求及时得到响应。\n（2）抢占式调度允许高优先级的任务打断当前执行的任务，抢占CPU的控制权。这有利于后面的高优先级的任务也能及时得到响应。但实现相对较复杂且可能出现低优先级的任务长期得不到调度。",
    "ID" : "55f2e51ee4b0152a611433aa",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "轮询任务调度和可抢占式调度有什么区别？"
  },
  {
    "answer" : "去除中间空格的函数，char* removeEmpty(char *str, char ch) {\n    char *it1 = str;\n    char *it2 = str;\n    while (*it2 != '\\0') {\n        \/\/while (*it2 == ch) {it2++; }\n        while (*it2 == ch  && *(it2 + 1) == ch)\n        {\n            it2++;\n        }\n        *it1++ = *it2++;\n    }\n     return str;\n}\nvoid FormatString(char str[], int len){\n    str = removeEmpty(str, ' ');\n}",
    "ID" : "55f2e51ce4b0152a61143337",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "给定字符串（ASCII码0-255）数组，请在不开辟额外空间的情况下删除开始和结尾处的空格，并将中间的多个连续的空格合并成一个。例如：\"   i    am a      little boy.    \"，变成\"i am a little boy\",语言不限，但不要用伪代码作答，函数输入输出请参考如下的函数原型：C++函数原型：\nvoid FormatString(char str[],int len){\n}"
  },
  {
    "answer" : "#include<iostream>\n#include<math.h>\n#include <time.h>\nusing namespace std;\nint num[10];\ninline void SrandNum()\n{\n    num[0]=rand()%100000;\n    num[1]=rand()%100000;\n    num[2]=rand()%100000;\n    num[3]=rand()%100000;\n    num[4]=rand()%100000;\n    num[5]=rand()%100000;\n    num[6]=rand()%100000;\n    num[7]=rand()%100000;\n    num[8]=rand()%100000;\n    num[9]=rand()%100000;\n}\nint MaxNum()\n{\n    int Max=-1;\n    for(int i=0;i<10;i++)\n    {\n        if(num[i]>=Max)\n            Max=num[i];\n    }\n    return Max;\n}\nint AfterMax()\n{\n    int Max=-1;\n    for(int i=0;i<4;i++)\n        if(num[i]>=Max)\n            Max=num[i];\n        for(int i=4;i<9;i++)\n            if(num[i]>Max)\n                return num[i];\n    return num[9];\n}\nint main()\n{\n    srand((unsigned) time(NULL));\n    int times=0;\n    int total=0;\n    int max=-1;\n    int afternum=-1;\n    while(times<1000000)\n    {\n        SrandNum();\n        max=MaxNum();\n        afternum=AfterMax();\n        if(afternum==max)\n            total++;\n        times++;\n    }\n    cout<<total<<endl;\n    return 0;\n}",
    "ID" : "55f2e51de4b0152a61143391",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "10个房间里放着随机数量的金币。每个房间只能进入一次，并只能在一个房间中拿金币。 一个人采取如下策略：前四个房间只看不拿。随后的房间只要看到比前四个房间都多的金币数， 就拿。否则就拿最后一个房间的金币。编程计算这种策略拿到最多金币的概率。"
  },
  {
    "answer" : "有A、B两个栈，进队列push到A，出队列从B中;pop在进队列前把B中的元素全部pop出来并push到A中;在出队列前把A中的元素全部pop出来并push到B中",
    "ID" : "55f2e51ee4b0152a611433b9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "用两个栈模拟队列先进先出，模拟其add和romve功能，给出思路和代码。"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114326a",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "8",
    "optionC" : "7",
    "optionAnswer" : "B",
    "answer" : "C语言区分大小写,pad与pAd是两个不同的变量。首先将5赋值给两个变量,由于赋值运算符的优先级高于逗号运算符,所以计算pAd = + + sum,此时pAd为6,sum也为6,然后计算pAd + +,pAd的值变为7,+ + pad,pad的值变为6,所以选择B。",
    "optionB" : "6",
    "type" : "1",
    "optionA" : "5",
    "question" : "有以下程序\n\n<stdio. h=\"\">main( )\n<\/stdio.><stdio. h=\"\">{ \n<\/stdio.><stdio. h=\"\">   int sum,pad,pAd;\n<\/stdio.><stdio. h=\"\">   sum = pad = 5;\n<\/stdio.><stdio. h=\"\">   pAd = + + sum,pAd + +,+ + pad;\n<\/stdio.><stdio. h=\"\">   printf(\"%d\\n\",pad); \n<\/stdio.><stdio. h=\"\">}<\/stdio.>\n程序的输出结果是"
  },
  {
    "answer" : "答：可以，在不同的C文件中以static形式来声明同名全局变量。\n可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错",
    "ID" : "55f2e51ee4b0152a611433c0",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？"
  },
  {
    "ID" : "55f2e469e4b0152a61143137",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "0",
    "optionC" : "1",
    "optionAnswer" : "D",
    "answer" : "宏替换是直接替换。 \nx\/=SQR(y+z)\/SQR(y+z); 相当于：x\/=y+z*y+z\/y+z*y+z;\n而除等（\/=）的优先级低于+、-、*、\\。所以先计算\/=右边的.而x为int型，结果保留整数位，所以为0，选择D。",
    "optionB" : "6",
    "type" : "1",
    "optionA" : "5",
    "question" : "下面程序的输出结果是__________。 \n\n#include < iostream.h> \n#define SQR(A) A*A\nvoid main() { \n    int x=6,y=3,z=2; \n    x\/=SQR(y+z)\/SQR(y+z); \n    cout< < x< < endl; \n}"
  },
  {
    "ID" : "55f2e4fee4b0152a61143207",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "类模板的成员函数都是函数模板，类模板实例化后，成员函数也随之实例化",
    "optionC" : "一个类定义中，只要有一个函数模板，则这个类是类模板",
    "optionAnswer" : "A",
    "answer" : "正确的说法是函数模板必须由编译器根据程序员的调用类型实例化为可执行的函数。",
    "optionB" : "函数模板的实例化由编译器实现",
    "type" : "1",
    "optionA" : "函数模板必须由程序员实例化为可执行的函数模板",
    "question" : "关于函数模板,描述错误的是？?"
  },
  {
    "ID" : "55b22671e4b0bb7ded0a8c88",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "P=f1()；",
    "optionC" : "P=A::fl()；",
    "optionAnswer" : "B",
    "answer" : "指向普通函数的指针  int max(int a, int b){…}   int (*p)(int, int);    p=max;\n指向类中公有函数的指针的赋值与上相同 指针名=类名::函数名，即 p=A::max;",
    "optionB" : "P=A::f1；",
    "type" : "1",
    "optionA" : "p=fl；",
    "question" : "已知fl(int)是类A的公有成员函数，P是指向成员函数f1()的指针，采用（）是正确的。"
  },
  {
    "answer" : "ARP(AddressResolutionProtocol)（地址解析协议)",
    "ID" : "55f2e51ee4b0152a611433cb",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "Internet物理地址和IP地址转换采用什么协议？"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114325b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "在C#中要在派生类中重新定义基类的虚函数必须在前面加Override。",
    "optionC" : "在C#中可使用 new 修饰符显式隐藏从基类继承的成员。",
    "optionAnswer" : "A",
    "answer" : "C#抽象类使用?abstract 修饰",
    "optionB" : "C++中可在头文件中声明类的成员而在CPP文件中定义类的成员，在C#中没有头文件并且在同一处声明和定义类的成员。",
    "type" : "1",
    "optionA" : "在C++中支持抽象类而在C#中不支持抽象类。",
    "question" : "以下描述错误的是？"
  },
  {
    "ID" : "55f2e4ffe4b0152a6114327b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "以上答案都不正确",
    "optionC" : "运行异常",
    "optionAnswer" : "A",
    "answer" : "最佳答案，没有之一： fclose是一个函数名，功能是关闭一个流。使用fclose()函数就可以把 缓冲区 内最后剩余的数据输出到内核缓冲区，并释放 文件指针 和有关的缓冲区。 函数原型：int fclose( FILE *fp ).\n一次正常的fclose会争取释放FILE指针的相关内容。再次fclose释放已经释放掉了的FILE指针，所以会出错",
    "optionB" : "不会出现异常，释放一个已经释放的指针，系统会自动忽略",
    "type" : "1",
    "optionA" : "导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常",
    "question" : "重复多次 fclose 一个打开过一次的 FILE *fp 指针会有什么结果？"
  },
  {
    "ID" : "55f2e4fee4b0152a6114321e",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "a[p-a]",
    "optionC" : "*a",
    "optionAnswer" : "B",
    "answer" : "A的值为1\nB越界\nC和A相同\nD p-a地址相减为0，访问数组第一个元素",
    "optionB" : "a[10]",
    "type" : "1",
    "optionA" : "*p",
    "question" : "若有以下定义和语句：\nint a[10]={1,2,3,4,5,6,7,8,9,10},*p=a;\n则不能表示a数组元素的表达式是"
  },
  {
    "ID" : "55f2e46ae4b0152a6114315b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "Open The Door",
    "optionC" : "open the door",
    "optionAnswer" : "C",
    "answer" : "字符串输入函数gets的功能是从标准输入设备键盘上输入一个字符串。首先使指针变量p指向字符串的首字母,while循环语句中对字符串的每个字符进行fun函数操作。fun函数的功能是,将字符串中的大写字母变小写字母。将处理结果返回主函数,主函数通过putchar( )字符输出函数进行输出。因此C选项正确。",
    "optionB" : "oPEN tHE dOOR",
    "type" : "1",
    "optionA" : "OPEN THE DOOR",
    "question" : "有以下程序\n\n#include <stdio.h>\nchar fun(char *c)\n{\n     if(*c<=`Z`&& *c>=`A`)\n        *c-=`A`-`a`;\n     return *c;\n}\nmain()\n{\n    char s[81],*p=s;\n    gets(s);\n    while(*p)\n    {\n        *p = fun(p);\n        putchar( *p);\n        p++;\n    }\n    printf(\"\\n\");\n}\n若运行时从键盘上输入OPEN THE DOOR<回车>,程序的输出结果是?"
  },
  {
    "ID" : "55b22610e4b0bb7ded0a8c0b",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "编译、编辑、连接、运行",
    "optionC" : "编译、调试、编辑、连接",
    "optionAnswer" : "B",
    "answer" : "经过编辑、编译、连接和运行四个步骤。编辑是将C++源程序输入计算机的过程，保\n存文件名为cpp。编译是使用系统提供的编译器将源程序cpp生成机器语言的过程，目标文件为\nobj，由于没有得到系统分配的绝对地址，还不能直接运行。连接是将目标文件obj转换为可执行\n程序的过程，结果为exe。运行是执行exe，在屏幕上显示结果的过程。",
    "optionB" : "编辑、编译、连接、运行",
    "type" : "1",
    "optionA" : "编辑、调试、编译、连接",
    "question" : "编写C++程序一般需经过的几个步骤依次是（）"
  },
  {
    "ID" : "55e6d85ae4b0152a610de803",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "protected和private",
    "optionC" : "public和private",
    "optionAnswer" : "B",
    "answer" : "private只能由该类中的函数或其友元函数访问。",
    "optionB" : "public和protected",
    "type" : "1",
    "optionA" : "都能访问",
    "question" : "类的成员有三种访问属性，分别是public、protected、private，子类能够访问的成员是（）"
  },
  {
    "ID" : "55f2e4ffe4b0152a61143270",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "24",
    "optionC" : "23",
    "optionAnswer" : "B",
    "answer" : "这题的正确答案应该是32位系统是4 64位系统是8，数组作为函数的参数是会退化为函数指针的，想想看，数组作为函数参数的时候经常是需要传递数组大小的",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "0",
    "question" : "在32位机器中，如下代码：\n\nvoid example(char acWelcome[]){\n    printf(\"%d\",sizeof(acWelcome));\n    return;\n}\nvoid main(){\n    char acWelcome[]=\"Welcome to Huawei Test\";\n    example(acWelcome);\n    return;\n}\n的输出是?"
  },
  {
    "ID" : "55f2e4fee4b0152a61143209",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "堆，堆",
    "optionC" : "栈， 栈",
    "optionAnswer" : "B",
    "answer" : "函数内局部变量，形参都是在栈内存空间中申请的，随着函数的结束而消失\nmalloc和new关键字在堆内存申请空间，使用结束需要认为的释放",
    "optionB" : "栈，堆",
    "type" : "1",
    "optionA" : "堆，栈",
    "question" : "函数参数使用的空间是在（）中申请的，malloc或new是在（）中申请空间的？"
  },
  {
    "ID" : "55e6d85ae4b0152a610de7f9",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "都不对",
    "optionC" : "b的16进制为0xffffffe0",
    "optionAnswer" : "C",
    "answer" : "a的值为-32，所以a<0.\n相反，c的值为224，大于0.\nb的16进制表示为ffffffe0",
    "optionB" : "c==a 为真",
    "type" : "1",
    "optionA" : "(a>0 )&&(b>0)为真",
    "question" : "signed char a=0xe0;\nunsigned int b=a;\nunsigned char c=a;\n下面说法正确的是："
  },
  {
    "answer" : "hosts文件篡改， 本机DNS服务器IP地址篡改，DNS通讯包篡改。",
    "ID" : "55f2e51de4b0152a6114334c",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "DNS欺骗的方式有哪些？"
  },
  {
    "answer" : "1月8日",
    "ID" : "55f2e51de4b0152a61143360",
    "typeID" : "54993f56e4b06783458c3b0f",
    "type" : "2",
    "question" : "在区间[-1, 1]随意取两个数，它们的和大于1的概率是___。(分数表示)"
  },
  {
    "ID" : "55b22611e4b0bb7ded0a8c27",
    "typeID" : "54993f56e4b06783458c3b0f",
    "optionD" : "在一个类中可以说明具有类类型的数据成员",
    "optionC" : "析构函数需要指定参数",
    "optionAnswer" : "C",
    "answer" : "构造函数可以有参数、可以重载、因此可以有多个，A项正确。析构函数只有一个不\n能重载、不能继承，没有返回值，B项正确，C项错误。",
    "optionB" : "一个类只有一个析构函数",
    "type" : "1",
    "optionA" : "一个类可以有多个构造函数",
    "question" : "下面有关类说法不正确的是（）"
  },{"ID":"461","typeID":"12","question":"\u8bed\u53e5for( \uff1b1 \uff1b)\u6709\u4ec0\u4e48\u95ee\u9898\uff1f\u5b83\u662f\u4ec0\u4e48\u610f\u601d\uff1f","answer":"\u65e0\u9650\u5faa\u73af\uff0c\u548cwhile(1)\u76f8\u540c\u3002"},{"ID":"460","typeID":"12","question":"\u5168\u5c40\u53d8\u91cf\u53ef\u4e0d\u53ef\u4ee5\u5b9a\u4e49\u5728\u53ef\u88ab\u591a\u4e2a.C\u6587\u4ef6\u5305\u542b\u7684\u5934\u6587\u4ef6\u4e2d\uff1f\u4e3a\u4ec0\u4e48\uff1f","answer":"\u53ef\u4ee5\uff0c\u5728\u4e0d\u540c\u7684C\u6587\u4ef6\u4e2d\u4ee5static\u5f62\u5f0f\u6765\u58f0\u660e\u540c\u540d\u5168\u5c40\u53d8\u91cf\u3002\r\n    \u53ef\u4ee5\u5728\u4e0d\u540c\u7684C\u6587\u4ef6\u4e2d\u58f0\u660e\u540c\u540d\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u524d\u63d0\u662f\u5176\u4e2d\u53ea\u80fd\u6709\u4e00\u4e2aC\u6587\u4ef6\u4e2d\u5bf9\u6b64\u53d8\u91cf\u8d4b\u521d\u503c\uff0c\u6b64\u65f6\u8fde\u63a5\u4e0d\u4f1a\u51fa\u9519\u3002"},{"ID":"459","typeID":"12","question":"\u5982\u4f55\u5f15\u7528\u4e00\u4e2a\u5df2\u7ecf\u5b9a\u4e49\u8fc7\u7684\u5168\u5c40\u53d8\u91cf\uff1f","answer":"extern\r\n     \u53ef\u4ee5\u7528\u5f15\u7528\u5934\u6587\u4ef6\u7684\u65b9\u5f0f\uff0c\u4e5f\u53ef\u4ee5\u7528extern\u5173\u952e\u5b57\uff0c\u5982\u679c\u7528\u5f15\u7528\u5934\u6587\u4ef6\u65b9\u5f0f\u6765\u5f15\u7528\u67d0\u4e2a\u5728\u5934\u6587\u4ef6\u4e2d\u58f0\u660e\u7684\u5168\u5c40\u53d8\u7406\uff0c\u5047\u5b9a\u4f60\u5c06\u90a3\u4e2a\u53d8\u5199\u9519\u4e86\uff0c\u90a3\u4e48\u5728\u7f16\u8bd1\u671f\u95f4 \u4f1a\u62a5\u9519\uff0c\u5982\u679c\u4f60\u7528extern\u65b9\u5f0f\u5f15\u7528\u65f6\uff0c\u5047\u5b9a\u4f60\u72af\u4e86\u540c\u6837\u7684\u9519\u8bef\uff0c\u90a3\u4e48\u5728\u7f16\u8bd1\u671f\u95f4\u4e0d\u4f1a\u62a5\u9519\uff0c\u800c\u5728\u8fde\u63a5\u671f\u95f4\u62a5\u9519\u3002"},{"ID":"458","typeID":"12","question":"\u5c40\u90e8\u53d8\u91cf\u80fd\u5426\u548c\u5168\u5c40\u53d8\u91cf\u91cd\u540d\uff1f","answer":"\u80fd\uff0c\u5c40\u90e8\u4f1a\u5c4f\u853d\u5168\u5c40\u3002\u8981\u7528\u5168\u5c40\u53d8\u91cf\uff0c\u9700\u8981\u4f7f\u7528\"::\"\r\n\u5c40\u90e8\u53d8\u91cf\u53ef\u4ee5\u4e0e\u5168\u5c40\u53d8\u91cf\u540c\u540d\uff0c\u5728\u51fd\u6570\u5185\u5f15\u7528\u8fd9\u4e2a\u53d8\u91cf\u65f6\uff0c\u4f1a\u7528\u5230\u540c\u540d\u7684\u5c40\u90e8\u53d8\u91cf\uff0c\u800c\u4e0d\u4f1a\u7528\u5230\u5168\u5c40\u53d8\u91cf\u3002\u5bf9\u4e8e\u6709\u4e9b\u7f16\u8bd1\u5668\u800c\u8a00\uff0c\u5728\u540c\u4e00\u4e2a\u51fd\u6570\u5185\u53ef\u4ee5\u5b9a\u4e49\u591a\u4e2a\u540c\u540d\u7684\u5c40\u90e8\u53d8\u91cf\uff0c\u6bd4\u5982\u5728\u4e24\u4e2a\u5faa\u73af\u4f53\u5185\u90fd\u5b9a\u4e49\u4e00\u4e2a\u540c\u540d\u7684\u5c40\u90e8\u53d8\u91cf\uff0c\u800c\u90a3\u4e2a\u5c40\u90e8\u53d8\u91cf\u7684\u4f5c\u7528\u57df\u5c31\u5728\u90a3\u4e2a\u5faa\u73af\u4f53\u5185\u3002"},{"ID":"457","typeID":"12","question":"Internet\u7269\u7406\u5730\u5740\u548cIP\u5730\u5740\u8f6c\u6362\u91c7\u7528\u4ec0\u4e48\u534f\u8bae\uff1f","answer":"ARP (Address Resolution Protocol)\uff08\u5730\u5740\u89e3\u6790\u5354\u8b70\uff09"},{"ID":"456","typeID":"12","question":"Internet\u91c7\u7528\u54ea\u79cd\u7f51\u7edc\u534f\u8bae\uff1f\u8be5\u534f\u8bae\u7684\u4e3b\u8981\u5c42\u6b21\u7ed3\u6784\uff1f","answer":"Tcp\/Ip\u534f\u8bae\r\n\u4e3b\u8981\u5c42\u6b21\u7ed3\u6784\u4e3a\uff1a \u5e94\u7528\u5c42\/\u4f20\u8f93\u5c42\/\u7f51\u7edc\u5c42\/\u6570\u636e\u94fe\u8def\u5c42\/\u7269\u7406\u5c42\u3002"},{"ID":"455","typeID":"12","question":"\u5192\u6ce1\u6392\u5e8f\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\u4ec0\u4e48\uff1f","answer":"\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(n^2)\u3002"},{"ID":"454","typeID":"12","question":"\u4ec0\u4e48\u51fd\u6570\u4e0d\u80fd\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff1f","answer":"constructor\u51fd\u6570\u4e0d\u80fd\u58f0\u660e\u4e3a\u865a\u51fd\u6570\u3002"},{"ID":"453","typeID":"12","question":"\u5806\u6808\u6ea2\u51fa\u4e00\u822c\u662f\u7531\u4ec0\u4e48\u539f\u56e0\u5bfc\u81f4\u7684\uff1f","answer":"\u6ca1\u6709\u56de\u6536\u5783\u573e\u8d44\u6e90\u3002"},{"ID":"452","typeID":"12","question":"\u4ec0\u4e48\u662f\u5e73\u8861\u4e8c\u53c9\u6811\uff1f","answer":"\u5de6\u53f3\u5b50\u6811\u90fd\u662f\u5e73\u8861\u4e8c\u53c9\u6811 \u4e14\u5de6\u53f3\u5b50\u6811\u7684\u6df1\u5ea6\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u4e0d\u5927\u4e8e1\u3002"},{"ID":"451","typeID":"12","question":"\u5168\u5c40\u53d8\u91cf\u548c\u5c40\u90e8\u53d8\u91cf\u5728\u5185\u5b58\u4e2d\u662f\u5426\u6709\u533a\u522b\uff1f\u5982\u679c\u6709\uff0c\u662f\u4ec0\u4e48\u533a\u522b\uff1f","answer":"\u5168\u5c40\u53d8\u91cf\u50a8\u5b58\u5728\u9759\u6001\u6570\u636e\u5e93\uff0c\u5c40\u90e8\u53d8\u91cf\u5728\u5806\u6808\u3002"},{"ID":"450","typeID":"12","question":"\u5f15\u7528\u4e0e\u6307\u9488\u6709\u4ec0\u4e48\u533a\u522b\uff1f","answer":"1) \u5f15\u7528\u5fc5\u987b\u88ab\u521d\u59cb\u5316\uff0c\u6307\u9488\u4e0d\u5fc5\u3002\r\n2) \u5f15\u7528\u521d\u59cb\u5316\u4ee5\u540e\u4e0d\u80fd\u88ab\u6539\u53d8\uff0c\u6307\u9488\u53ef\u4ee5\u6539\u53d8\u6240\u6307\u7684\u5bf9\u8c61\u3002\r\n3) \u4e0d\u5b58\u5728\u6307\u5411\u7a7a\u503c\u7684\u5f15\u7528\uff0c\u4f46\u662f\u5b58\u5728\u6307\u5411\u7a7a\u503c\u7684\u6307\u9488\u3002"},{"ID":"449","typeID":"12","question":"\u52a8\u6001\u8fde\u63a5\u5e93\u7684\u4e24\u79cd\u65b9\u5f0f?","answer":"\u8c03\u7528\u4e00\u4e2aDLL\u4e2d\u7684\u51fd\u6570\u6709\u4e24\u79cd\u65b9\u6cd5\uff1a\r\n1\uff0e\u8f7d\u5165\u65f6\u52a8\u6001\u94fe\u63a5\uff08load-time dynamic linking\uff09\uff0c\u6a21\u5757\u975e\u5e38\u660e\u786e\u8c03\u7528\u67d0\u4e2a\u5bfc\u51fa\u51fd\u6570\r\n\uff0c\u4f7f\u5f97\u4ed6\u4eec\u5c31\u50cf\u672c\u5730\u51fd\u6570\u4e00\u6837\u3002\u8fd9\u9700\u8981\u94fe\u63a5\u65f6\u94fe\u63a5\u90a3\u4e9b\u51fd\u6570\u6240\u5728DLL\u7684\u5bfc\u5165\u5e93\uff0c\u5bfc\u5165\u5e93\u5411\r\n\u7cfb\u7edf\u63d0\u4f9b\u4e86\u8f7d\u5165DLL\u65f6\u6240\u9700\u7684\u4fe1\u606f\u53caDLL\u51fd\u6570\u5b9a\u4f4d\u3002 \r\n2\uff0e\u8fd0\u884c\u65f6\u52a8\u6001\u94fe\u63a5\uff08run-time dynamic linking\uff09\uff0c\u8fd0\u884c\u65f6\u53ef\u4ee5\u901a\u8fc7LoadLibrary\u6216Loa\r\ndLibraryEx\u51fd\u6570\u8f7d\u5165DLL\u3002DLL\u8f7d\u5165\u540e\uff0c\u6a21\u5757\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528GetProcAddress\u83b7\u53d6DLL\u51fd\u6570\u7684\r\n\u51fa\u53e3\u5730\u5740\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u901a\u8fc7\u8fd4\u56de\u7684\u51fd\u6570\u6307\u9488\u8c03\u7528DLL\u51fd\u6570\u4e86\u3002\u5982\u6b64\u5373\u53ef\u907f\u514d\u5bfc\u5165\u5e93\u6587\u4ef6\u4e86\r\n\u3002"},{"ID":"447","typeID":"12","question":"int i=10, j=10, k=3; k*=i+j; k\u6700\u540e\u7684\u503c\u662f\uff1f","answer":"60\uff0c\u6b64\u9898\u8003\u5bdf\u4f18\u5148\u7ea7\uff0c\u5b9e\u9645\u5199\u6210\uff1a k*=(i+j);\uff0c\u8d4b\u503c\u8fd0\u7b97\u7b26\u4f18\u5148\u7ea7\u6700\u4f4e"},{"ID":"446","typeID":"12","question":"\u5173\u4e8e\u5185\u5b58\u5bf9\u9f50\u7684\u95ee\u9898\u4ee5\u53casizof()\u7684\u8f93\u51fa","answer":"\u7f16\u8bd1\u5668\u81ea\u52a8\u5bf9\u9f50\u7684\u539f\u56e0\uff1a\u4e3a\u4e86\u63d0\u9ad8\u7a0b\u5e8f\u7684\u6027\u80fd\uff0c\u6570\u636e\u7ed3\u6784\uff08\u5c24\u5176\u662f\u6808\uff09\u5e94\u8be5\u5c3d\u53ef\u80fd\r\n\u5730\u5728\u81ea\u7136\u8fb9\u754c\u4e0a\u5bf9\u9f50\u3002\u539f\u56e0\u5728\u4e8e\uff0c\u4e3a\u4e86\u8bbf\u95ee\u672a\u5bf9\u9f50\u7684\u5185\u5b58\uff0c\u5904\u7406\u5668\u9700\u8981\u4f5c\u4e24\u6b21\u5185\u5b58\u8bbf\u95ee\r\n\uff1b\u7136\u800c\uff0c\u5bf9\u9f50\u7684\u5185\u5b58\u8bbf\u95ee\u4ec5\u9700\u8981\u4e00\u6b21\u8bbf\u95ee\u3002"},{"ID":"445","typeID":"12","question":"SQL Server\u662f\u5426\u652f\u6301\u884c\u7ea7\u9501\uff0c\u6709\u4ec0\u4e48\u597d\u5904\uff1f","answer":"\u652f\u6301\uff0c\u8bbe\u7acb\u5c01\u9501\u673a\u5236\u4e3b\u8981\u662f\u4e3a\u4e86\u5bf9\u5e76\u53d1\u64cd\u4f5c\u8fdb\u884c\u63a7\u5236\uff0c\u5bf9\u5e72\u6270\u8fdb\u884c\u5c01\u9501\uff0c\u4fdd\u8bc1\u6570\u636e\r\n\u7684\u4e00\u81f4\u6027\u548c\u51c6\u786e\u6027\uff0c\u884c\u7ea7\u5c01\u9501\u786e\u4fdd\u5728\u7528\u6237\u53d6\u5f97\u88ab\u66f4\u65b0\u7684\u884c\u5230\u8be5\u884c\u8fdb\u884c\u66f4\u65b0\u8fd9\u6bb5\u65f6\u95f4\u5185\u4e0d\r\n\u88ab\u5176\u5b83\u7528\u6237\u6240\u4fee\u6539\u3002\u56e0\u800c\u884c\u7ea7\u9501\u5373\u53ef\u4fdd\u8bc1\u6570\u636e\u7684\u4e00\u81f4\u6027\u53c8\u80fd\u63d0\u9ad8\u6570\u636e\u64cd\u4f5c\u7684\u8ff8\u53d1\u6027\u3002"},{"ID":"444","typeID":"12","question":"\u4e00\u822c\u6570\u636e\u5e93\u82e5\u51fa\u73b0\u65e5\u5fd7\u6ee1\u4e86\uff0c\u4f1a\u51fa\u73b0\u4ec0\u4e48\u60c5\u51b5\uff0c\u662f\u5426\u8fd8\u80fd\u4f7f\u7528\uff1f","answer":"\u53ea\u80fd\u6267\u884c\u67e5\u8be2\u7b49\u8bfb\u64cd\u4f5c\uff0c\u4e0d\u80fd\u6267\u884c\u66f4\u6539\uff0c\u5907\u4efd\u7b49\u5199\u64cd\u4f5c\uff0c\u539f\u56e0\u662f\u4efb\u4f55\u5199\u64cd\u4f5c\u90fd\u8981\u8bb0\r\n\u5f55\u65e5\u5fd7\u3002\u4e5f\u5c31\u662f\u8bf4\u57fa\u672c\u4e0a\u5904\u4e8e\u4e0d\u80fd\u4f7f\u7528\u7684\u72b6\u6001\u3002"},{"ID":"443","typeID":"12","question":"\u51fd\u6570\u6a21\u677f\u4e0e\u7c7b\u6a21\u677f\u6709\u4ec0\u4e48\u533a\u522b\uff1f","answer":"\u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u5316\u662f\u7531\u7f16\u8bd1\u7a0b\u5e8f\u5728\u5904\u7406\u51fd\u6570\u8c03\u7528\u65f6\u81ea\u52a8\u5b8c\u6210\u7684\uff0c\u800c\u7c7b\u6a21\u677f\u7684\u5b9e\u4f8b\u5316\r\n\u5fc5\u987b\u7531\u7a0b\u5e8f\u5458\u5728\u7a0b\u5e8f\u4e2d\u663e\u5f0f\u5730\u6307\u5b9a\u3002"},{"ID":"442","typeID":"12","question":"\u4f7f\u7528\u7ebf\u7a0b\u662f\u5982\u4f55\u9632\u6b62\u51fa\u73b0\u5927\u7684\u6ce2\u5cf0\uff1f","answer":"\u610f\u601d\u662f\u5982\u4f55\u9632\u6b62\u540c\u65f6\u4ea7\u751f\u5927\u91cf\u7684\u7ebf\u7a0b\uff0c\u65b9\u6cd5\u662f\u4f7f\u7528\u7ebf\u7a0b\u6c60\uff0c\u7ebf\u7a0b\u6c60\u5177\u6709\u53ef\u4ee5\u540c\u65f6\u63d0\r\n\u9ad8\u8c03\u5ea6\u6548\u7387\u548c\u9650\u5236\u8d44\u6e90\u4f7f\u7528\u7684\u597d\u5904\uff0c\u7ebf\u7a0b\u6c60\u4e2d\u7684\u7ebf\u7a0b\u8fbe\u5230\u6700\u5927\u6570\u65f6\uff0c\u5176\u4ed6\u7ebf\u7a0b\u5c31\u4f1a\u6392\u961f\r\n\u7b49\u5019\u3002"},{"ID":"441","typeID":"12","question":"C++\u4e2d\u4ec0\u4e48\u6570\u636e\u5206\u914d\u5728\u6808\u6216\u5806\u4e2d\uff0cNew\u5206\u914d\u6570\u636e\u662f\u5728\u8fd1\u5806\u8fd8\u662f\u8fdc\u5806\u4e2d\uff1f","answer":"\u6808: \u5b58\u653e\u5c40\u90e8\u53d8\u91cf\uff0c\u51fd\u6570\u8c03\u7528\u53c2\u6570,\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u51fd\u6570\u8fd4\u56de\u5730\u5740\uff0c\u7531\u7cfb\u7edf\u7ba1\u7406\r\n\u5806: \u7a0b\u5e8f\u8fd0\u884c\u65f6\u52a8\u6001\u7533\u8bf7\uff0cnew \u548c\u3000malloc\u7533\u8bf7\u7684\u5185\u5b58\u5c31\u5728\u5806\u4e0a\r\nnew\u5728\u8fd1\u5806"},{"ID":"440","typeID":"12","question":"Linux\u6709\u5185\u6838\u7ea7\u7ebf\u7a0b\u4e48\uff1f","answer":"\u7ebf\u7a0b\u901a\u5e38\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u8fdb\u7a0b\u4e2d\u4ee3\u7801\u7684\u4e0d\u540c\u6267\u884c\u8def\u7ebf\u3002\u4ece\u5b9e\u73b0\u65b9\u5f0f\u4e0a\u5212\u5206\uff0c\u7ebf\u7a0b\u6709\u4e24\r\n\u79cd\u7c7b\u578b\uff1a\u201c\u7528\u6237\u7ea7\u7ebf\u7a0b\u201d\u548c\u201c\u5185\u6838\u7ea7\u7ebf\u7a0b\u201d\u3002 \u7528\u6237\u7ebf\u7a0b\u6307\u4e0d\u9700\u8981\u5185\u6838\u652f\u6301\u800c\u5728\u7528\u6237\u7a0b\u5e8f\r\n\u4e2d\u5b9e\u73b0\u7684\u7ebf\u7a0b\uff0c\u5176\u4e0d\u4f9d\u8d56\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u6838\u5fc3\uff0c\u5e94\u7528\u8fdb\u7a0b\u5229\u7528\u7ebf\u7a0b\u5e93\u63d0\u4f9b\u521b\u5efa\u3001\u540c\u6b65\u3001\u8c03\u5ea6\r\n\u548c\u7ba1\u7406\u7ebf\u7a0b\u7684\u51fd\u6570\u6765\u63a7\u5236\u7528\u6237\u7ebf\u7a0b\u3002\u8fd9\u79cd\u7ebf\u7a0b\u751a\u81f3\u5728\u8c61 DOS \u8fd9\u6837\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4e5f\u53ef\u5b9e\u73b0\r\n\uff0c\u4f46\u7ebf\u7a0b\u7684\u8c03\u5ea6\u9700\u8981\u7528\u6237\u7a0b\u5e8f\u5b8c\u6210\uff0c\u8fd9\u6709\u4e9b\u7c7b\u4f3c Windows 3.x \u7684\u534f\u4f5c\u5f0f\u591a\u4efb\u52a1\u3002\u53e6\u5916\u4e00\r\n\u79cd\u5219\u9700\u8981\u5185\u6838\u7684\u53c2\u4e0e\uff0c\u7531\u5185\u6838\u5b8c\u6210\u7ebf\u7a0b\u7684\u8c03\u5ea6\u3002\u5176\u4f9d\u8d56\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u6838\u5fc3\uff0c\u7531\u5185\u6838\u7684\u5185\u90e8\r\n\u9700\u6c42\u8fdb\u884c\u521b\u5efa\u548c\u64a4\u9500\uff0c\u8fd9\u4e24\u79cd\u6a21\u578b\u5404\u6709\u5176\u597d\u5904\u548c\u7f3a\u70b9\u3002\u7528\u6237\u7ebf\u7a0b\u4e0d\u9700\u8981\u989d\u5916\u7684\u5185\u6838\u5f00\u652f\r\n\uff0c\u5e76\u4e14\u7528\u6237\u6001\u7ebf\u7a0b\u7684\u5b9e\u73b0\u65b9\u5f0f\u53ef\u4ee5\u88ab\u5b9a\u5236\u6216\u4fee\u6539\u4ee5\u9002\u5e94\u7279\u6b8a\u5e94\u7528\u7684\u8981\u6c42\uff0c\u4f46\u662f\u5f53\u4e00\u4e2a\u7ebf\r\n\u7a0b\u56e0 I\/O \u800c\u5904\u4e8e\u7b49\u5f85\u72b6\u6001\u65f6\uff0c\u6574\u4e2a\u8fdb\u7a0b\u5c31\u4f1a\u88ab\u8c03\u5ea6\u7a0b\u5e8f\u5207\u6362\u4e3a\u7b49\u5f85\u72b6\u6001\uff0c\u5176\u4ed6\u7ebf\u7a0b\u5f97\u4e0d\r\n\u5230\u8fd0\u884c\u7684\u673a\u4f1a\uff1b\u800c\u5185\u6838\u7ebf\u7a0b\u5219\u6ca1\u6709\u5404\u4e2a\u9650\u5236\uff0c\u6709\u5229\u4e8e\u53d1\u6325\u591a\u5904\u7406\u5668\u7684\u5e76\u53d1\u4f18\u52bf\uff0c\u4f46\u5374\u5360\r\n\u7528\u4e86\u66f4\u591a\u7684\u7cfb\u7edf\u5f00\u652f\u3002 "},{"ID":"439","typeID":"12","question":"\u7a0b\u5e8f\u4ec0\u4e48\u65f6\u5019\u5e94\u8be5\u4f7f\u7528\u7ebf\u7a0b\uff0c\u4ec0\u4e48\u65f6\u5019\u5355\u7ebf\u7a0b\u6548\u7387\u9ad8\uff1f","answer":"1\uff0e\u8017\u65f6\u7684\u64cd\u4f5c\u4f7f\u7528\u7ebf\u7a0b\uff0c\u63d0\u9ad8\u5e94\u7528\u7a0b\u5e8f\u54cd\u5e94\r\n2\uff0e\u5e76\u884c\u64cd\u4f5c\u65f6\u4f7f\u7528\u7ebf\u7a0b\uff0c\u5982C\/S\u67b6\u6784\u7684\u670d\u52a1\u5668\u7aef\u5e76\u53d1\u7ebf\u7a0b\u54cd\u5e94\u7528\u6237\u7684\u8bf7\u6c42\u3002\r\n3\uff0e\u591aCPU\u7cfb\u7edf\u4e2d\uff0c\u4f7f\u7528\u7ebf\u7a0b\u63d0\u9ad8CPU\u5229\u7528\u7387\r\n4\uff0e\u6539\u5584\u7a0b\u5e8f\u7ed3\u6784\u3002\u4e00\u4e2a\u65e2\u957f\u53c8\u590d\u6742\u7684\u8fdb\u7a0b\u53ef\u4ee5\u8003\u8651\u5206\u4e3a\u591a\u4e2a\u7ebf\u7a0b\uff0c\u6210\u4e3a\u51e0\u4e2a\u72ec\u7acb\u6216\u534a\u72ec\r\n\u7acb\u7684\u8fd0\u884c\u90e8\u5206\uff0c\u8fd9\u6837\u7684\u7a0b\u5e8f\u4f1a\u5229\u4e8e\u7406\u89e3\u548c\u4fee\u6539\u3002"},{"ID":"438","typeID":"12","question":"NEWTEXTMETRIC \u662f\u4ec0\u4e48\uff1f","answer":"\u7269\u7406\u5b57\u4f53\u7ed3\u6784\uff0c\u7528\u6765\u8bbe\u7f6e\u5b57\u4f53\u7684\u9ad8\u5bbd\u5927\u5c0f"},{"ID":"437","typeID":"12","question":"CSingleLock\u662f\u5e72\u4ec0\u4e48\u7684\u3002","answer":"\u540c\u6b65\u591a\u4e2a\u7ebf\u7a0b\u5bf9\u4e00\u4e2a\u6570\u636e\u7c7b\u7684\u540c\u65f6\u8bbf\u95ee"},{"ID":"436","typeID":"12","question":"C++\u4e2d\u4e3a\u4ec0\u4e48\u7528\u6a21\u677f\u7c7b\uff1f","answer":"(1)\u53ef\u7528\u6765\u521b\u5efa\u52a8\u6001\u589e\u957f\u548c\u51cf\u5c0f\u7684\u6570\u636e\u7ed3\u6784\r\n\uff082\uff09\u5b83\u662f\u7c7b\u578b\u65e0\u5173\u7684\uff0c\u56e0\u6b64\u5177\u6709\u5f88\u9ad8\u7684\u53ef\u590d\u7528\u6027\u3002\r\n\uff083\uff09\u5b83\u5728\u7f16\u8bd1\u65f6\u800c\u4e0d\u662f\u8fd0\u884c\u65f6\u68c0\u67e5\u6570\u636e\u7c7b\u578b\uff0c\u4fdd\u8bc1\u4e86\u7c7b\u578b\u5b89\u5168\r\n\uff084\uff09\u5b83\u662f\u5e73\u53f0\u65e0\u5173\u7684\uff0c\u53ef\u79fb\u690d\u6027\r\n\uff085\uff09\u53ef\u7528\u4e8e\u57fa\u672c\u6570\u636e\u7c7b\u578b"},{"ID":"435","typeID":"12","question":"MFC\u4e2dCString\u662f\u7c7b\u578b\u5b89\u5168\u7c7b\u4e48\uff1f","answer":"\u4e0d\u662f\uff0c\u5176\u5b83\u6570\u636e\u7c7b\u578b\u8f6c\u6362\u5230CString\u53ef\u4ee5\u4f7f\u7528CString\u7684\u6210\u5458\u51fd\u6570Format\u6765\u8f6c\u6362"},{"ID":"434","typeID":"12","question":"\u7f16\u5199strcat\u51fd\u6570","answer":"\u5df2\u77e5strcat\u51fd\u6570\u7684\u539f\u578b\u662fchar *strcat (char *strDest, const char *strSrc);\r\n\u5176\u4e2dstrDest \u662f\u76ee\u7684\u5b57\u7b26\u4e32\uff0cstrSrc \u662f\u6e90\u5b57\u7b26\u4e32\u3002\r\n\uff081\uff09\u4e0d\u8c03\u7528C++\/C \u7684\u5b57\u7b26\u4e32\u5e93\u51fd\u6570\uff0c\u8bf7\u7f16\u5199\u51fd\u6570 strcat\r\n\u7b54\uff1a\r\nVC\u6e90\u7801\uff1a\r\nchar * __cdecl strcat (char * dst, const char * src)\r\n{\r\nchar * cp = dst;\r\nwhile( *cp )\r\ncp++; \/* find end of dst *\/\r\nwhile( *cp++ = *src++ ) ; \/* Copy src to end of dst *\/\r\nreturn( dst ); \/* return dst *\/\r\n}\r\n\uff082\uff09strcat\u80fd\u628astrSrc \u7684\u5185\u5bb9\u8fde\u63a5\u5230strDest\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u8981char * \u7c7b\u578b\u7684\u8fd4\u56de\u503c\uff1f\r\n\u7b54\uff1a\u65b9\u4fbf\u8d4b\u503c\u7ed9\u5176\u4ed6\u53d8\u91cf"},{"ID":"433","typeID":"12","question":"switch()\u4e2d\u4e0d\u5141\u8bb8\u7684\u6570\u636e\u7c7b\u578b\u662f?","answer":"\u5b9e\u578b"},{"ID":"432","typeID":"12","question":"\u5728C++ \u7a0b\u5e8f\u4e2d\u8c03\u7528\u88ab C \u7f16\u8bd1\u5668\u7f16\u8bd1\u540e\u7684\u51fd\u6570\uff0c\u4e3a\u4ec0\u4e48\u8981\u52a0 extern \u201cC\u201d\u58f0\u660e\uff1f","answer":"\u51fd\u6570\u548c\u53d8\u91cf\u88abC++\u7f16\u8bd1\u540e\u5728\u7b26\u53f7\u5e93\u4e2d\u7684\u540d\u5b57\u4e0eC\u8bed\u8a00\u7684\u4e0d\u540c\uff0c\u88abextern \"C\"\u4fee\u9970\u7684\u53d8\r\n\u91cf\u548c\u51fd\u6570\u662f\u6309\u7167C\u8bed\u8a00\u65b9\u5f0f\u7f16\u8bd1\u548c\u8fde\u63a5\u7684\u3002\u7531\u4e8e\u7f16\u8bd1\u540e\u7684\u540d\u5b57\u4e0d\u540c\uff0cC++\u7a0b\u5e8f\u4e0d\u80fd\u76f4\u63a5\u8c03\r\n\u7528C \u51fd\u6570\u3002C++\u63d0\u4f9b\u4e86\u4e00\u4e2aC \u8fde\u63a5\u4ea4\u6362\u6307\u5b9a\u7b26\u53f7extern\u201cC\u201d\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\r\n"},{"ID":"431","typeID":"12","question":"\uff03i nclude \u548c \uff03i nclude \u201cfilename.h\u201d \u6709\u4ec0\u4e48\u533a\u522b\uff1f","answer":"\u524d\u8005\u7528\u6765\u5305\u542b\u5f00\u53d1\u73af\u5883\u63d0\u4f9b\u7684\u5e93\u5934\u6587\u4ef6\uff0c\u540e\u8005\u7528\u6765\u5305\u542b\u81ea\u5df1\u7f16\u5199\u7684\u5934\u6587\u4ef6\u3002"},{"ID":"430","typeID":"12","question":"\u5934\u6587\u4ef6\u4e2d\u7684 ifndef\/define\/endif \u5e72\u4ec0\u4e48\u7528\uff1f","answer":"\u9632\u6b62\u5934\u6587\u4ef6\u88ab\u91cd\u590d\u5f15\u7528"},{"ID":"429","typeID":"12","question":"\u5173\u952e\u5b57volatile\u6709\u4ec0\u4e48\u542b\u610f?","answer":"\u4e00\u4e2a\u5b9a\u4e49\u4e3avolatile\u7684\u53d8\u91cf\u662f\u8bf4\u8fd9\u53d8\u91cf\u53ef\u80fd\u4f1a\u88ab\u610f\u60f3\u4e0d\u5230\u5730\u6539\u53d8\uff0c\u8fd9\u6837\uff0c\u7f16\u8bd1\u5668\u5c31\u4e0d\u4f1a\u53bb\u5047\u8bbe\u8fd9\u4e2a\u53d8\u91cf\u7684\u503c\u4e86\u3002\u7cbe\u786e\u5730\u8bf4\u5c31\u662f\uff0c\u4f18\u5316\u5668\u5728\u7528\u5230\u8fd9\u4e2a\u53d8\u91cf\u65f6\u5fc5\u987b\u6bcf\u6b21\u90fd\u5c0f\u5fc3\u5730\u91cd\u65b0\u8bfb\u53d6\u8fd9\u4e2a\u53d8\u91cf\u7684\u503c\uff0c\u800c\u4e0d\u662f\u4f7f\u7528\u4fdd\u5b58\u5728\u5bc4\u5b58\u5668\u91cc\u7684\u5907\u4efd\u3002\u4e0b\u9762\u662fvolatile\u53d8\u91cf\u7684\u51e0\u4e2a\u4f8b\u5b50\uff1a\r\n1) \u5e76\u884c\u8bbe\u5907\u7684\u786c\u4ef6\u5bc4\u5b58\u5668\uff08\u5982\uff1a\u72b6\u6001\u5bc4\u5b58\u5668\uff09\r\n2) \u4e00\u4e2a\u4e2d\u65ad\u670d\u52a1\u5b50\u7a0b\u5e8f\u4e2d\u4f1a\u8bbf\u95ee\u5230\u7684\u975e\u81ea\u52a8\u53d8\u91cf(Non-automatic variables)\r\n3) \u591a\u7ebf\u7a0b\u5e94\u7528\u4e2d\u88ab\u51e0\u4e2a\u4efb\u52a1\u5171\u4eab\u7684\u53d8\u91cf"},{"ID":"428","typeID":"12","question":"\u5173\u952e\u5b57const\u6709\u4ec0\u4e48\u542b\u610f\uff1f","answer":"1) \u5173\u952e\u5b57const\u7684\u4f5c\u7528\u662f\u4e3a\u7ed9\u8bfb\u4f60\u4ee3\u7801\u7684\u4eba\u4f20\u8fbe\u975e\u5e38\u6709\u7528\u7684\u4fe1\u606f\uff0c\u5b9e\u9645\u4e0a\uff0c\u58f0\u660e\u4e00\u4e2a\u53c2\u6570\u4e3a\u5e38\u91cf\u662f\u4e3a\u4e86\u544a\u8bc9\u4e86\u7528\u6237\u8fd9\u4e2a\u53c2\u6570\u7684\u5e94\u7528\u76ee\u7684\u3002\u5982\u679c\u4f60\u66fe\u82b1\u5f88\u591a\u65f6\u95f4\u6e05\u7406 \u5176\u5b83\u4eba\u7559\u4e0b\u7684\u5783\u573e\uff0c\u4f60\u5c31\u4f1a\u5f88\u5feb\u5b66\u4f1a\u611f\u8c22\u8fd9\u70b9\u591a\u4f59\u7684\u4fe1\u606f\u3002\uff08\u5f53\u7136\uff0c\u61c2\u5f97\u7528const\u7684\u7a0b\u5e8f\u5458\u5f88\u5c11\u4f1a\u7559\u4e0b\u7684\u5783\u573e\u8ba9\u522b\u4eba\u6765\u6e05\u7406\u7684\u3002\uff09\r\n2) \u901a\u8fc7\u7ed9\u4f18\u5316\u5668\u4e00\u4e9b\u9644\u52a0\u7684\u4fe1\u606f\uff0c\u4f7f\u7528\u5173\u952e\u5b57const\u4e5f\u8bb8\u80fd\u4ea7\u751f\u66f4\u7d27\u51d1\u7684\u4ee3\u7801\u3002\r\n3) \u5408\u7406\u5730\u4f7f\u7528\u5173\u952e\u5b57const\u53ef\u4ee5\u4f7f\u7f16\u8bd1\u5668\u5f88\u81ea\u7136\u5730\u4fdd\u62a4\u90a3\u4e9b\u4e0d\u5e0c\u671b\u88ab\u6539\u53d8\u7684\u53c2\u6570\uff0c\u9632\u6b62\u5176\u88ab\u65e0\u610f\u7684\u4ee3\u7801\u4fee\u6539\u3002\u7b80\u800c\u8a00\u4e4b\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11bug\u7684\u51fa\u73b0\u3002"},{"ID":"427","typeID":"12","question":"\u5173\u952e\u5b57static\u7684\u4f5c\u7528\u662f\u4ec0\u4e48\uff1f","answer":"\u5728C\u8bed\u8a00\u4e2d\uff0c\u5173\u952e\u5b57static\u6709\u4e09\u4e2a\u660e\u663e\u7684\u4f5c\u7528\uff1a\r\n1)\u5728\u51fd\u6570\u4f53\uff0c\u4e00\u4e2a\u88ab\u58f0\u660e\u4e3a\u9759\u6001\u7684\u53d8\u91cf\u5728\u8fd9\u4e00\u51fd\u6570\u88ab\u8c03\u7528\u8fc7\u7a0b\u4e2d\u7ef4\u6301\u5176\u503c\u4e0d\u53d8\u3002\r\n2) \u5728\u6a21\u5757\u5185\uff08\u4f46\u5728\u51fd\u6570\u4f53\u5916\uff09\uff0c\u4e00\u4e2a\u88ab\u58f0\u660e\u4e3a\u9759\u6001\u7684\u53d8\u91cf\u53ef\u4ee5\u88ab\u6a21\u5757\u5185\u6240\u7528\u51fd\u6570\u8bbf\u95ee\uff0c\u4f46\u4e0d\u80fd\u88ab\u6a21\u5757\u5916\u5176\u5b83\u51fd\u6570\u8bbf\u95ee\u3002\u5b83\u662f\u4e00\u4e2a\u672c\u5730\u7684\u5168\u5c40\u53d8\u91cf\u3002\r\n3) \u5728\u6a21\u5757\u5185\uff0c\u4e00\u4e2a\u88ab\u58f0\u660e\u4e3a\u9759\u6001\u7684\u51fd\u6570\u53ea\u53ef\u88ab\u8fd9\u4e00\u6a21\u5757\u5185\u7684\u5176\u5b83\u51fd\u6570\u8c03\u7528\u3002\u90a3\u5c31\u662f\uff0c\u8fd9\u4e2a\u51fd\u6570\u88ab\u9650\u5236\u5728\u58f0\u660e\u5b83\u7684\u6a21\u5757\u7684\u672c\u5730\u8303\u56f4\u5185\u4f7f\u7528\u3002"},{"ID":"426","typeID":"12","question":"\u600e\u4e48\u6837\u7528C\u7f16\u5199\u6b7b\u5faa\u73af\u5462\uff1f","answer":"while(1)\r\n{\r\n}\r\n"},{"ID":"425","typeID":"12","question":"\u5199\u4e00\u4e2a\"\u6807\u51c6\"\u5b8fMIN \uff0c\u8fd9\u4e2a\u5b8f\u8f93\u5165\u4e24\u4e2a\u53c2\u6570\u5e76\u8fd4\u56de\u8f83\u5c0f\u7684\u4e00\u4e2a\uff1f","answer":" #define MIN(A,B) \uff08\uff08A\uff09 <= (B) ? (A) : (B)) "},{"ID":"424","typeID":"12","question":"\u7528\u9884\u5904\u7406\u6307\u4ee4#define \u58f0\u660e\u4e00\u4e2a\u5e38\u6570\uff0c\u7528\u4ee5\u8868\u660e1\u5e74\u4e2d\u6709\u591a\u5c11\u79d2\uff08\u5ffd\u7565\u95f0\u5e74\u95ee\u9898\uff09","answer":" #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL"},{"ID":"277","typeID":"12","question":"\u8bf7\u7f16\u5199\u51fd\u6570fun\uff0c\u5176\u529f\u80fd\u662f\uff1a\u5c06\u4e24\u4e2a\u4e24\u4f4d\u6570\u7684\u6b63\u6574\u6570a\u3001b\u5408\u5e76\u5f62\u6210\u4e00\u4e2a\u6574\u6570\u653e\u5728c\u4e2d\u3002\u5408\u5e76\u7684\u65b9\u5f0f\u662f\uff1a\u5c06a\u6570\u7684\u5341\u4f4d\u548c\u4e2a\u4f4d\u6570\u4f9d\u6b21\u653e\u5728c\u6570\u7684\u5343\u4f4d\u548c\u5341\u4f4d\u4e0a\uff0cb\u6570\u7684\u5341\u4f4d\u548c\u4e2a\u4f4d\u6570\u4f9d\u6b21\u653e\u5728c\u6570\u7684\u767e\u4f4d\u548c\u4e2a\u4f4d\u4e0a\u3002","answer":"#include <conio.h>\r\n\r\n#include <stdio.h>\r\n\r\n \r\n\r\nvoid fun (int a, int b ,long *c)\r\n\r\n{\r\n\r\n}\r\n\r\n \r\n\r\nmain ()\r\n\r\n{\r\n\r\nint a,b;\r\n\r\nlong c;\r\n\r\nclrscr ();\r\n\r\nprintf (\u201cInput a, b:\u201d);\r\n\r\nscanf(\u201c%d%d\u201d, &a, &b);\r\n\r\nfun (a, b, &c);\r\n\r\nprintf (\u201cThe result is: %d\n\u201d,  c);\r\n\r\n}"},{"ID":"276","typeID":"12","question":"\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u53ef\u4ee5\u7edf\u8ba1\u4e00\u4e2a\u957f\u5ea6\u4e3a2\u7684\u5b57\u7b26\u4e32\u5728\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982\uff0c\u5047\u5b9a\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u4e3a\uff1aasd asasdfg asd as zx67 asd mklo\uff0c\u5b50\u5b57\u7b26\u4e32\u4e3aas\uff0c\u5219\u5e94\u8f93\u51fa6\u3002","answer":"#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#include <conio.h>\r\n\r\n \r\n\r\nint fun(char *str,char *substr)\r\n\r\n{\r\n\r\n \r\n\r\n}\r\n\r\n \r\n\r\nmain()\r\n\r\n{\r\n\r\nchar str[81],substr[3];\r\n\r\nint n;\r\n\r\n \r\n\r\nclrscr() ;\r\n\r\nprintf(\u201c\u8f93\u5165\u4e3b\u5b57\u7b26\u4e32: \u201c);\r\n\r\ngets(str);\r\n\r\nprintf(\u201c\u8f93\u5165\u5b50\u5b57\u7b26\u4e32: \u201c);\r\n\r\ngets(substr);\r\n\r\nputs(str);\r\n\r\nputs(substr);\r\n\r\nn=fun(str,substr);\r\n\r\nprintf(\u201cn=%d\n\u201d,n);\r\n\r\n}"},{"ID":"275","typeID":"12","question":"\u4e0b\u5217\u7ed9\u5b9a\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570fun\u7684\u529f\u80fd\u662f\uff1a\u7ed9\u4e00\u7ef4\u6570\u7ec4a\u8f93\u5165\u4efb\u610f4\u4e2a\u6574\u6570\uff0c\u5e76\u6309\u5982\u4e0b\u7684\u89c4\u5f8b\u8f93\u51fa\u3002\u4f8b\u5982\u8f93\u51651\u30012\u30013\u30014","answer":"#include <stdio.h>\r\n\r\n#define   M   4\r\n\r\n \r\n\r\n\/********found********\/\r\n\r\nint fun(int a)\r\n\r\n{\r\n\r\nint i,j,k,m;\r\n\r\nprintf(\u201cEnter 4 number : \u201c);\r\n\r\nfor(i=0; i<M; i++)\r\n\r\nscanf(\u201c%d\u201d,&a[i]);\r\n\r\nprintf(\u201c\n\nThe result  :\n\n\u201d);\r\n\r\nfor(i=M;i>0;i\u2013)\r\n\r\n{\r\n\r\nk=a[M-1];\r\n\r\n\/********found********\/\r\n\r\nfor(j=M-1;j>0;j\u2013)\r\n\r\na[j]=a[j+1];\r\n\r\na[0]=k;\r\n\r\nfor(m=0; m<M; m++)\r\n\r\nprintf(\u201c%d  \u201c,a[m]);\r\n\r\nprintf(\u201c\n\u201d);\r\n\r\n}\r\n\r\n}\r\n\r\nmain()\r\n\r\n{\r\n\r\nint a[M];\r\n\r\nfun(a);\r\n\r\nprintf(\u201c\n\n\u201d);\r\n\r\n}\r\n"},{"ID":"274","typeID":"12","question":"\u7f16\u5199\u4e00\u4e2a\u51fd\u6570fun\uff0c\u5b83\u7684\u529f\u80fd\u662f\uff1a\u5b9e\u73b0\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u8fde\u63a5\uff08\u4e0d\u4f7f\u7528\u5e93\u51fd\u6570strcat\uff09\uff0c\u5373\u628ap2\u6240\u6307\u7684\u5b57\u7b26\u4e32\u8fde\u63a5\u5230p1\u6240\u6307\u7684\u5b57\u7b26\u4e32\u540e\u3002","answer":"#include <stdio.h>\r\n\r\n#include <conio.h>\r\n\r\n \r\n\r\nvoid fun(char p1[], char p2[])\r\n\r\n{\r\n\r\n}\r\n\r\n \r\n\r\nmain()\r\n\r\n{\r\n\r\nchar s1[80], s2[40] ;\r\n\r\nclrscr() ;\r\n\r\nprintf(\u201cEnter s1 and s2:\n\u201d) ;\r\n\r\nscanf(\u201c%s%s\u201d, s1, s2) ;\r\n\r\nprintf(\u201cs1=%s\n\u201d, s1) ;\r\n\r\nprintf(\u201cs2=%s\n\u201d, s2) ;\r\n\r\nprintf(\u201cInvoke fun(s1,s2):\n\u201d) ;\r\n\r\nfun(s1, s2) ;\r\n\r\nprintf(\u201cAfter invoking:\n\u201d) ;\r\n\r\nprintf(\u201c%s\n\u201d, s1) ;\r\n\r\n}"},{"ID":"273","typeID":"12","question":"\u8bf7\u7f16\u5199\u51fd\u6570fun\uff0c\u5b83\u7684\u529f\u80fd\u662f\u8ba1\u7b97\uff1a\r\n\r\ns =  (ln(1)+ln(2)+ln(3)+\u2026+ln(m))0.5\uff0c\r\n\r\ns\u4f5c\u4e3a\u51fd\u6570\u503c\u8fd4\u56de\u3002\u5728C\u8bed\u8a00\u4e2d\u53ef\u8c03\u7528log(n)\u51fd\u6570\u6c42ln(n)\u3002log\u51fd\u6570\u7684\u5f15\u7528\u8bf4\u660e\u662f\uff1adouble log(double x)\u3002\u4f8b\u5982\uff0c\u82e5m\u7684\u503c\u4e3a20\uff0c\u5219fun\u51fd\u6570\u503c\u4e3a6.506583\u3002","answer":"#include <conio.h>\r\n\r\n#include <math.h>\r\n\r\n#include <stdio.h>\r\n\r\n \r\n\r\ndouble  fun( int  m )\r\n\r\n{\r\n\r\n}\r\n\r\n \r\n\r\nmain()\r\n\r\n{\r\n\r\nclrscr();\r\n\r\nprintf(\u201c%f\n\u201d,fun(20));\r\n\r\n}"},{"ID":"272","typeID":"12","question":"\u5806\u548c\u6808\u7684\u7406\u8bba\u77e5\u8bc6","answer":" \u7533\u8bf7\u65b9\u5f0f\r\n\u6808: \u7531\u7cfb\u7edf\u81ea\u52a8\u5206\u914d\u3002 \u4f8b\u5982\uff0c\u58f0\u660e\u5728\u51fd\u6570\u4e2d\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf int a; \u7cfb\u7edf\u81ea\u52a8\u5728\u6808\u4e2d\u4e3aa\u5f00\u8f9f\u7a7a\u95f4\r\n\u5806: \u9700\u8981\u7a0b\u5e8f\u5458\u81ea\u5df1\u7533\u8bf7\uff0c\u5e76\u6307\u660e\u5927\u5c0f\uff0c\u5728c\u4e2dmalloc\u51fd\u6570\uff1a\u5982p1 = (char *)malloc(10); \u5728C++\u4e2d\u7528new\u8fd0\u7b97\u7b26 \u5982p2 = (char *)malloc(10); \u4f46\u662f\u6ce8\u610f\u5c40\u90e8\u53d8\u91cfp1\u3001p2\u672c\u8eab\u662f\u5728\u6808\u4e2d\u7684\uff0c\u4f46\u662f\u4ed6\u4eec\u6307\u5411\u7684\u7533\u8bf7\u5230\u7684\u5185\u5b58\u662f\u5728\u5806\u533a\uff0c\u8fd9\u70b9\u8981\u660e\u786e!\r\n\u7533\u8bf7\u540e\u7cfb\u7edf\u7684\u54cd\u5e94\r\n\u6808\uff1a\u53ea\u8981\u6808\u7684\u5269\u4f59\u7a7a\u95f4\u5927\u4e8e\u6240\u7533\u8bf7\u7a7a\u95f4\uff0c\u7cfb\u7edf\u5c06\u4e3a\u7a0b\u5e8f\u63d0\u4f9b\u5185\u5b58\uff0c\u5426\u5219\u5c06\u62a5\u5f02\u5e38\u63d0\u793a\u6808\u6ea2\u51fa\u3002\r\n\u5806\uff1a\u9996\u5148\u5e94\u8be5\u77e5\u9053\u64cd\u4f5c\u7cfb\u7edf\u6709\u4e00\u4e2a\u8bb0\u5f55\u7a7a\u95f2\u5185\u5b58\u5730\u5740\u7684\u94fe\u8868\uff0c\u5f53\u7cfb\u7edf\u6536\u5230\u7a0b\u5e8f\u7684\u7533\u8bf7\u65f6\uff0c \u4f1a\u904d\u5386\u8be5\u94fe\u8868\uff0c\u5bfb\u627e\u7b2c\u4e00\u4e2a\u7a7a\u95f4\u5927\u4e8e\u6240\u7533\u8bf7\u7a7a\u95f4\u7684\u5806\u7ed3\u70b9\uff0c\u7136\u540e\u5c06\u8be5\u7ed3\u70b9\u4ece\u7a7a\u95f2\u7ed3\u70b9\u94fe\u8868\u4e2d\u5220\u9664\uff0c\u5e76\u5c06\u8be5\u7ed3\u70b9\u7684\u7a7a\u95f4\u5206\u914d\u7ed9\u7a0b\u5e8f\uff0c\u53e6\u5916\uff0c\u5bf9\u4e8e\u5927\u591a\u6570\u7cfb\u7edf\uff0c\u4f1a\u5728\u8fd9\u5757\u5185\u5b58\u7a7a\u95f4\u4e2d\u7684\u9996\u5730\u5740\u5904\u8bb0\u5f55\u672c\u6b21\u5206\u914d\u7684\u5927\u5c0f\uff0c\u8fd9\u6837\uff0c\u4ee3\u7801\u4e2d\u7684delete\u8bed\u53e5\u624d\u80fd\u6b63\u786e\u7684\u91ca\u653e\u672c\u5185\u5b58\u7a7a\u95f4\u3002\u53e6\u5916\uff0c\u7531\u4e8e\u627e\u5230\u7684\u5806\u7ed3\u70b9\u7684\u5927\u5c0f\u4e0d\u4e00\u5b9a\u6b63\u597d\u7b49\u4e8e\u7533\u8bf7\u7684\u5927\u5c0f\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u7684\u5c06\u591a\u4f59\u7684\u90a3\u90e8\u5206\u91cd\u65b0\u653e\u5165\u7a7a\u95f2\u94fe\u8868\u4e2d\u3002\r\n\u7533\u8bf7\u5927\u5c0f\u7684\u9650\u5236\r\n\u6808\uff1a\u5728Windows\u4e0b,\u6808\u662f\u5411\u4f4e\u5730\u5740\u6269\u5c55\u7684\u6570\u636e\u7ed3\u6784\uff0c\u662f\u4e00\u5757\u8fde\u7eed\u7684\u5185\u5b58\u533a\u57df\u3002\u8fd9\u53e5\u8bdd\u7684\u610f\u601d\u662f\u6808\u9876\u7684\u5730\u5740\u548c\u6808\u7684\u6700\u5927\u5bb9\u91cf\u662f\u7cfb\u7edf\u9884\u5148\u89c4\u5b9a\u597d\u7684\uff0c\u5728WINDOWS\u4e0b\uff0c\u6808\u7684\u5927\u5c0f\u662f2M(\u4e5f\u6709\u7684\u8bf4\u662f1M\uff0c\u603b\u4e4b\u662f\u4e00\u4e2a\u7f16\u8bd1\u65f6\u5c31\u786e\u5b9a\u7684\u5e38\u6570)\uff0c\u5982\u679c\u7533\u8bf7\u7684\u7a7a\u95f4\u8d85\u8fc7\u6808\u7684\u5269\u4f59\u7a7a\u95f4\u65f6\uff0c\u5c06\u63d0\u793aoverflow\u3002\u56e0\u6b64\uff0c\u80fd\u4ece\u6808\u83b7\u5f97\u7684\u7a7a\u95f4\u8f83\u5c0f\u3002\r\n\u5806\uff1a\u5806\u662f\u5411\u9ad8\u5730\u5740\u6269\u5c55\u7684\u6570\u636e\u7ed3\u6784\uff0c\u662f\u4e0d\u8fde\u7eed\u7684\u5185\u5b58\u533a\u57df\u3002\u8fd9\u662f\u7531\u4e8e\u7cfb\u7edf\u662f\u7528\u94fe\u8868\u6765\u5b58\u50a8\u7684\u7a7a\u95f2\u5185\u5b58\u5730\u5740\u7684\uff0c\u81ea\u7136\u662f\u4e0d\u8fde\u7eed\u7684\uff0c\u800c\u94fe\u8868\u7684\u904d\u5386\u65b9\u5411\u662f\u7531\u4f4e\u5730\u5740\u5411\u9ad8\u5730\u5740\u3002\u5806\u7684\u5927\u5c0f\u53d7\u9650\u4e8e\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u6709\u6548\u7684\u865a\u62df\u5185\u5b58\u3002\u7531\u6b64\u53ef\u89c1\uff0c\u5806\u83b7\u5f97\u7684\u7a7a\u95f4\u6bd4\u8f83\u7075\u6d3b\uff0c\u4e5f\u6bd4\u8f83\u5927\u3002\r\n \u7533\u8bf7\u6548\u7387\u7684\u6bd4\u8f83\uff1a\r\n\u6808\uff1a\u7531\u7cfb\u7edf\u81ea\u52a8\u5206\u914d\uff0c\u901f\u5ea6\u8f83\u5feb\u3002\u4f46\u7a0b\u5e8f\u5458\u662f\u65e0\u6cd5\u63a7\u5236\u7684\u3002\r\n\u5806\uff1a\u662f\u7531malloc\/new\u5206\u914d\u7684\u5185\u5b58\uff0c\u4e00\u822c\u901f\u5ea6\u6bd4\u8f83\u6162\uff0c\u800c\u4e14\u5bb9\u6613\u4ea7\u751f\u5185\u5b58\u788e\u7247,\u4e0d\u8fc7\u7528\u8d77\u6765\u6700\u65b9\u4fbf\u3002\r\n\r\n \u5806\u548c\u6808\u4e2d\u7684\u5b58\u50a8\u5185\u5bb9\r\n\u6808\uff1a \u5728\u51fd\u6570\u8c03\u7528\u65f6\uff0c\u7b2c\u4e00\u4e2a\u8fdb\u6808\u7684\u662f\u4e3b\u51fd\u6570\u4e2d\u7684\u4e0b\u4e00\u6761\u6307\u4ee4(\u51fd\u6570\u8c03\u7528\u8bed\u53e5\u7684\u4e0b\u4e00\u6761\u53ef\u6267\u884c\u8bed\u53e5)\u7684\u5730\u5740\uff0c\u7136\u540e\u662f\u51fd\u6570\u7684\u5404\u4e2a\u53c2\u6570\uff0c\u5728\u5927\u591a\u6570\u7684C\u7f16\u8bd1\u5668\u4e2d\uff0c\u53c2\u6570\u662f\u7531\u53f3\u5f80\u5de6\u5165\u6808\u7684\uff0c\u7136\u540e\u662f\u51fd\u6570\u4e2d\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u6ce8\u610f\u9759\u6001\u53d8\u91cf\u662f\u4e0d\u5165\u6808\u7684\u3002\u5f53\u672c\u6b21\u51fd\u6570\u8c03\u7528\u7ed3\u675f\u540e\uff0c\u5c40\u90e8\u53d8\u91cf\u5148\u51fa\u6808\uff0c\u7136\u540e\u662f\u53c2\u6570\uff0c\u6700\u540e\u6808\u9876\u6307\u9488\u6307\u5411\u6700\u5f00\u59cb\u5b58\u7684\u5730\u5740\uff0c\u4e5f\u5c31\u662f\u4e3b\u51fd\u6570\u4e2d\u7684\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c\u7a0b\u5e8f\u7531\u8be5\u70b9\u7ee7\u7eed\u8fd0\u884c\u3002\r\n\u5806\uff1a\u4e00\u822c\u662f\u5728\u5806\u7684\u5934\u90e8\u7528\u4e00\u4e2a\u5b57\u8282\u5b58\u653e\u5806\u7684\u5927\u5c0f\u3002\u5806\u4e2d\u7684\u5177\u4f53\u5185\u5bb9\u6709\u7a0b\u5e8f\u5458\u5b89\u6392\u3002\r\n\r\n\u5b58\u53d6\u6548\u7387\u7684\u6bd4\u8f83\r\nchar s1\uff3b\uff3d = \u201caaaaaaaaaaaaaaa\u201d;\r\nchar *s2 = \u201cbbbbbbbbbbbbbbbbb\u201d;\r\naaaaaaaaaaa\u662f\u5728\u8fd0\u884c\u65f6\u523b\u8d4b\u503c\u7684\uff1b\r\n\u800cbbbbbbbbbbb\u662f\u5728\u7f16\u8bd1\u65f6\u5c31\u786e\u5b9a\u7684\uff1b\r\n\u4f46\u662f\uff0c\u5728\u4ee5\u540e\u7684\u5b58\u53d6\u4e2d\uff0c\u5728\u6808\u4e0a\u7684\u6570\u7ec4\u6bd4\u6307\u9488\u6240\u6307\u5411\u7684\u5b57\u7b26\u4e32(\u4f8b\u5982\u5806)\u5feb\u3002\r\n\u6bd4\u5982\uff1a\r\n#include\r\nvoid main()\r\n{\r\nchar a = 1;\r\nchar c\uff3b\uff3d = \u201c1234567890\u2033;\r\nchar *p =\u201d1234567890\u2033;\r\na = c\uff3b1\uff3d;\r\na = p\uff3b1\uff3d;\r\nreturn;\r\n}\r\n\u5bf9\u5e94\u7684\u6c47\u7f16\u4ee3\u7801\r\n10: a = c\uff3b1\uff3d;\r\n00401067 8A 4D F1 mov cl,byte ptr \uff3bebp-0Fh\uff3d\r\n0040106A 88 4D FC mov byte ptr \uff3bebp-4\uff3d,cl\r\n11: a = p\uff3b1\uff3d;\r\n0040106D 8B 55 EC mov edx,dword ptr \uff3bebp-14h\uff3d\r\n00401070 8A 42 01 mov al,byte ptr \uff3bedx+1\uff3d\r\n00401073 88 45 FC mov byte ptr \uff3bebp-4\uff3d,al\r\n\u7b2c\u4e00\u79cd\u5728\u8bfb\u53d6\u65f6\u76f4\u63a5\u5c31\u628a\u5b57\u7b26\u4e32\u4e2d\u7684\u5143\u7d20\u8bfb\u5230\u5bc4\u5b58\u5668cl\u4e2d\uff0c\u800c\u7b2c\u4e8c\u79cd\u5219\u8981\u5148\u628a\u6307\u9488\u503c\u8bfb\u5230edx\u4e2d\uff0c\u5728\u6839\u636eedx\u8bfb\u53d6\u5b57\u7b26\uff0c\u663e\u7136\u6162\u4e86\u3002\r\n\u5c0f\u7ed3\r\n\u5806\u548c\u6808\u7684\u533a\u522b\u53ef\u4ee5\u7528\u5982\u4e0b\u7684\u6bd4\u55bb\u6765\u770b\u51fa\uff1a \u4f7f\u7528\u6808\u5c31\u8c61\u6211\u4eec\u53bb\u996d\u9986\u91cc\u5403\u996d\uff0c\u53ea\u7ba1\u70b9\u83dc(\u53d1\u51fa\u7533\u8bf7)\u3001\u4ed8\u94b1\u3001\u548c\u5403(\u4f7f\u7528)\uff0c\u5403\u9971\u4e86\u5c31\u8d70\uff0c\u4e0d\u5fc5\u7406\u4f1a\u5207\u83dc\u3001\u6d17\u83dc\u7b49\u51c6\u5907\u5de5\u4f5c\u548c\u6d17\u7897\u3001\u5237\u9505\u7b49\u626b\u5c3e\u5de5\u4f5c\uff0c\u4ed6\u7684\u597d\u5904\u662f\u5feb\u6377\uff0c\u4f46\u662f\u81ea\u7531\u5ea6\u5c0f\u3002\u4f7f\u7528\u5806\u5c31\u8c61\u662f\u81ea\u5df1\u52a8\u624b\u505a\u559c\u6b22\u5403\u7684\u83dc\u80b4\uff0c\u6bd4\u8f83\u9ebb\u70e6\uff0c\u4f46\u662f\u6bd4\u8f83\u7b26\u5408\u81ea\u5df1\u7684\u53e3\u5473\uff0c\u800c\u4e14\u81ea\u7531\u5ea6\u5927\u3002\r\n\u8fd8\u6709\u5c31\u662f\u51fd\u6570\u8c03\u7528\u65f6\u4f1a\u5728\u6808\u4e0a\u6709\u4e00\u7cfb\u5217\u7684\u4fdd\u7559\u73b0\u573a\u53ca\u4f20\u9012\u53c2\u6570\u7684\u64cd\u4f5c\u3002\u6808\u7684\u7a7a\u95f4\u5927\u5c0f\u6709\u9650\u5b9a\uff0cVC\u7684\u7f3a\u7701\u662f2M\u3002\u6808\u4e0d\u591f\u7528\u7684\u60c5\u51b5\u4e00\u822c\u662f\u7a0b\u5e8f\u4e2d\u5206\u914d\u4e86\u5927\u91cf\u6570\u7ec4\u548c\u9012\u5f52\u51fd\u6570\u5c42\u6b21\u592a\u6df1\u3002\u6709\u4e00\u70b9\u5fc5\u987b\u77e5\u9053\uff0c\u5f53\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u5b8c\u8fd4\u56de\u540e\u5b83\u4f1a\u91ca\u653e\u8be5\u51fd\u6570\u4e2d\u6240\u6709\u7684\u6808\u7a7a\u95f4\u3002\u6808\u662f\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u7ba1\u7406\u7684\uff0c\u4e0d\u7528\u4f60\u64cd\u5fc3\u3002\u5806\u662f\u52a8\u6001\u5206\u914d\u5185\u5b58\u7684\uff0c\u5e76\u4e14\u4f60\u53ef\u4ee5\u5206\u914d\u4f7f\u7528\u5f88\u5927\u7684\u5185\u5b58\u3002\u4f46\u662f\u7528\u4e0d\u597d\u4f1a\u4ea7\u751f\u5185\u5b58\u6cc4\u6f0f\u3002\u5e76\u4e14\u9891\u7e41\u5730malloc\u548cfree\u4f1a\u4ea7\u751f\u5185\u5b58\u788e\u7247(\u6709\u70b9\u7c7b\u4f3c\u78c1\u76d8\u788e\u7247)\uff0c\u56e0\u4e3aC\u5206\u914d\u52a8\u6001\u5185\u5b58\u65f6\u662f\u5bfb\u627e\u5339\u914d\u7684\u5185\u5b58\u7684\u3002\u800c\u7528\u6808\u5219\u4e0d\u4f1a\u4ea7\u751f\u788e\u7247\u3002\u5728\u6808\u4e0a\u5b58\u53d6\u6570\u636e\u6bd4\u901a\u8fc7\u6307\u9488\u5728\u5806\u4e0a\u5b58\u53d6\u6570\u636e\u5feb\u4e9b\u3002\u4e00\u822c\u5927\u5bb6\u8bf4\u7684\u5806\u6808\u548c\u6808\u662f\u4e00\u6837\u7684\uff0c\u5c31\u662f\u6808(stack)\uff0c\u800c\u8bf4\u5806\u65f6\u624d\u662f\u5806heap\u3002\u6808\u662f\u5148\u5165\u540e\u51fa\u7684\uff0c\u4e00\u822c\u662f\u7531\u9ad8\u5730\u5740\u5411\u4f4e\u5730\u5740\u751f\u957f\u3002"},{"ID":"271","typeID":"12","question":"\u7a0b\u5e8f\u7684\u5185\u5b58\u5206\u914d","answer":"1\u3001\u6808\u533a(stack)\uff1a \u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u5206\u914d\u91ca\u653e\uff0c\u5b58\u653e\u51fd\u6570\u7684\u53c2\u6570\u503c\uff0c\u5c40\u90e8\u53d8\u91cf\u7b49\u3002\u5176\u64cd\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\u4e8e\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u6808\u3002\r\n2\u3001\u5806\u533a(heap)\uff1a \u4e00\u822c\u7531\u7a0b\u5e8f\u5458\u5206\u914d\u91ca\u653e\uff08malloc\/free\u3001new\/delete\uff09\uff0c \u82e5\u7a0b\u5e8f\u5458\u4e0d\u91ca\u653e\uff0c\u7a0b\u5e8f\u7ed3\u675f\u65f6\u53ef\u80fd\u7531\u64cd\u4f5c\u7cfb\u7edf\u56de\u6536\u3002\u6ce8\u610f\u5b83\u4e0e\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u5806\u662f\u4e24\u56de\u4e8b\uff0c\u5206\u914d\u65b9\u5f0f\u5012\u662f\u7c7b\u4f3c\u4e8e\u94fe\u8868\u3002\r\n3\u3001\u5168\u5c40\u533a(static)\uff1a \u5168\u5c40\u53d8\u91cf\u548c\u9759\u6001\u53d8\u91cf\u7684\u5b58\u50a8\u662f\u653e\u5728\u4e00\u5757\u7684\uff0c\u521d\u59cb\u5316\u7684\u5168\u5c40\u53d8\u91cf\u548c\u9759\u6001\u53d8\u91cf\u5728\u4e00\u5757\u533a\u57df\uff0c \u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u53d8\u91cf\u548c\u672a\u521d\u59cb\u5316\u7684\u9759\u6001\u53d8\u91cf\u5728\u76f8\u90bb\u7684\u53e6\u4e00\u5757\u533a\u57df\uff0c\u7a0b\u5e8f\u7ed3\u675f\u540e\u7531\u7cfb\u7edf\u91ca\u653e\u3002\r\n4\u3001\u6587\u5b57\u5e38\u91cf\u533a\uff1a \u5e38\u91cf\u5b57\u7b26\u4e32\u5c31\u662f\u653e\u5728\u8fd9\u91cc\u7684\uff0c \u7a0b\u5e8f\u7ed3\u675f\u540e\u7531\u7cfb\u7edf\u91ca\u653e\u3002\r\n5\u3001\u7a0b\u5e8f\u4ee3\u7801\u533a\uff1a \u5b58\u653e\u51fd\u6570\u4f53\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801\u3002\r\nExample:\r\nint a = 0; \/\/ \u5168\u5c40\u521d\u59cb\u5316\u533a\r\nchar *p1; \/\/ \u5168\u5c40\u672a\u521d\u59cb\u5316\u533a\r\nmain()\r\n{\r\nint a; \/\/ \u6808\u533a\r\nchar s\uff3b\uff3d = \u201cabc\u201d; \/\/ \u6808\u533a\r\nchar *p2; \/\/ \u6808\u533a\r\nchar *p3 = \u201c123456\u2033; \/\/ 123456\u0000\u5728\u5e38\u91cf\u533a\uff0cp3\u5728\u6808\u4e0a\u3002\r\nstatic int c =0\uff1b \/\/ \u5168\u5c40(\u9759\u6001)\u521d\u59cb\u5316\u533a\r\np1 = (char *)malloc(10);\r\np2 = (char *)malloc(20); \/\/ \u5206\u914d\u5f97\u6765\u5f9710\u548c20\u5b57\u8282\u7684\u533a\u57df\u5c31\u5728\u5806\u533a\u3002\r\nstrcpy(p1, \u201c123456\u2033); \/\/ 123456\u0000\u653e\u5728\u5e38\u91cf\u533a\uff0c\u7f16\u8bd1\u5668\u53ef\u80fd\u4f1a\u5c06\u5b83\u4e0ep3\u6240\u6307\u5411\u7684\u201d123456\u2033\u4f18\u5316\u6210\u4e00\u4e2a\u5730\u65b9\u3002\r\n}"},{"ID":"270","typeID":"12","question":"c++\u5185\u5b58\u6cc4\u6f0f\u68c0\u6d4b","answer":"\u68c0\u6d4b\u5185\u5b58\u6cc4\u6f0f\u7684\u65b9\u6cd5\u591a\u79cd\u591a\u6837\uff0c\u6709\u4f7f\u7528\u5185\u5b58\u6cc4\u6f0f\u68c0\u6d4b\u5de5\u5177\uff08\u6bd4\u5982BoundsChecker\uff09\u68c0\u6d4b\u5185\u5b58\u6cc4\u6f0f\uff1b\u6709\u76f4\u63a5\u770b\u4ee3\u7801\u68c0\u6d4b\u4ee3\u7801\u903b\u8f91\uff0c\u770b\u90a3\u4e9b\u5730\u65b9\u662f\u5426\u6ca1\u6709\u91ca\u653e\u5185\u5b58\u3002\u4e00\u822c\u5730\u9759\u6001\u5185\u5b58\u6cc4\u6f0f\u901a\u8fc7\u5de5\u5177\u4e0e\u4ee3\u7801\u68c0\u67e5\u5f88\u5bb9\u6613\u627e\u5230\u6cc4\u6f0f\u70b9\uff1b\u52a8\u6001\u7684\u5185\u5b58\u6cc4\u6f0f\u5f88\u96be\u67e5\uff0c\u4e00\u822c\u901a\u8fc7\u5728\u4ee3\u7801\u4e2d\u52a0\u65ad\u70b9\u8ddf\u8e2a\u548cRun-Time\u5185\u5b58\u68c0\u6d4b\u5de5\u5177\u6765\u67e5\u627e\u3002"},{"ID":"269","typeID":"12","question":"C++\u5185\u5b58\u6cc4\u6f0f\u7684\u53d1\u751f\u65b9\u5f0f","answer":"1. \u5e38\u53d1\u6027\u5185\u5b58\u6cc4\u6f0f\u3002\u53d1\u751f\u5185\u5b58\u6cc4\u6f0f\u7684\u4ee3\u7801\u4f1a\u88ab\u591a\u6b21\u6267\u884c\u5230\uff0c\u6bcf\u6b21\u88ab\u6267\u884c\u7684\u65f6\u5019\u90fd\u4f1a\u5bfc\u81f4\u4e00\u5757\u5185\u5b58\u6cc4\u6f0f\u3002\u6bd4\u5982\u4f8b\u4e8c\uff0c\u5982\u679cSomething()\u51fd\u6570\u4e00\u76f4\u8fd4\u56deTrue\uff0c\u90a3\u4e48pOldBmp\u6307\u5411\u7684HBITMAP\u5bf9\u8c61\u603b\u662f\u53d1\u751f\u6cc4\u6f0f\u3002\r\n\r\n2. \u5076\u53d1\u6027\u5185\u5b58\u6cc4\u6f0f\u3002\u53d1\u751f\u5185\u5b58\u6cc4\u6f0f\u7684\u4ee3\u7801\u53ea\u6709\u5728\u67d0\u4e9b\u7279\u5b9a\u73af\u5883\u6216\u64cd\u4f5c\u8fc7\u7a0b\u4e0b\u624d\u4f1a\u53d1\u751f\u3002\u6bd4\u5982\u4f8b\u4e8c\uff0c\u5982\u679cSomething()\u51fd\u6570\u53ea\u6709\u5728\u7279\u5b9a\u73af\u5883\u4e0b\u624d\u8fd4\u56deTrue\uff0c\u90a3\u4e48pOldBmp\u6307\u5411\u7684HBITMAP\u5bf9\u8c61\u5e76\u4e0d\u603b\u662f\u53d1\u751f\u6cc4\u6f0f\u3002\u5e38\u53d1\u6027\u548c\u5076\u53d1\u6027\u662f\u76f8\u5bf9\u7684\u3002\u5bf9\u4e8e\u7279\u5b9a\u7684\u73af\u5883\uff0c\u5076\u53d1\u6027\u7684\u4e5f\u8bb8\u5c31\u53d8\u6210\u4e86\u5e38\u53d1\u6027\u7684\u3002\u6240\u4ee5\u6d4b\u8bd5\u73af\u5883\u548c\u6d4b\u8bd5\u65b9\u6cd5\u5bf9\u68c0\u6d4b\u5185\u5b58\u6cc4\u6f0f\u81f3\u5173\u91cd\u8981\u3002\r\n\r\n3. \u4e00\u6b21\u6027\u5185\u5b58\u6cc4\u6f0f\u3002\u53d1\u751f\u5185\u5b58\u6cc4\u6f0f\u7684\u4ee3\u7801\u53ea\u4f1a\u88ab\u6267\u884c\u4e00\u6b21\uff0c\u6216\u8005\u7531\u4e8e\u7b97\u6cd5\u4e0a\u7684\u7f3a\u9677\uff0c\u5bfc\u81f4\u603b\u4f1a\u6709\u4e00\u5757\u4ec5\u4e14\u4e00\u5757\u5185\u5b58\u53d1\u751f\u6cc4\u6f0f\u3002\u6bd4\u5982\uff0c\u5728\u7c7b\u7684\u6784\u9020\u51fd\u6570\u4e2d\u5206\u914d\u5185\u5b58\uff0c\u5728\u6790\u6784\u51fd\u6570\u4e2d\u5374\u6ca1\u6709\u91ca\u653e\u8be5\u5185\u5b58\uff0c\u4f46\u662f\u56e0\u4e3a\u8fd9\u4e2a\u7c7b\u662f\u4e00\u4e2aSingleton\uff0c\u6240\u4ee5\u5185\u5b58\u6cc4\u6f0f\u53ea\u4f1a\u53d1\u751f\u4e00\u6b21\u3002\r\n\r\n4. \u9690\u5f0f\u5185\u5b58\u6cc4\u6f0f\u3002\u7a0b\u5e8f\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u4e0d\u505c\u7684\u5206\u914d\u5185\u5b58\uff0c\u4f46\u662f\u76f4\u5230\u7ed3\u675f\u7684\u65f6\u5019\u624d\u91ca\u653e\u5185\u5b58\u3002\u4e25\u683c\u7684\u8bf4\u8fd9\u91cc\u5e76\u6ca1\u6709\u53d1\u751f\u5185\u5b58\u6cc4\u6f0f\uff0c\u56e0\u4e3a\u6700\u7ec8\u7a0b\u5e8f\u91ca\u653e\u4e86\u6240\u6709\u7533\u8bf7\u7684\u5185\u5b58\u3002\u4f46\u662f\u5bf9\u4e8e\u4e00\u4e2a \u670d\u52a1\u5668\u7a0b\u5e8f\uff0c\u9700\u8981\u8fd0\u884c\u51e0\u5929\uff0c\u51e0\u5468\u751a\u81f3\u51e0\u4e2a\u6708\uff0c\u4e0d\u53ca\u65f6\u91ca\u653e\u5185\u5b58\u4e5f\u53ef\u80fd\u5bfc\u81f4\u6700\u7ec8\u8017\u5c3d\u7cfb\u7edf\u7684\u6240\u6709\u5185\u5b58\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u79f0\u8fd9\u7c7b\u5185\u5b58\u6cc4\u6f0f\u4e3a\u9690\u5f0f\u5185\u5b58\u6cc4\u6f0f\u3002"},{"ID":"268","typeID":"12","question":"\u4e0d\u80fd\u505aswitch\uff08\uff09\u7684\u53c2\u6570\u7c7b\u578b\u662f\uff1a","answer":"SWITH\uff08\u8868\u8fbe\u5f0f\uff09\uff0c\u8868\u8fbe\u5f0f\u53ef\u4ee5\u662f\u6574\u578b\u3001\u5b57\u7b26\u578b\u4ee5\u53ca\u679a\u4e3e\u7c7b\u578b\u7b49\u8868\u8fbe\u5f0f\u3002\r\n\r\nswitch\u7684\u53c2\u6570\u4e0d\u80fd\u4e3a\u5b9e\u578b\u3002"},{"ID":"267","typeID":"12","question":"\u7528\u6237\u8f93\u5165M\uff0cN\u503c\uff0c\u4ece1\u81f3N\u5f00\u59cb\u987a\u5e8f\u5faa\u73af\u6570\u6570\uff0c\u6bcf\u6570\u5230M\u8f93\u51fa\u8be5\u6570\u503c\uff0c\u76f4\u81f3\u5168\u90e8\u8f93\u51fa\u3002\u5199\u51faC\u7a0b\u5e8f\u3002","answer":"\u5faa\u73af\u94fe\u8868\uff0c\u7528\u53d6\u4f59\u64cd\u4f5c\u505a \u2014\u2014>\uff1f\uff1f"},{"ID":"266","typeID":"12","question":"IP\u5730\u5740\u7684\u7f16\u7801\u5206\u4e3a\u54ea\u4fe9\u90e8\u5206\uff1f","answer":"IP\u5730\u5740\u7531\u4e24\u90e8\u5206\u7ec4\u6210\uff0c\u7f51\u7edc\u53f7\u548c\u4e3b\u673a\u53f7\u3002\u4e0d\u8fc7\u662f\u8981\u548c\u201c\u5b50\u7f51\u63a9\u7801\u201d\u6309\u4f4d\u4e0e\u4e0a\u4e4b\u540e\u624d\u80fd\u533a\u5206\u54ea\u4e9b\u662f\u7f51\u7edc\u4f4d\u54ea\u4e9b\u662f\u4e3b\u673a\u4f4d\u3002"},{"ID":"265","typeID":"12","question":"Internet\u7269\u7406\u5730\u5740\u548cIP\u5730\u5740\u8f6c\u6362\u91c7\u7528\u4ec0\u4e48\u534f\u8bae\uff1f","answer":"ARP \uff08Address Resolution Protocol\uff09\uff08\u5730\u5740\u89e3\u6790\u534f\u8bae\uff09"},{"ID":"264","typeID":"12","question":" Internet\u91c7\u7528\u54ea\u79cd\u7f51\u7edc\u534f\u8bae\uff1f\u8be5\u534f\u8bae\u7684\u4e3b\u8981\u5c42\u6b21\u7ed3\u6784\uff1f","answer":"tcp\/ip \u5e94\u7528\u5c42\/\u4f20\u8f93\u5c42\/\u7f51\u7edc\u5c42\/\u6570\u636e\u94fe\u8def\u5c42\/\u7269\u7406\u5c42"},{"ID":"263","typeID":"12","question":"\u5199\u51fafloat x \u4e0e\u201c\u96f6\u503c\u201d\u6bd4\u8f83\u7684if\u8bed\u53e5\u3002","answer":"if\uff08x>0.000001&&x<-0.000001\uff09"},{"ID":"262","typeID":"12","question":" \u5192\u6ce1\u6392\u5e8f\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\u4ec0\u4e48\uff1f","answer":"O\uff08n^2\uff09"},{"ID":"261","typeID":"12","question":"\u4ec0\u4e48\u51fd\u6570\u4e0d\u80fd\u58f0\u660e\u4e3a\u865a\u51fd\u6570\uff1f","answer":"constructor ==>C++\u4e2d\u7684\u7c7b\u7684\u6784\u9020\u51fd\u6570\u58f0\u660e"},{"ID":"260","typeID":"12","question":"\u5806\u6808\u6ea2\u51fa\u4e00\u822c\u662f\u7531\u4ec0\u4e48\u539f\u56e0\u5bfc\u81f4\u7684\uff1f","answer":"\u6ca1\u6709\u56de\u6536\u5783\u573e\u8d44\u6e90\r\n"},{"ID":"259","typeID":"12","question":"\u4ec0\u4e48\u662f\u5e73\u8861\u4e8c\u53c9\u6811\uff1f","answer":"\u5de6\u53f3\u5b50\u6811\u90fd\u662f\u5e73\u8861\u4e8c\u53c9\u6811 \u4e14\u5de6\u53f3\u5b50\u6811\u7684\u6df1\u5ea6\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u4e0d\u5927\u4e8e1"},{"ID":"258","typeID":"12","question":"\u5168\u5c40\u53d8\u91cf\u548c\u5c40\u90e8\u53d8\u91cf\u5728\u5185\u5b58\u4e2d\u662f\u5426\u6709\u533a\u522b\uff1f\u5982\u679c\u6709\uff0c\u662f\u4ec0\u4e48\u533a\u522b\uff1f","answer":"\u5168\u5c40\u53d8\u91cf\u50a8\u5b58\u5728\u9759\u6001\u6570\u636e\u533a\uff0c\u5c40\u90e8\u53d8\u91cf\u5728\u5806\u6808"},{"ID":"257","typeID":"12","question":"\u63cf\u8ff0\u5b9e\u65f6\u7cfb\u7edf\u7684\u57fa\u672c\u7279\u6027","answer":"\u5728\u7279\u5b9a\u65f6\u95f4\u5185\u5b8c\u6210\u7279\u5b9a\u7684\u4efb\u52a1\uff0c\u5b9e\u65f6\u6027\u4e0e\u53ef\u9760\u6027"},{"ID":"256","typeID":"12","question":"\u5f15\u7528\u4e0e\u6307\u9488\u6709\u4ec0\u4e48\u533a\u522b\uff1f","answer":"1\uff09 \u5f15\u7528\u5fc5\u987b\u88ab\u521d\u59cb\u5316\uff0c\u6307\u9488\u4e0d\u5fc5\u3002\r\n\r\n2\uff09 \u5f15\u7528\u521d\u59cb\u5316\u4ee5\u540e\u4e0d\u80fd\u88ab\u6539\u53d8\uff0c\u6307\u9488\u53ef\u4ee5\u6539\u53d8\u6240\u6307\u7684\u5bf9\u8c61\u3002\r\n\r\n3\uff09 \u4e0d\u5b58\u5728\u6307\u5411\u7a7a\u503c\u7684\u5f15\u7528\uff0c\u4f46\u662f\u5b58\u5728\u6307\u5411\u7a7a\u503c\u7684\u6307\u9488\u3002"},{"ID":"255","typeID":"12","question":"static\u6709\u4ec0\u4e48\u7528\u9014\uff1f\uff08\u8bf7\u81f3\u5c11\u8bf4\u660e\u4e24\u79cd\uff09","answer":"1.\u9650\u5236\u53d8\u91cf\u7684\u4f5c\u7528\u57df\r\n\r\n2.\u8bbe\u7f6e\u53d8\u91cf\u7684\u5b58\u50a8\u57df"},{"ID":"254","typeID":"12","question":"C++\u7ee7\u627f\u673a\u5236","answer":"n\u7c7b\u6210\u5458\u7684\u8bbf\u95ee\u63a7\u5236\u65b9\u5f0f\r\n\r\npublic\uff1a\u7c7b\u672c\u8eab\u3001\u6d3e\u751f\u7c7b\u548c\u5176\u5b83\u7c7b\u5747\u53ef\u8bbf\u95ee\uff1b\r\n\r\nprotected\uff1a\u7c7b\u672c\u8eab\u548c\u6d3e\u751f\u7c7b\u5747\u53ef\u8bbf\u95ee\uff0c\u5176\u5b83\u7c7b\u4e0d\u80fd\u8bbf\u95ee\uff1b\r\n\r\nprivate\uff08\u9ed8\u8ba4\uff09\uff1a\u7c7b\u672c\u8eab\u53ef\u8bbf\u95ee\uff0c\u6d3e\u751f\u7c7b\u548c\u5176\u5b83\u7c7b\u4e0d\u80fd\u8bbf\u95ee\u3002"},{"ID":"253","typeID":"12","question":"\u8f6f\u4ef6\u5f00\u53d1\u6d41\u7a0b","answer":"\u9700\u6c42\u5206\u6790\u548c\u9879\u76ee\u8ba1\u5212\uff1a\u53ef\u884c\u6027\u8ba1\u5212\uff0c\u9879\u76ee\u8ba1\u5212\uff0c\u9700\u6c42\u5206\u6790\uff0c\u6d4b\u8bd5\u8ba1\u5212\r\n\r\n\u8f6f\u4ef6\u8bbe\u8ba1\u8bf4\u660e\u4e66\uff1a\u529f\u80fd\u8bbe\u8ba1\u8bf4\u660e\u4e66\uff0c\u5b9e\u73b0\u8bbe\u8ba1\u8bf4\u660e\u4e66\r\n\r\n\u4f7f\u7528\u624b\u518c\r\n\r\n\u6d4b\u8bd5\u62a5\u544a\r\n\r\n\u9879\u76ee\u603b\u7ed3"},{"ID":"252","typeID":"12","question":"C++\u591a\u6001\u5b9e\u73b0\u673a\u5236","answer":"\u5728C++\u4e2d\uff0c\u5bf9\u4e8e\u6709virtual\u7684\u7c7b\uff0c\u5176sizeof\u4f1a\u6bd4\u6b63\u5e38\u60c5\u51b5\u591a\u59044\u4e2a\u5b57\u8282\u3002\u65e2\u5728\u7c7b\u7684\u6700\u5f00\u59cb\u56db\u4e2a\u5b57\u8282\uff0c\u653e\u7684\u662fVTABLE\u8868\u7684\u5730\u5740\uff08void *\u7c7b\u578b\uff09\u3002\u800c\u5728VTABLE\u4e2d\uff0c\u6240\u6709\u865a\u51fd\u6570\u662f\u4ee5\u6307\u9488\u6570\u7ec4\u7684\u5f62\u5f0f\u5b58\u653e\u3002 \u5bf9\u4e8e\u6d3e\u751f\u7684\u7c7b\uff0c\u5373\u65f6\u6ca1\u6709\u91cd\u8f7d\u57fa\u7c7b\u7684\u865a\u51fd\u6570\uff0c\u4e5f\u4f1a\u5728\u5176VTABLE\u5360\u7528\u4e00\u683c\u3002\u9020\u6210\u7a7a\u95f4\u4e0a\u7684\u6d6a\u8d39\u3002\u975e\u865a\u57fa\u7c7b\u6ca1\u6709VTABLE\uff0cVTABLE\u662f\u5728\u6784\u9020\u7684\u65f6\u5019\u7f16\u8bd1\u5668\u751f\u6210\u7684\u3002"},{"ID":"251","typeID":"12","question":"\u627e\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e2d\u6700\u5927\u516c\u5171\u5b50\u5b57\u7b26\u4e32,\u5982\"abccade\",\"dgcadde\"\u7684\u6700\u5927\u5b50\u4e32\u4e3a\"cad\" ","answer":"int GetCommon(char *s1, char *s2, char **r1, char **r2)\r\n{\r\nint len1 = strlen(s1);\r\nint len2 = strlen(s2);\r\nint maxlen = 0;\r\nfor(int i = 0; i < len1; i++)\r\n{\r\nfor(int j = 0; j < len2; j++)\r\n{\r\nif(s1[i] == s2[j])\r\n{\r\nint as = i, bs = j, count = 1;\r\nwhile(as + 1 < len1 && bs + 1 < len2 && s1[++as] == s2[++bs])\r\ncount++;\r\nif(count > maxlen)\r\n{\r\nmaxlen = count;\r\n*r1 = s1 + i;\r\n*r2 = s2 + j;\r\n}\r\n}\r\n}\r\n}\r\n"},{"ID":"243","typeID":"12","question":"\u8c08\u8c08\u4f60\u5bf9\u9762\u5411\u5bf9\u8c61\u7684\u8ba4\u8bc6","answer":"\u9762\u5411\u5bf9\u8c61\u53ef\u4ee5\u7406\u89e3\u6210\u5bf9\u5f85\u6bcf\u4e00\u4e2a\u95ee\u9898,\u90fd\u662f\u9996\u5148\u8981\u786e\u5b9a\u8fd9\u4e2a\u95ee\u9898\u7531\u51e0\u4e2a\u90e8\u5206\u7ec4\u6210,\u800c\u6bcf\u4e00\u4e2a\u90e8\u5206\u5176 \u5b9e\u5c31\u662f\u4e00\u4e2a\u5bf9\u8c61\u3002\u7136\u540e\u518d\u5206\u522b\u8bbe\u8ba1\u8fd9\u4e9b\u5bf9\u8c61,\u6700\u540e\u5f97\u5230\u6574\u4e2a\u7a0b\u5e8f\u3002\u4f20\u7edf\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u591a\u662f\u57fa\u4e8e\u529f\u80fd\u7684\u601d\u60f3 \u6765\u8fdb\u884c\u8003\u8651\u548c\u8bbe\u8ba1\u7684,\u800c\u9762\u5411\u5bf9\u8c61\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u5219\u662f\u57fa\u4e8e\u5bf9\u8c61\u7684\u89d2\u5ea6\u6765\u8003\u8651\u95ee\u9898\u3002\u8fd9\u6837\u505a\u80fd\u591f\u4f7f\u5f97\u7a0b\u5e8f\u66f4 \u52a0\u7684\u7b80\u6d01\u6e05\u6670\u3002\r\n\u8bf4\u660e:\u7f16\u7a0b\u4e2d\u63a5\u89e6\u6700\u591a\u7684\u201c\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u6280\u672f\u201d\u4ec5\u4ec5\u662f\u9762\u5411\u5bf9\u8c61\u6280\u672f\u4e2d\u7684\u4e00\u4e2a\u7ec4\u6210\u90e8\u5206\u3002\u53d1\u6325\u9762\u5411 \u5bf9\u8c61\u6280\u672f\u7684\u4f18\u52bf\u662f\u4e00\u4e2a\u7efc\u5408\u7684\u6280\u672f\u95ee\u9898,\u4e0d\u4ec5\u9700\u8981\u9762\u5411\u5bf9\u8c61\u7684\u5206\u6790,\u8bbe\u8ba1\u548c\u7f16\u7a0b\u6280\u672f,\u800c\u4e14\u9700\u8981\u501f\u52a9\u5fc5 \u8981\u7684\u5efa\u6a21\u548c\u5f00\u53d1\u5de5\u5177\u3002"},{"ID":"242","typeID":"12","question":"\u7528 C \u7f16\u5199\u4e00\u4e2a\u6b7b\u5faa\u73af\u7a0b\u5e8f","answer":"while(1)\r\n{}\r\n\u8bf4\u660e:\u5f88\u591a\u79cd\u9014\u5f84\u90fd\u53ef\u5b9e\u73b0\u540c\u4e00\u79cd\u529f\u80fd,\u4f46\u662f\u4e0d\u540c\u7684\u65b9\u6cd5\u65f6\u95f4\u548c\u7a7a\u95f4\u5360\u7528\u5ea6\u4e0d\u540c,\u7279\u522b\u662f\u5bf9\u4e8e\u5d4c\u5165\r\n\u5f0f\u8f6f\u4ef6,\u5904\u7406\u5668\u901f\u5ea6\u6bd4\u8f83\u6162,\u5b58\u50a8\u7a7a\u95f4\u8f83\u5c0f,\u6240\u4ee5\u65f6\u95f4\u548c\u7a7a\u95f4\u4f18\u52bf\u662f\u9009\u62e9\u5404\u79cd\u65b9\u6cd5\u7684\u9996\u8981\u8003\u8651\u6761\u4ef6\u3002"},{"ID":"241","typeID":"12","question":"\u7b80\u8ff0 strcpy\u3001sprintf \u4e0e memcpy \u7684\u533a\u522b","answer":"\u4e09\u8005\u4e3b\u8981\u6709\u4ee5\u4e0b\u4e0d\u540c\u4e4b\u5904:\r\n(1)\u64cd\u4f5c\u5bf9\u8c61\u4e0d\u540c,strcpy\u7684\u4e24\u4e2a\u64cd\u4f5c\u5bf9\u8c61\u5747\u4e3a\u5b57\u7b26\u4e32,sprintf\u7684\u64cd\u4f5c\u6e90\u5bf9\u8c61\u53ef\u4ee5\u662f\u591a\u79cd\u6570\u636e\u7c7b\u578b,\u76ee\u7684\u64cd\u4f5c\u5bf9\u8c61\u662f\u5b57\u7b26\u4e32,memcpy \u7684\u4e24\u4e2a\u5bf9\u8c61\u5c31\u662f\u4e24\u4e2a\u4efb\u610f\u53ef\u64cd\u4f5c\u7684\u5185\u5b58\u5730\u5740,\u5e76\u4e0d\u9650\u4e8e\u4f55\u79cd\u6570\u636e\u7c7b\u578b\u3002 (2)\u6267\u884c\u6548\u7387\u4e0d\u540c,memcpy \u6700\u9ad8,strcpy \u6b21\u4e4b,sprintf \u7684\u6548\u7387\u6700\u4f4e\u3002\r\n(3)\u5b9e\u73b0\u529f\u80fd\u4e0d\u540c,strcpy \u4e3b\u8981\u5b9e\u73b0\u5b57\u7b26\u4e32\u53d8\u91cf\u95f4\u7684\u62f7\u8d1d,sprintf \u4e3b\u8981\u5b9e\u73b0\u5176\u4ed6\u6570\u636e\u7c7b\u578b\u683c\u5f0f\u5230\u5b57\r\n\u7b26\u4e32\u7684\u8f6c\u5316,memcpy \u4e3b\u8981\u662f\u5185\u5b58\u5757\u95f4\u7684\u62f7\u8d1d\u3002\r\n\u8bf4\u660e:strcpy\u3001sprintf \u4e0e memcpy \u90fd\u53ef\u4ee5\u5b9e\u73b0\u62f7\u8d1d\u7684\u529f\u80fd,\u4f46\u662f\u9488\u5bf9\u7684\u5bf9\u8c61\u4e0d\u540c,\u6839\u636e\u5b9e\u9645\u9700\u6c42,\u6765\r\n\u9009\u62e9\u5408\u9002\u7684\u51fd\u6570\u5b9e\u73b0\u62f7\u8d1d\u529f\u80fd\u3002\r\n"},{"ID":"240","typeID":"12","question":"\u5e38\u5f15\u7528\u6709\u4ec0\u4e48\u4f5c\u7528","answer":"\u5e38\u5f15\u7528\u7684\u5f15\u5165\u4e3b\u8981\u662f\u4e3a\u4e86\u907f\u514d\u4f7f\u7528\u53d8\u91cf\u7684\u5f15\u7528\u65f6,\u5728\u4e0d\u77e5\u60c5\u7684\u60c5\u51b5\u4e0b\u6539\u53d8\u53d8\u91cf\u7684\u503c\u3002\u5e38\u5f15\u7528\u4e3b\u8981\u7528 \u4e8e\u5b9a\u4e49\u4e00\u4e2a\u666e\u901a\u53d8\u91cf\u7684\u53ea\u8bfb\u5c5e\u6027\u7684\u522b\u540d\u3001\u4f5c\u4e3a\u51fd\u6570\u7684\u4f20\u5165\u5f62\u53c2,\u907f\u514d\u5b9e\u53c2\u5728\u8c03\u7528\u51fd\u6570\u4e2d\u88ab\u610f\u5916\u7684\u6539\u53d8\u3002\r\n\u8bf4\u660e:\u5f88\u591a\u60c5\u51b5\u4e0b,\u9700\u8981\u7528\u5e38\u5f15\u7528\u505a\u5f62\u53c2,\u88ab\u5f15\u7528\u5bf9\u8c61\u7b49\u6548\u4e8e\u5e38\u5bf9\u8c61,\u4e0d\u80fd\u5728\u51fd\u6570\u4e2d\u6539\u53d8\u5b9e\u53c2\u7684\u503c, \u8fd9\u6837\u7684\u597d\u5904\u662f\u6709\u8f83\u9ad8\u7684\u6613\u8bfb\u6027\u548c\u8f83\u5c0f\u7684\u51fa\u9519\u7387\u3002"},{"ID":"239","typeID":"12","question":"\u5982\u4f55\u907f\u514d\u201c\u91ce\u6307\u9488\u201d","answer":"\u201c\u91ce\u6307\u9488\u201d\u4ea7\u751f\u539f\u56e0\u53ca\u89e3\u51b3\u529e\u6cd5\u5982\u4e0b:\r\n(1)\u6307\u9488\u53d8\u91cf\u58f0\u660e\u65f6\u6ca1\u6709\u88ab\u521d\u59cb\u5316\u3002\u89e3\u51b3\u529e\u6cd5:\u6307\u9488\u58f0\u660e\u65f6\u521d\u59cb\u5316,\u53ef\u4ee5\u662f\u5177\u4f53\u7684\u5730\u5740\u503c,\u4e5f\u53ef \u8ba9\u5b83\u6307\u5411 NULL\u3002\r\n(2)\u6307\u9488 p \u88ab free \u6216\u8005 delete \u4e4b\u540e,\u6ca1\u6709\u7f6e\u4e3a NULL\u3002\u89e3\u51b3\u529e\u6cd5:\u6307\u9488\u6307\u5411\u7684\u5185\u5b58\u7a7a\u95f4\u88ab\u91ca\u653e \u540e\u6307\u9488\u5e94\u8be5\u6307\u5411 NULL\u3002\r\n(3)\u6307\u9488\u64cd\u4f5c\u8d85\u8d8a\u4e86\u53d8\u91cf\u7684\u4f5c\u7528\u8303\u56f4\u3002\u89e3\u51b3\u529e\u6cd5:\u5728\u53d8\u91cf\u7684\u4f5c\u7528\u57df\u7ed3\u675f\u524d\u91ca\u653e\u6389\u53d8\u91cf\u7684\u5730\u5740\u7a7a\u95f4 \u5e76\u4e14\u8ba9\u6307\u9488\u6307\u5411 NULL\u3002\r\n\u6ce8\u610f:\u201c\u91ce\u6307\u9488\u201d\u7684\u89e3\u51b3\u65b9\u6cd5\u4e5f\u662f\u7f16\u7a0b\u89c4\u8303\u7684\u57fa\u672c\u539f\u5219,\u5e73\u65f6\u4f7f\u7528\u6307\u9488\u65f6\u4e00\u5b9a\u8981\u907f\u514d\u4ea7\u751f\u201c\u91ce\u6307\u9488\u201d, \u5728\u4f7f\u7528\u6307\u9488\u524d\u4e00\u5b9a\u8981\u68c0\u9a8c\u6307\u9488\u7684\u5408\u6cd5\u6027\u3002"},{"ID":"238","typeID":"12","question":"\u7b80\u8ff0\u6307\u9488\u5e38\u91cf\u4e0e\u5e38\u91cf\u6307\u9488\u533a\u522b\r\n","answer":"\u6307\u9488\u5e38\u91cf\u662f\u6307\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6307\u9488,\u8fd9\u4e2a\u6307\u9488\u7684\u503c\u53ea\u80fd\u5728\u5b9a\u4e49\u65f6\u521d\u59cb\u5316,\u5176\u4ed6\u5730\u65b9\u4e0d\u80fd\u6539\u53d8\u3002\u5e38\u91cf\u6307\u9488 \u662f\u6307\u5b9a\u4e49\u4e86\u4e00\u4e2a\u6307\u9488,\u8fd9\u4e2a\u6307\u9488\u6307\u5411\u4e00\u4e2a\u53ea\u8bfb\u7684\u5bf9\u8c61,\u4e0d\u80fd\u901a\u8fc7\u5e38\u91cf\u6307\u9488\u6765\u6539\u53d8\u8fd9\u4e2a\u5bf9\u8c61\u7684\u503c\u3002\r\n\u6307\u9488\u5e38\u91cf\u5f3a\u8c03\u7684\u662f\u6307\u9488\u7684\u4e0d\u53ef\u6539\u53d8\u6027,\u800c\u5e38\u91cf\u6307\u9488\u5f3a\u8c03\u7684\u662f\u6307\u9488\u5bf9\u5176\u6240\u6307\u5bf9\u8c61\u7684\u4e0d\u53ef\u6539\u53d8\u6027\u3002\r\n  \u6ce8\u610f:\u65e0\u8bba\u662f\u6307\u9488\u5e38\u91cf\u8fd8\u662f\u5e38\u91cf\u6307\u9488,\u5176\u6700\u5927\u7684\u7528\u9014\u5c31\u662f\u4f5c\u4e3a\u51fd\u6570\u7684\u5f62\u5f0f\u53c2\u6570,\u4fdd\u8bc1\u5b9e\u53c2\u5728\u88ab\u8c03\u7528\r\n\u51fd\u6570\u4e2d\u7684\u4e0d\u53ef\u6539\u53d8\u7279\u6027\u3002"},{"ID":"237","typeID":"12","question":"\u6d41\u64cd\u4f5c\u7b26\u91cd\u8f7d\u4e3a\u4ec0\u4e48\u8fd4\u56de\u5f15\u7528","answer":"\u5728\u7a0b\u5e8f\u4e2d,\u6d41\u64cd\u4f5c\u7b26>>\u548c<<\u7ecf\u5e38\u8fde\u7eed\u4f7f\u7528\u3002\u56e0\u6b64\u8fd9\u4e24\u4e2a\u64cd\u4f5c\u7b26\u7684\u8fd4\u56de\u503c\u5e94\u8be5\u662f\u4e00\u4e2a\u4ecd\u65e7\u652f\u6301\u8fd9\u4e24\u4e2a \u64cd\u4f5c\u7b26\u7684\u6d41\u5f15\u7528\u3002\u5176\u4ed6\u7684\u6570\u636e\u7c7b\u578b\u90fd\u65e0\u6cd5\u505a\u5230\u8fd9\u4e00\u70b9\u3002\r\n\u6ce8\u610f:\u9664\u4e86\u5728\u8d4b\u503c\u64cd\u4f5c\u7b26\u548c\u6d41\u64cd\u4f5c\u7b26\u4e4b\u5916\u7684\u5176\u4ed6\u7684\u4e00\u4e9b\u64cd\u4f5c\u7b26\u4e2d,\u5982+\u3001-\u3001*\u3001\/\u7b49\u5374\u5343\u4e07\u4e0d\u80fd\u8fd4\u56de \u5f15\u7528\u3002\u56e0\u4e3a\u8fd9\u56db\u4e2a\u64cd\u4f5c\u7b26\u7684\u5bf9\u8c61\u90fd\u662f\u53f3\u503c,\u56e0\u6b64,\u5b83\u4eec\u5fc5\u987b\u6784\u9020\u4e00\u4e2a\u5bf9\u8c61\u4f5c\u4e3a\u8fd4\u56de\u503c\u3002\r\n"},{"ID":"236","typeID":"12","question":"extern \u6709\u4ec0\u4e48\u4f5c\u7528","answer":"extern \u6807\u8bc6\u7684\u53d8\u91cf\u6216\u8005\u51fd\u6570\u58f0\u660e\u5176\u5b9a\u4e49\u5728\u522b\u7684\u6587\u4ef6\u4e2d,\u63d0\u793a\u7f16\u8bd1\u5668\u9047\u5230\u6b64\u53d8\u91cf\u548c\u51fd\u6570\u65f6\u5728\u5176\u5b83\u6a21\u5757\r\n\u4e2d\u5bfb\u627e\u5176\u5b9a\u4e49\u3002"},{"ID":"235","typeID":"12","question":"static \u6709\u4ec0\u4e48\u4f5c\u7528","answer":"static \u5728 C \u4e2d\u4e3b\u8981\u7528\u4e8e\u5b9a\u4e49\u5168\u5c40\u9759\u6001\u53d8\u91cf\u3001\u5b9a\u4e49\u5c40\u90e8\u9759\u6001\u53d8\u91cf\u3001\u5b9a\u4e49\u9759\u6001\u51fd\u6570\u3002\u5728 C++\u4e2d\u65b0\u589e\u4e86\u4e24 \u79cd\u4f5c\u7528:\u5b9a\u4e49\u9759\u6001\u6570\u636e\u6210\u5458\u3001\u9759\u6001\u51fd\u6570\u6210\u5458\u3002\r\n\u6ce8\u610f:\u56e0\u4e3a static \u5b9a\u4e49\u7684\u53d8\u91cf\u5206\u914d\u5728\u9759\u6001\u533a,\u6240\u4ee5\u5176\u5b9a\u4e49\u7684\u53d8\u91cf\u7684\u9ed8\u8ba4\u503c\u4e3a 0,\u666e\u901a\u53d8\u91cf\u7684\u9ed8\u8ba4\u503c \u4e3a\u968f\u673a\u6570,\u5728\u5b9a\u4e49\u6307\u9488\u53d8\u91cf\u65f6\u8981\u7279\u522b\u6ce8\u610f\u3002\r\n"},{"ID":"234","typeID":"12","question":"\u5173\u952e\u5b57 const \u662f\u4ec0\u4e48","answer":"const \u7528\u6765\u5b9a\u4e49\u4e00\u4e2a\u53ea\u8bfb\u7684\u53d8\u91cf\u6216\u5bf9\u8c61\u3002\u4e3b\u8981\u4f18\u70b9:\u4fbf\u4e8e\u7c7b\u578b\u68c0\u67e5\u3001\u540c\u5b8f\u5b9a\u4e49\u4e00\u6837\u53ef\u4ee5\u65b9\u4fbf\u5730\u8fdb\u884c \u53c2\u6570\u7684\u4fee\u6539\u548c\u8c03\u6574\u3001\u8282\u7701\u7a7a\u95f4,\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u5185\u5b58\u5206\u914d\u3001\u53ef\u4e3a\u51fd\u6570\u91cd\u8f7d\u63d0\u4f9b\u53c2\u8003\u3002\r\n\u8bf4\u660e:const \u4fee\u9970\u51fd\u6570\u53c2\u6570,\u662f\u4e00\u79cd\u7f16\u7a0b\u89c4\u8303\u7684\u8981\u6c42,\u4fbf\u4e8e\u9605\u8bfb,\u4e00\u770b\u5373\u77e5\u8fd9\u4e2a\u53c2\u6570\u4e0d\u80fd\u88ab\u6539\u53d8, \u5b9e\u73b0\u65f6\u4e0d\u6613\u51fa\u9519\u3002"},{"ID":"233","typeID":"12","question":"typedef \u548c define \u6709\u4ec0\u4e48\u533a\u522b","answer":"(1)\u7528\u6cd5\u4e0d\u540c:typedef \u7528\u6765\u5b9a\u4e49\u4e00\u79cd\u6570\u636e\u7c7b\u578b\u7684\u522b\u540d,\u589e\u5f3a\u7a0b\u5e8f\u7684\u53ef\u8bfb\u6027\u3002define \u4e3b\u8981\u7528\u6765\u5b9a\u4e49 \u5e38\u91cf,\u4ee5\u53ca\u4e66\u5199\u590d\u6742\u4f7f\u7528\u9891\u7e41\u7684\u5b8f\u3002\r\n(2)\u6267\u884c\u65f6\u95f4\u4e0d\u540c:typedef \u662f\u7f16\u8bd1\u8fc7\u7a0b\u7684\u4e00\u90e8\u5206,\u6709\u7c7b\u578b\u68c0\u67e5\u7684\u529f\u80fd\u3002define \u662f\u5b8f\u5b9a\u4e49,\u662f\u9884\u7f16 \u8bd1\u7684\u90e8\u5206,\u5176\u53d1\u751f\u5728\u7f16\u8bd1\u4e4b\u524d,\u53ea\u662f\u7b80\u5355\u7684\u8fdb\u884c\u5b57\u7b26\u4e32\u7684\u66ff\u6362,\u4e0d\u8fdb\u884c\u7c7b\u578b\u7684\u68c0\u67e5\u3002\r\n(3)\u4f5c\u7528\u57df\u4e0d\u540c:typedef \u6709\u4f5c\u7528\u57df\u9650\u5b9a\u3002define \u4e0d\u53d7\u4f5c\u7528\u57df\u7ea6\u675f,\u53ea\u8981\u662f\u5728 define \u58f0\u660e\u540e\u7684\u5f15\u7528 \u90fd\u662f\u6b63\u786e\u7684\u3002\r\n(4)\u5bf9\u6307\u9488\u7684\u64cd\u4f5c\u4e0d\u540c:typedef \u548c define \u5b9a\u4e49\u7684\u6307\u9488\u65f6\u6709\u5f88\u5927\u7684\u533a\u522b\u3002\r\n\u6ce8\u610f:typedef \u5b9a\u4e49\u662f\u8bed\u53e5,\u56e0\u4e3a\u53e5\u5c3e\u8981\u52a0\u4e0a\u5206\u53f7\u3002\u800c define \u4e0d\u662f\u8bed\u53e5,\u5343\u4e07\u4e0d\u80fd\u5728\u53e5\u5c3e\u52a0\u5206\u53f7\u3002"},{"ID":"232","typeID":"12","question":"\u5199\u4e00\u4e2a\u201c\u6807\u51c6\u201d\u5b8f MIN","answer":"\u5199\u4e00\u4e2a\u201c\u6807\u51c6\u201d\u5b8f MIN,\u8fd9\u4e2a\u5b8f\u8f93\u5165\u4e24\u4e2a\u53c2\u6570\u5e76\u4e14\u8fd4\u56de\u8f83\u5c0f\u7684\u4e00\u4e2a\u3002 \u3010\u7b54\u6848\u3011\r\n#define min(a,b)((a)<=(b)?(a):(b)) \u6ce8\u610f:\u5728\u8c03\u7528\u65f6\u4e00\u5b9a\u8981\u6ce8\u610f\u8fd9\u4e2a\u5b8f\u5b9a\u4e49\u7684\u526f\u4f5c\u7528,\u5982\u4e0b\u8c03\u7528: ((++*p)<=(x)?(++*p):(x)\u3002\r\np \u6307\u9488\u5c31\u81ea\u52a0\u4e86\u4e24\u6b21,\u8fdd\u80cc\u4e86 MIN \u7684\u672c\u610f\u3002"},{"ID":"231","typeID":"12","question":"C++\u7684\u5f15\u7528\u548c C \u8bed\u8a00\u7684\u6307\u9488\u6709\u4ec0\u4e48\u533a\u522b","answer":"\u6307\u9488\u548c\u5f15\u7528\u4e3b\u8981\u6709\u4ee5\u4e0b\u533a\u522b:\r\n(1)\u5f15\u7528\u5fc5\u987b\u88ab\u521d\u59cb\u5316,\u4f46\u662f\u4e0d\u5206\u914d\u5b58\u50a8\u7a7a\u95f4\u3002\u6307\u9488\u4e0d\u58f0\u660e\u65f6\u521d\u59cb\u5316,\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u9700\u8981\u5206\u914d \u5b58\u50a8\u7a7a\u95f4\u3002\r\n(2)\u5f15\u7528\u521d\u59cb\u5316\u4ee5\u540e\u4e0d\u80fd\u88ab\u6539\u53d8,\u6307\u9488\u53ef\u4ee5\u6539\u53d8\u6240\u6307\u7684\u5bf9\u8c61\u3002 (3)\u4e0d\u5b58\u5728\u6307\u5411\u7a7a\u503c\u7684\u5f15\u7528,\u4f46\u662f\u5b58\u5728\u6307\u5411\u7a7a\u503c\u7684\u6307\u9488\u3002 \u6ce8\u610f:\u5f15\u7528\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u65f6,\u4f1a\u5f15\u53d1\u4e00\u5b9a\u7684\u95ee\u9898,\u56e0\u4e3a\u8ba9\u5f15\u7528\u4f5c\u53c2\u6570,\u76ee\u7684\u5c31\u662f\u60f3\u6539\u53d8\u8fd9\u4e2a\u5f15\u7528\u6240\r\n\u6307\u5411\u5730\u5740\u7684\u5185\u5bb9,\u800c\u51fd\u6570\u8c03\u7528\u65f6\u4f20\u5165\u7684\u662f\u5b9e\u53c2,\u770b\u4e0d\u51fa\u51fd\u6570\u7684\u53c2\u6570\u662f\u6b63\u5e38\u53d8\u91cf,\u8fd8\u662f\u5f15\u7528,\u56e0\u6b64\u53ef\u80fd\u4f1a\r\n\u5f15\u53d1\u9519\u8bef\u3002\u6240\u4ee5\u4f7f\u7528\u65f6\u4e00\u5b9a\u8981\u5c0f\u5fc3\u8c28\u614e\u3002\r\n"},{"ID":"230","typeID":"12","question":"&&\u548c&\u3001||\u548c|\u6709\u4ec0\u4e48\u533a\u522b","answer":"(1)&\u548c|\u5bf9\u64cd\u4f5c\u6570\u8fdb\u884c\u6c42\u503c\u8fd0\u7b97,&&\u548c||\u53ea\u662f\u5224\u65ad\u903b\u8f91\u5173\u7cfb\u3002 18\r\n\ufffc\ufffc(2)&&\u548c||\u5728\u5728\u5224\u65ad\u5de6\u4fa7\u64cd\u4f5c\u6570\u5c31\u80fd\u786e\u5b9a\u7ed3\u679c\u7684\u60c5\u51b5\u4e0b\u5c31\u4e0d\u518d\u5bf9\u53f3\u4fa7\u64cd\u4f5c\u6570\u6c42\u503c\u3002\r\n\u6ce8\u610f:\u5728\u7f16\u7a0b\u7684\u65f6\u5019\u6709\u4e9b\u65f6\u5019\u5c06&&\u6216||\u66ff\u6362\u6210&\u6216|\u6ca1\u6709\u51fa\u9519,\u4f46\u662f\u5176\u903b\u8f91\u662f\u9519\u8bef\u7684,\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e0d \u53ef\u9884\u60f3\u7684\u540e\u679c(\u6bd4\u5982\u5f53\u4e24\u4e2a\u64cd\u4f5c\u6570\u4e00\u4e2a\u662f 1 \u53e6\u4e00\u4e2a\u662f 2 \u65f6)\u3002"},{"ID":"229","typeID":"12","question":"short i = 0; i = i + 1L;\u8fd9\u4e24\u53e5\u6709\u9519\u5417","answer":"\u4ee3\u7801\u4e00\u662f\u9519\u7684,\u4ee3\u7801\u4e8c\u662f\u6b63\u786e\u7684\u3002\r\n\u8bf4\u660e:\u5728\u6570\u636e\u5b89\u5168\u7684\u60c5\u51b5\u4e0b\u5927\u7c7b\u578b\u7684\u6570\u636e\u5411\u5c0f\u7c7b\u578b\u7684\u6570\u636e\u8f6c\u6362\u4e00\u5b9a\u8981\u663e\u793a\u7684\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u3002"},{"ID":"228","typeID":"12","question":"\u8c08\u8c08\u4f60\u5bf9\u7f16\u7a0b\u89c4\u8303\u7684\u7406\u89e3\u6216\u8ba4\u8bc6","answer":"\u7f16\u7a0b\u89c4\u8303\u53ef\u603b\u7ed3\u4e3a:\u7a0b\u5e8f\u7684\u53ef\u884c\u6027,\u53ef\u8bfb\u6027\u3001\u53ef\u79fb\u690d\u6027\u4ee5\u53ca\u53ef\u6d4b\u8bd5\u6027\u3002\r\n\u8bf4\u660e:\u8fd9\u662f\u7f16\u7a0b\u89c4\u8303\u7684\u603b\u7eb2\u76ee,\u9762\u8bd5\u8005\u4e0d\u4e00\u5b9a\u8981\u53bb\u80cc\u8bf5\u4e0a\u9762\u7ed9\u51fa\u7684\u90a3\u51e0\u4e2a\u4f8b\u5b50,\u5e94\u8be5\u53bb\u7406\u89e3\u8fd9\u51e0\u4e2a \u4f8b\u5b50\u8bf4\u660e\u7684\u95ee\u9898,\u60f3\u4e00\u60f3,\u81ea\u5df1\u5982\u4f55\u89e3\u51b3\u53ef\u884c\u6027\u3001\u53ef\u8bfb\u6027\u3001\u53ef\u79fb\u690d\u6027\u4ee5\u53ca\u53ef\u6d4b\u8bd5\u6027\u8fd9\u51e0\u4e2a\u95ee\u9898,\u7ed3\u5408\u4ee5 \u4e0a\u51e0\u4e2a\u4f8b\u5b50\u548c\u81ea\u5df1\u5e73\u65f6\u7684\u7f16\u7a0b\u4e60\u60ef\u6765\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u3002"},{"ID":"227","typeID":"12","question":"\u7f16\u7801\u5b9e\u73b0\u5192\u6ce1\u6392\u5e8f","answer":"\u5192\u6ce1\u6392\u5e8f\u7f16\u7a0b\u5b9e\u73b0\u5982\u4e0b:\r\n#include <stdio.h>\r\n#define LEN 10 \/\/\u6570\u7ec4\u957f\u5ea6\r\nvoid main( void ) {\r\nintARRAY[10]={0,6,3,2,7,5,4,9,1,8}; \/\/\u5f85\u6392\u5e8f\u6570\u7ec4 printf( \"\n\" );\r\nfor( int a = 0; a < LEN; a++ ) {\r\nprintf( \"%d \", ARRAY[a] ); }\r\nint i = 0;\r\nint j = 0;\r\nbool isChange;\r\n\/\/\u6253\u5370\u6570\u7ec4\u5185\u5bb9\r\n\/\/\u8bbe\u5b9a\u4ea4\u6362\u6807\u5fd7\r\nfor( i = 1; i < LEN; i++ ) {\r\nisChange = 0;\r\nfor( j = LEN-1; j >= i; j-- ) {\r\nif( ARRAY[j+1] < ARRAY[j] ) {\r\nARRAY[0] = ARRAY[j+1];\r\n\/\/\u6700\u591a\u505a LEN-1 \u8d9f\u6392\u5e8f \/\/\u672c\u8d9f\u6392\u5e8f\u5f00\u59cb\u524d,\u4ea4\u6362\u6807\u5fd7\u5e94\u4e3a\u5047 \/\/\u5bf9\u5f53\u524d\u65e0\u5e8f\u533a ARRAY[i..LEN]\u81ea\u4e0b\u5411\u4e0a\u626b\u63cf\r\n\/\/\u4ea4\u6362\u8bb0\u5f55 \/\/ARRAY[0]\u4e0d\u662f\u54e8\u5175,\u4ec5\u505a\u6682\u5b58\u5355\u5143\r\n} }\r\nARRAY[j+1] = ARRAY[j]; ARRAY[j] = ARRAY[0]; isChange = 1;\r\n\/\/\u53d1\u751f\u4e86\u4ea4\u6362,\u6545\u5c06\u4ea4\u6362\u6807\u5fd7\u7f6e\u4e3a\u771f\r\n\/\/\u6253\u5370\u672c\u6b21\u6392\u5e8f\u540e\u6570\u7ec4\u5185\u5bb9\r\n\/\/\u672c\u8d9f\u6392\u5e8f\u672a\u53d1\u751f\u4ea4\u6362,\u63d0\u524d\u7ec8\u6b62\u7b97\u6cd5\r\nprintf( \"\n\" );\r\nfor( a = 0; a < LEN; a++)\r\n{\r\nprintf( \"%d \", ARRAY[a] );\r\n}\r\nif( !isChange )\r\n{\r\nbreak;\r\n} }\r\nprintf( \"\n\" );\r\nreturn; }"},{"ID":"226","typeID":"12","question":"\u7f16\u7801\u5b9e\u73b0\u76f4\u63a5\u63d2\u5165\u6392\u5e8f","answer":"\u76f4\u63a5\u63d2\u5165\u6392\u5e8f\u7f16\u7a0b\u5b9e\u73b0\u5982\u4e0b:\r\n#include<iostream.h> void main( void )\r\n{\r\nint ARRAY[10] = { 0, 6, 3, 2, 7, 5, 4, 9, 1, 8 };\r\nint i,j;\r\nfor( i=0;i<10;i++) {\r\ncout<<ARRAY[i]<<\" \"; }\r\ncout<<endl;\r\nfor( i = 2; i <= 10; i++ ) {\r\nif(ARRAY[i] < ARRAY[i-1]) {\r\n\/\/\u5c06 ARRAY[2],...,ARRAY[n]\u4f9d\u6b21\u6309\u5e8f\u63d2\u5165\r\n\/\/\u5982\u679c ARRAY[i]\u5927\u4e8e\u4e00\u5207\u6709\u5e8f\u7684\u6570\u503c, \/\/ARRAY[i]\u5c06\u4fdd\u6301\u539f\u4f4d\u4e0d\u52a8\r\nARRAY[0] = ARRAY[i]; j = i - 1;\r\ndo{\r\n\/\/\u5c06 ARRAY[0]\u770b\u505a\u662f\u54e8\u5175,\u662f ARRAY[i]\u7684\u526f\u672c\r\n\/\/\u4ece\u53f3\u5411\u5de6\u5728\u6709\u5e8f\u533a ARRAY[1..i-1]\u4e2d \/\/\u67e5\u627e ARRAY[i]\u7684\u63d2\u5165\u4f4d\u7f6e \/\/\u5c06\u6570\u503c\u5927\u4e8e ARRAY[i]\u8bb0\u5f55\u540e\u79fb\r\nARRAY[j+1] = ARRAY[j];\r\nj-- ;\r\n}while( ARRAY[0] < ARRAY[j] );\r\nARRAY[j+1]=ARRAY[0]; \/\/ARRAY[i]\u63d2\u5165\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\r\n} }\r\nfor( i=0;i<10;i++)\r\n{\r\ncout<<ARRAY[i]<<\" \";\r\n}\r\ncout<<endl; }\r\n\u6ce8\u610f:\u6240\u6709\u4e3a\u7b80\u5316\u8fb9\u754c\u6761\u4ef6\u800c\u5f15\u5165\u7684\u9644\u52a0\u7ed3\u70b9(\u5143\u7d20)\u5747\u53ef\u79f0\u4e3a\u54e8\u5175\u3002\u5f15\u5165\u54e8\u5175\u540e\u4f7f\u5f97\u67e5\u627e\u5faa\u73af\u6761 \u4ef6\u7684\u65f6\u95f4\u5927\u7ea6\u51cf\u5c11\u4e86\u4e00\u534a,\u5bf9\u4e8e\u8bb0\u5f55\u6570\u8f83\u5927\u7684\u6587\u4ef6\u8282\u7ea6\u7684\u65f6\u95f4\u5c31\u76f8\u5f53\u53ef\u89c2\u3002\u7c7b\u4f3c\u4e8e\u6392\u5e8f\u8fd9\u6837\u4f7f\u7528\u9891\u7387\u975e \u5e38\u9ad8\u7684\u7b97\u6cd5,\u8981\u5c3d\u53ef\u80fd\u5730\u51cf\u5c11\u5176\u8fd0\u884c\u65f6\u95f4\u3002\u6240\u4ee5\u4e0d\u80fd\u628a\u4e0a\u8ff0\u7b97\u6cd5\u4e2d\u7684\u54e8\u5175\u89c6\u4e3a\u96d5\u866b\u5c0f\u6280\u3002\r\n"},{"ID":"225","typeID":"12","question":"\u8ba1\u7b97\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u6df1\u5ea6","answer":"\u6df1\u5ea6\u7684\u8ba1\u7b97\u51fd\u6570:\r\n\r\n\ufffcint depth(BiTree T) {\r\nif(!T) return 0; \/\/\u5224\u65ad\u5f53\u524d\u7ed3\u70b9\u662f\u5426\u4e3a\u53f6\u5b50\u7ed3\u70b9\r\n\ufffc\ufffc\r\nint d1= depth(T->lchild); \/\/\u6c42\u5f53\u524d\u7ed3\u70b9\u7684\u5de6\u5b69\u5b50\u6811\u7684\u6df1\u5ea6 int d2= depth(T->rchild); \/\/\u6c42\u5f53\u524d\u7ed3\u70b9\u7684\u53f3\u5b69\u5b50\u6811\u7684\u6df1\u5ea6 return (d1>d2?d1:d2)+1;\r\n}\r\n\u6ce8\u610f:\u6839\u636e\u4e8c\u53c9\u6811\u7684\u7ed3\u6784\u7279\u70b9,\u5f88\u591a\u7b97\u6cd5\u90fd\u53ef\u4ee5\u7528\u9012\u5f52\u7b97\u6cd5\u6765\u5b9e\u73b0\u3002\r\n"},{"ID":"224","typeID":"12","question":"\u7b80\u8ff0\u961f\u5217\u548c\u6808\u7684\u5f02\u540c","answer":"\u961f\u5217\u548c\u6808\u90fd\u662f\u7ebf\u6027\u5b58\u50a8\u7ed3\u6784,\u4f46\u662f\u4e24\u8005\u7684\u63d2\u5165\u548c\u5220\u9664\u6570\u636e\u7684\u64cd\u4f5c\u4e0d\u540c,\u961f\u5217\u662f\u201c\u5148\u8fdb\u5148\u51fa\u201d,\u6808\u662f \u201c\u540e\u8fdb\u5148\u51fa\u201d\u3002\r\n\u6ce8\u610f:\u533a\u522b\u6808\u533a\u548c\u5806\u533a\u3002\u5806\u533a\u7684\u5b58\u53d6\u662f\u201c\u987a\u5e8f\u968f\u610f\u201d,\u800c\u6808\u533a\u662f\u201c\u540e\u8fdb\u5148\u51fa\u201d\u3002\u6808\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u5206 \u914d\u91ca\u653e ,\u5b58\u653e\u51fd\u6570\u7684\u53c2\u6570\u503c,\u5c40\u90e8\u53d8\u91cf\u7684\u503c\u7b49\u3002\u5176\u64cd\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\u4e8e\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u6808\u3002\u5806\u4e00\u822c\u7531\u7a0b\u5e8f\u5458 \u5206\u914d\u91ca\u653e, \u82e5\u7a0b\u5e8f\u5458\u4e0d\u91ca\u653e,\u7a0b\u5e8f\u7ed3\u675f\u65f6\u53ef\u80fd\u7531 OS \u56de\u6536\u3002\u5206\u914d\u65b9\u5f0f\u7c7b\u4f3c\u4e8e\u94fe\u8868\u3002\r\n\u5b83\u4e0e\u672c\u9898\u4e2d\u7684\u5806\u548c\u6808\u662f\u4e24\u56de\u4e8b\u3002\u5806\u6808\u53ea\u662f\u4e00\u79cd\u6570\u636e\u7ed3\u6784,\u800c\u5806\u533a\u548c\u6808\u533a\u662f\u7a0b\u5e8f\u7684\u4e0d\u540c\u5185\u5b58\u5b58\u50a8\u533a\u57df\u3002\r\n"},{"ID":"223","typeID":"12","question":"\u600e\u6837\u628a\u4e00\u4e2a\u5355\u94fe\u8868\u53cd\u5e8f","answer":"(1)\u53cd\u8f6c\u4e00\u4e2a\u94fe\u8868\u3002\u5faa\u73af\u7b97\u6cd5\u3002\r\nList reverse(List n) {\r\nif(!n) {\r\nreturn n; }\r\nlist cur = n.next; list pre = n;\r\nlist tmp;\r\n\/\/\u5224\u65ad\u94fe\u8868\u662f\u5426\u4e3a\u7a7a,\u4e3a\u7a7a\u5373\u9000\u51fa\u3002\r\n\/\/\u4fdd\u5b58\u5934\u7ed3\u70b9\u7684\u4e0b\u4e2a\u7ed3\u70b9 \/\/\u4fdd\u5b58\u5934\u7ed3\u70b9\r\n\ufffc\ufffc\r\npre.next = null;\r\nwhile ( NULL != cur.next ) {\r\ntmp = cur; tmp.next = pre pre = tmp;\r\ncur = cur.next;\r\n\/\/\u5934\u7ed3\u70b9\u7684\u6307\u9488\u6307\u7a7a,\u8f6c\u6362\u540e\u53d8\u5c3e\u7ed3\u70b9 \/\/\u5faa\u73af\u76f4\u5230 cur.next \u4e3a\u7a7a\r\n\/\/\u5b9e\u73b0\u5982\u56fe 10.3\u2014\u56fe 10.5 \u6240\u793a\r\n}\r\nreturn tmp; \/\/f \u8fd4\u56de\u5934\u6307\u9488\r\n}\r\n(2)\u53cd\u8f6c\u4e00\u4e2a\u94fe\u8868\u3002\u9012\u5f52\u7b97\u6cd5\u3002\r\nList *reverse( List *oldList, List *newHead = NULL ) {\r\nList *next = oldList-> next; oldList-> next = newHead; newHead = oldList;\r\n\/\/\u8bb0\u5f55\u4e0a\u6b21\u7ffb\u8f6c\u540e\u7684\u94fe\u8868 \/\/\u5c06\u5f53\u524d\u7ed3\u70b9\u63d2\u5165\u5230\u7ffb\u8f6c\u540e\u94fe\u8868\u7684\u5f00\u5934 \/\/\u9012\u5f52\u5904\u7406\u5269\u4f59\u7684\u94fe\u8868\r\nreturn ( next==NULL )? newHead: reverse( t, newHead ); \r\n}\r\n\u8bf4\u660e:\u5faa\u73af\u7b97\u6cd5\u5c31\u662f\u56fe 10.2\u2014\u56fe 10.5 \u7684\u79fb\u52a8\u8fc7\u7a0b,\u6bd4\u8f83\u597d\u7406\u89e3\u548c\u60f3\u5230\u3002\u9012\u5f52\u7b97\u6cd5\u7684\u8bbe\u8ba1\u867d\u6709\u4e00\u70b9\u96be \u5ea6,\u4f46\u662f\u7406\u89e3\u4e86\u5faa\u73af\u7b97\u6cd5,\u518d\u8bbe\u8ba1\u9012\u5f52\u7b97\u6cd5\u5c31\u7b80\u5355\u591a\u4e86\u3002"},{"ID":"222","typeID":"12","question":"\u94fe\u8868\u548c\u6570\u7ec4\u6709\u4ec0\u4e48\u533a\u522b","answer":"\u6570\u7ec4\u548c\u94fe\u8868\u6709\u4ee5\u4e0b\u51e0\u70b9\u4e0d\u540c:\r\n(1)\u5b58\u50a8\u5f62\u5f0f:\u6570\u7ec4\u662f\u4e00\u5757\u8fde\u7eed\u7684\u7a7a\u95f4,\u58f0\u660e\u65f6\u5c31\u8981\u786e\u5b9a\u957f\u5ea6\u3002\u94fe\u8868\u662f\u4e00\u5757\u53ef\u4e0d\u8fde\u7eed\u7684\u52a8\u6001\u7a7a\u95f4, \u957f\u5ea6\u53ef\u53d8,\u6bcf\u4e2a\u7ed3\u70b9\u8981\u4fdd\u5b58\u76f8\u90bb\u7ed3\u70b9\u6307\u9488\u3002\r\n(2)\u6570\u636e\u67e5\u627e:\u6570\u7ec4\u7684\u7ebf\u6027\u67e5\u627e\u901f\u5ea6\u5feb,\u67e5\u627e\u64cd\u4f5c\u76f4\u63a5\u4f7f\u7528\u504f\u79fb\u5730\u5740\u3002\u94fe\u8868\u9700\u8981\u6309\u987a\u5e8f\u68c0\u7d22\u7ed3\u70b9, \u6548\u7387\u4f4e\u3002\r\n(3)\u6570\u636e\u63d2\u5165\u6216\u5220\u9664:\u94fe\u8868\u53ef\u4ee5\u5feb\u901f\u63d2\u5165\u548c\u5220\u9664\u7ed3\u70b9,\u800c\u6570\u7ec4\u5219\u53ef\u80fd\u9700\u8981\u5927\u91cf\u6570\u636e\u79fb\u52a8\u3002 (4)\u8d8a\u754c\u95ee\u9898:\u94fe\u8868\u4e0d\u5b58\u5728\u8d8a\u754c\u95ee\u9898,\u6570\u7ec4\u6709\u8d8a\u754c\u95ee\u9898\u3002 \u8bf4\u660e:\u5728\u9009\u62e9\u6570\u7ec4\u6216\u94fe\u8868\u6570\u636e\u7ed3\u6784\u65f6,\u4e00\u5b9a\u8981\u6839\u636e\u5b9e\u9645\u9700\u8981\u8fdb\u884c\u9009\u62e9\u3002\u6570\u7ec4\u4fbf\u4e8e\u67e5\u8be2,\u94fe\u8868\u4fbf\u4e8e\u63d2\r\n\u5165\u5220\u9664\u3002\u6570\u7ec4\u8282\u7701\u7a7a\u95f4\u4f46\u662f\u957f\u5ea6\u56fa\u5b9a,\u94fe\u8868\u867d\u7136\u53d8\u957f\u4f46\u662f\u5360\u4e86\u66f4\u591a\u7684\u5b58\u50a8\u7a7a\u95f4\u3002"},{"ID":"221","typeID":"12","question":"\u7b80\u8ff0\u591a\u6001\u5b9e\u73b0\u7684\u539f\u7406","answer":"\u7f16\u8bd1\u5668\u53d1\u73b0\u4e00\u4e2a\u7c7b\u4e2d\u6709\u865a\u51fd\u6570,\u4fbf\u4f1a\u7acb\u5373\u4e3a\u6b64\u7c7b\u751f\u6210\u865a\u51fd\u6570\u8868 vtable\u3002\u865a\u51fd\u6570\u8868\u7684\u5404\u8868\u9879\u4e3a\u6307\u5411\u5bf9 \u5e94\u865a\u51fd\u6570\u7684\u6307\u9488\u3002\u7f16\u8bd1\u5668\u8fd8\u4f1a\u5728\u6b64\u7c7b\u4e2d\u9690\u542b\u63d2\u5165\u4e00\u4e2a\u6307\u9488 vptr(\u5bf9 vc \u7f16\u8bd1\u5668\u6765\u8bf4,\u5b83\u63d2\u5728\u7c7b\u7684\u7b2c\u4e00\u4e2a\u4f4d \u7f6e\u4e0a)\u6307\u5411\u865a\u51fd\u6570\u8868\u3002\u8c03\u7528\u6b64\u7c7b\u7684\u6784\u9020\u51fd\u6570\u65f6,\u5728\u7c7b\u7684\u6784\u9020\u51fd\u6570\u4e2d,\u7f16\u8bd1\u5668\u4f1a\u9690\u542b\u6267\u884c vptr \u4e0e vtable \u7684 \u5173\u8054\u4ee3\u7801,\u5c06 vptr \u6307\u5411\u5bf9\u5e94\u7684 vtable,\u5c06\u7c7b\u4e0e\u6b64\u7c7b\u7684 vtable \u8054\u7cfb\u4e86\u8d77\u6765\u3002\u53e6\u5916\u5728\u8c03\u7528\u7c7b\u7684\u6784\u9020\u51fd\u6570\u65f6, \u6307\u5411\u57fa\u7840\u7c7b\u7684\u6307\u9488\u6b64\u65f6\u5df2\u7ecf\u53d8\u6210\u6307\u5411\u5177\u4f53\u7684\u7c7b\u7684 this \u6307\u9488,\u8fd9\u6837\u4f9d\u9760\u6b64 this \u6307\u9488\u5373\u53ef\u5f97\u5230\u6b63\u786e\u7684 vtable,\u3002 \u5982\u6b64\u624d\u80fd\u771f\u6b63\u4e0e\u51fd\u6570\u4f53\u8fdb\u884c\u8fde\u63a5,\u8fd9\u5c31\u662f\u52a8\u6001\u8054\u7f16,\u5b9e\u73b0\u591a\u6001\u7684\u57fa\u672c\u539f\u7406\u3002\r\n\u6ce8\u610f:\u4e00\u5b9a\u8981\u533a\u5206\u865a\u51fd\u6570,\u7eaf\u865a\u51fd\u6570\u3001\u865a\u62df\u7ee7\u627f\u7684\u5173\u7cfb\u548c\u533a\u522b\u3002\u7262\u8bb0\u865a\u51fd\u6570\u5b9e\u73b0\u539f\u7406,\u56e0\u4e3a\u591a\u6001 C++\u9762\u8bd5\u7684\u91cd\u8981\u8003\u70b9\u4e4b\u4e00,\u800c\u865a\u51fd\u6570\u662f\u5b9e\u73b0\u591a\u6001\u7684\u57fa\u7840\u3002\r\n"},{"ID":"220","typeID":"12","question":"\u7b80\u8ff0\u7c7b\u6210\u5458\u51fd\u6570\u7684\u91cd\u5199\u3001\u91cd\u8f7d\u548c\u9690\u85cf\u7684\u533a\u522b","answer":"(1)\u91cd\u5199\u548c\u91cd\u8f7d\u4e3b\u8981\u6709\u4ee5\u4e0b\u51e0\u70b9\u4e0d\u540c\u3002\r\n\uf071 \u8303\u56f4\u7684\u533a\u522b:\u88ab\u91cd\u5199\u7684\u548c\u91cd\u5199\u7684\u51fd\u6570\u5728\u4e24\u4e2a\u7c7b\u4e2d,\u800c\u91cd\u8f7d\u548c\u88ab\u91cd\u8f7d\u7684\u51fd\u6570\u5728\u540c\u4e00\u4e2a\u7c7b\u4e2d\u3002\r\n\uf071 \u53c2\u6570\u7684\u533a\u522b:\u88ab\u91cd\u5199\u51fd\u6570\u548c\u91cd\u5199\u51fd\u6570\u7684\u53c2\u6570\u5217\u8868\u4e00\u5b9a\u76f8\u540c,\u800c\u88ab\u91cd\u8f7d\u51fd\u6570\u548c\u91cd\u8f7d\u51fd\u6570\u7684\u53c2\u6570\u5217\u8868\u4e00\r\n\u5b9a\u4e0d\u540c\u3002\r\n\uf071 virtual \u7684\u533a\u522b:\u91cd\u5199\u7684\u57fa\u7c7b\u4e2d\u88ab\u91cd\u5199\u7684\u51fd\u6570\u5fc5\u987b\u8981\u6709 virtual \u4fee\u9970,\u800c\u91cd\u8f7d\u51fd\u6570\u548c\u88ab\u91cd\u8f7d\u51fd\u6570\u53ef\u4ee5\u88ab\r\n6\r\n\ufffcB::g A::f B::h\r\n\ufffc\ufffcvirtual \u4fee\u9970,\u4e5f\u53ef\u4ee5\u6ca1\u6709\u3002\r\n(2)\u9690\u85cf\u548c\u91cd\u5199\u3001\u91cd\u8f7d\u6709\u4ee5\u4e0b\u51e0\u70b9\u4e0d\u540c\u3002\r\n\uf071 \u4e0e\u91cd\u8f7d\u7684\u8303\u56f4\u4e0d\u540c:\u548c\u91cd\u5199\u4e00\u6837,\u9690\u85cf\u51fd\u6570\u548c\u88ab\u9690\u85cf\u51fd\u6570\u4e0d\u5728\u540c\u4e00\u4e2a\u7c7b\u4e2d\u3002\r\n\uf071 \u53c2\u6570\u7684\u533a\u522b:\u9690\u85cf\u51fd\u6570\u548c\u88ab\u9690\u85cf\u7684\u51fd\u6570\u7684\u53c2\u6570\u5217\u8868\u53ef\u4ee5\u76f8\u540c,\u4e5f\u53ef\u4e0d\u540c,\u4f46\u662f\u51fd\u6570\u540d\u80af\u5b9a\u8981\u76f8\u540c\u3002\r\n\u5f53\u53c2\u6570\u4e0d\u76f8\u540c\u65f6,\u65e0\u8bba\u57fa\u7c7b\u4e2d\u7684\u53c2\u6570\u662f\u5426\u88ab virtual \u4fee\u9970,\u57fa\u7c7b\u7684\u51fd\u6570\u90fd\u662f\u88ab\u9690\u85cf,\u800c\u4e0d\u662f\u88ab\u91cd\u5199\u3002\r\n\u8bf4\u660e:\u867d\u7136\u91cd\u8f7d\u548c\u8986\u76d6\u90fd\u662f\u5b9e\u73b0\u591a\u6001\u7684\u57fa\u7840,\u4f46\u662f\u4e24\u8005\u5b9e\u73b0\u7684\u6280\u672f\u5b8c\u5168\u4e0d\u76f8\u540c,\u8fbe\u5230\u7684\u76ee\u7684\u4e5f\u662f\u5b8c \u5168\u4e0d\u540c\u7684,\u8986\u76d6\u662f\u52a8\u6001\u6001\u7ed1\u5b9a\u7684\u591a\u6001,\u800c\u91cd\u8f7d\u662f\u9759\u6001\u7ed1\u5b9a\u7684\u591a\u6001\u3002\r\n"},{"ID":"219","typeID":"12","question":"\u8bbf\u95ee\u57fa\u7c7b\u7684\u79c1\u6709\u865a\u51fd\u6570","answer":"\u5199\u51fa\u4ee5\u4e0b\u7a0b\u5e8f\u7684\u8f93\u51fa\u7ed3\u679c:\r\n\ufffc#include <iostream.h> class A\r\n5\r\n\ufffc\ufffc\r\n{\r\nvirtual void g()\r\n{\r\ncout << \"A::g\" << endl;\r\n} private:\r\nvirtual void f() {\r\ncout << \"A::f\" << endl; }\r\n};\r\nclass B : public A {\r\nvoid g() {\r\ncout << \"B::g\" << endl; }\r\nvirtual void h() {\r\ncout << \"B::h\" << endl; }\r\n};\r\ntypedef void( *Fun )( void ); void main()\r\n{\r\nB b;\r\nFun pFun;\r\nfor(int i = 0 ; i < 3; i++) {\r\npFun = ( Fun )*( ( int* ) * ( int* )( &b ) + i );\r\npFun(); }\r\n}\r\n\u8f93\u51fa\u7ed3\u679c:\r\n\u6ce8\u610f:\u672c\u9898\u4e3b\u8981\u8003\u5bdf\u4e86\u9762\u8bd5\u8005\u5bf9\u865a\u51fd\u6570\u7684\u7406\u89e3\u7a0b\u5ea6\u3002\u4e00\u4e2a\u5bf9\u865a\u51fd\u6570\u4e0d\u4e86\u89e3\u7684\u4eba\u5f88\u96be\u6b63\u786e\u7684\u505a\u51fa\u672c\u9898\u3002 \u5728\u5b66\u4e60\u9762\u5411\u5bf9\u8c61\u7684\u591a\u6001\u6027\u65f6\u4e00\u5b9a\u8981\u6df1\u523b\u7406\u89e3\u865a\u51fd\u6570\u8868\u7684\u5de5\u4f5c\u539f\u7406\u3002"},{"ID":"217","typeID":"12","question":"\u8c08\u8c08\u4f60\u5bf9\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u8ba4\u8bc6","answer":"\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u6709\u4ee5\u4e0b\u4e24\u4e2a\u4e0d\u540c\u4e4b\u5904: (1)\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u751f\u6210\u65b0\u7684\u7c7b\u5bf9\u8c61,\u800c\u8d4b\u503c\u8fd0\u7b97\u7b26\u4e0d\u80fd\u3002 (2)\u7531\u4e8e\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u662f\u76f4\u63a5\u6784\u9020\u4e00\u4e2a\u65b0\u7684\u7c7b\u5bf9\u8c61,\u6240\u4ee5\u5728\u521d\u59cb\u5316\u8fd9\u4e2a\u5bf9\u8c61\u4e4b\u524d\u4e0d\u7528\u68c0\u9a8c\u6e90\u5bf9\u8c61\r\n\u662f\u5426\u548c\u65b0\u5efa\u5bf9\u8c61\u76f8\u540c\u3002\u800c\u8d4b\u503c\u8fd0\u7b97\u7b26\u5219\u9700\u8981\u8fd9\u4e2a\u64cd\u4f5c,\u53e6\u5916\u8d4b\u503c\u8fd0\u7b97\u4e2d\u5982\u679c\u539f\u6765\u7684\u5bf9\u8c61\u4e2d\u6709\u5185\u5b58\u5206\u914d\u8981 \u5148\u628a\u5185\u5b58\u91ca\u653e\u6389\r\n  \u6ce8\u610f:\u5f53\u6709\u7c7b\u4e2d\u6709\u6307\u9488\u7c7b\u578b\u7684\u6210\u5458\u53d8\u91cf\u65f6,\u4e00\u5b9a\u8981\u91cd\u5199\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u8fd0\u7b97\u7b26,\u4e0d\u8981\u4f7f\u7528\u9ed8\u8ba4\r\n\u7684\u3002"},{"ID":"216","typeID":"12","question":"C++\u7684\u7a7a\u7c7b\u6709\u54ea\u4e9b\u6210\u5458\u51fd\u6570","answer":"\u7f3a\u7701\u6784\u9020\u51fd\u6570\u3002\r\n\uf071 \u7f3a\u7701\u62f7\u8d1d\u6784\u9020\u51fd\u6570\u3002\r\n\uf071 \u7f3a\u7701\u6790\u6784\u51fd\u6570\u3002\r\n\uf071 \u7f3a\u7701\u8d4b\u503c\u8fd0\u7b97\u7b26\u3002\r\n\uf071 \u7f3a\u7701\u53d6\u5740\u8fd0\u7b97\u7b26\u3002\r\n\uf071 \u7f3a\u7701\u53d6\u5740\u8fd0\u7b97\u7b26 const\u3002\r\n\u6ce8\u610f:\u6709\u4e9b\u4e66\u4e0a\u53ea\u662f\u7b80\u5355\u7684\u4ecb\u7ecd\u4e86\u524d\u56db\u4e2a\u51fd\u6570\u3002\u6ca1\u6709\u63d0\u53ca\u540e\u9762\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002\u4f46\u540e\u9762\u8fd9\u4e24\u4e2a\u51fd\u6570\u4e5f\u662f \u7a7a\u7c7b\u7684\u9ed8\u8ba4\u51fd\u6570\u3002\u53e6\u5916\u9700\u8981\u6ce8\u610f\u7684\u662f,\u53ea\u6709\u5f53\u5b9e\u9645\u4f7f\u7528\u8fd9\u4e9b\u51fd\u6570\u7684\u65f6\u5019,\u7f16\u8bd1\u5668\u624d\u4f1a\u53bb\u5b9a\u4e49\u5b83\u4eec\u3002\r\n"},{"ID":"215","typeID":"12","question":"\u9762\u5411\u5bf9\u8c61\u7684\u4e09\u5927\u7279\u5f81","answer":"\u9762\u5411\u5bf9\u8c61\u7684\u4e09\u5927\u7279\u5f81\u662f\u5c01\u88c5\u6027\u3001\u7ee7\u627f\u6027\u548c\u591a\u6001\u6027:\r\n\uf071 \u5c01\u88c5\u6027:\u5c06\u5ba2\u89c2\u4e8b\u7269\u62bd\u8c61\u6210\u7c7b,\u6bcf\u4e2a\u7c7b\u5bf9\u81ea\u8eab\u7684\u6570\u636e\u548c\u65b9\u6cd5\u5b9e\u884c protection(private, protected,\r\npublic)\u3002\r\n\uf071 \u7ee7\u627f\u6027:\u5e7f\u4e49\u7684\u7ee7\u627f\u6709\u4e09\u79cd\u5b9e\u73b0\u5f62\u5f0f:\u5b9e\u73b0\u7ee7\u627f(\u4f7f\u7528\u57fa\u7c7b\u7684\u5c5e\u6027\u548c\u65b9\u6cd5\u800c\u65e0\u9700\u989d\u5916\u7f16\u7801\u7684\u80fd\u529b)\u3001\u53ef\r\n\u89c6\u7ee7\u627f(\u5b50\u7a97\u4f53\u4f7f\u7528\u7236\u7a97\u4f53\u7684\u5916\u89c2\u548c\u5b9e\u73b0\u4ee3\u7801)\u3001\u63a5\u53e3\u7ee7\u627f(\u4ec5\u4f7f\u7528\u5c5e\u6027\u548c\u65b9\u6cd5,\u5b9e\u73b0\u6ede\u540e\u5230\u5b50\u7c7b\u5b9e\u73b0)\u3002\r\n\uf071 \u591a\u6001\u6027:\u662f\u5c06\u7236\u7c7b\u5bf9\u8c61\u8bbe\u7f6e\u6210\u4e3a\u548c\u4e00\u4e2a\u6216\u66f4\u591a\u5b83\u7684\u5b50\u5bf9\u8c61\u76f8\u7b49\u7684\u6280\u672f\u3002\u7528\u5b50\u7c7b\u5bf9\u8c61\u7ed9\u7236\u7c7b\u5bf9\u8c61\u8d4b\u503c\r\n\u4e4b\u540e,\u7236\u7c7b\u5bf9\u8c61\u5c31\u53ef\u4ee5\u6839\u636e\u5f53\u524d\u8d4b\u503c\u7ed9\u5b83\u7684\u5b50\u5bf9\u8c61\u7684\u7279\u6027\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u8fd0\u4f5c\u3002\r\n\u8bf4\u660e:\u9762\u5411\u5bf9\u8c61\u7684\u4e09\u4e2a\u7279\u5f81\u662f\u5b9e\u73b0\u9762\u5411\u5bf9\u8c61\u6280\u672f\u7684\u5173\u952e,\u6bcf\u4e00\u4e2a\u7279\u5f81\u7684\u76f8\u5173\u6280\u672f\u90fd\u975e\u5e38\u7684\u590d\u6742,\u7a0b \u5e8f\u5458\u5e94\u8be5\u591a\u770b\u3001\u591a\u7ec3\u3002"},{"ID":"214","typeID":"12","question":"\u8bbe\u7f6e\u5730\u5740\u4e3a 0x67a9 \u7684\u6574\u578b\u53d8\u91cf\u7684\u503c\u4e3a 0xaa66","answer":"\r\n\u8bf4\u660e:\u8fd9\u9053\u9898\u5c31\u662f\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u7684\u5178\u578b\u4f8b\u5b50,\u65e0\u8bba\u5728\u4ec0\u4e48\u5e73\u53f0\u5730\u5740\u957f\u5ea6\u548c\u6574\u578b\u6570\u636e\u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684, \u5373\u4e00\u4e2a\u6574\u578b\u6570\u636e\u53ef\u4ee5\u5f3a\u5236\u8f6c\u6362\u6210\u5730\u5740\u6307\u9488\u7c7b\u578b,\u53ea\u8981\u6709\u610f\u4e49\u5373\u53ef\u3002"},{"ID":"213","typeID":"12","question":"\u7b80\u8ff0 strcpy\u3001sprintf \u4e0e memcpy \u7684\u533a\u522b","answer":"\u4e09\u8005\u4e3b\u8981\u6709\u4ee5\u4e0b\u4e0d\u540c\u4e4b\u5904:\r\n(1)\u64cd\u4f5c\u5bf9\u8c61\u4e0d\u540c,strcpy\u7684\u4e24\u4e2a\u64cd\u4f5c\u5bf9\u8c61\u5747\u4e3a\u5b57\u7b26\u4e32,sprintf\u7684\u64cd\u4f5c\u6e90\u5bf9\u8c61\u53ef\u4ee5\u662f\u591a\u79cd\u6570\u636e\u7c7b\u578b, \u76ee\u7684\u64cd\u4f5c\u5bf9\u8c61\u662f\u5b57\u7b26\u4e32,memcpy \u7684\u4e24\u4e2a\u5bf9\u8c61\u5c31\u662f\u4e24\u4e2a\u4efb\u610f\u53ef\u64cd\u4f5c\u7684\u5185\u5b58\u5730\u5740,\u5e76\u4e0d\u9650\u4e8e\u4f55\u79cd\u6570\u636e\u7c7b\u578b\u3002\r\n(2)\u6267\u884c\u6548\u7387\u4e0d\u540c,memcpy \u6700\u9ad8,strcpy \u6b21\u4e4b,sprintf \u7684\u6548\u7387\u6700\u4f4e\u3002\r\n(3)\u5b9e\u73b0\u529f\u80fd\u4e0d\u540c,strcpy \u4e3b\u8981\u5b9e\u73b0\u5b57\u7b26\u4e32\u53d8\u91cf\u95f4\u7684\u62f7\u8d1d,sprintf \u4e3b\u8981\u5b9e\u73b0\u5176\u4ed6\u6570\u636e\u7c7b\u578b\u683c\u5f0f\u5230\u5b57 \u7b26\u4e32\u7684\u8f6c\u5316,memcpy \u4e3b\u8981\u662f\u5185\u5b58\u5757\u95f4\u7684\u62f7\u8d1d\u3002\r\n\u8bf4\u660e:strcpy\u3001sprintf \u4e0e memcpy \u90fd\u53ef\u4ee5\u5b9e\u73b0\u62f7\u8d1d\u7684\u529f\u80fd,\u4f46\u662f\u9488\u5bf9\u7684\u5bf9\u8c61\u4e0d\u540c,\u6839\u636e\u5b9e\u9645\u9700\u6c42,\u6765 \u9009\u62e9\u5408\u9002\u7684\u51fd\u6570\u5b9e\u73b0\u62f7\u8d1d\u529f\u80fd\u3002"},{"ID":"212","typeID":"12","question":"\u7b80\u8ff0 C\u3001C++\u7a0b\u5e8f\u7f16\u8bd1\u7684\u5185\u5b58\u5206\u914d\u60c5\u51b5","answer":"C\u3001C++\u4e2d\u5185\u5b58\u5206\u914d\u65b9\u5f0f\u53ef\u4ee5\u5206\u4e3a\u4e09\u79cd:\r\n(1)\u4ece\u9759\u6001\u5b58\u50a8\u533a\u57df\u5206\u914d: \u5185\u5b58\u5728\u7a0b\u5e8f\u7f16\u8bd1\u65f6\u5c31\u5df2\u7ecf\u5206\u914d\u597d,\u8fd9\u5757\u5185\u5b58\u5728\u7a0b\u5e8f\u7684\u6574\u4e2a\u8fd0\u884c\u671f\u95f4\u90fd\u5b58\u5728\u3002\u901f\u5ea6\u5feb\u3001\u4e0d\u5bb9\u6613\u51fa\u9519,\r\n\u56e0\u4e3a\u6709\u7cfb\u7edf\u4f1a\u5584\u540e\u3002\u4f8b\u5982\u5168\u5c40\u53d8\u91cf,static \u53d8\u91cf\u7b49\u3002\r\n(2)\u5728\u6808\u4e0a\u5206\u914d: \u5728\u6267\u884c\u51fd\u6570\u65f6,\u51fd\u6570\u5185\u5c40\u90e8\u53d8\u91cf\u7684\u5b58\u50a8\u5355\u5143\u90fd\u5728\u6808\u4e0a\u521b\u5efa,\u51fd\u6570\u6267\u884c\u7ed3\u675f\u65f6\u8fd9\u4e9b\u5b58\u50a8\u5355\u5143\u81ea\u52a8\u88ab\u91ca\r\n\u653e\u3002\u6808\u5185\u5b58\u5206\u914d\u8fd0\u7b97\u5185\u7f6e\u4e8e\u5904\u7406\u5668\u7684\u6307\u4ee4\u96c6\u4e2d,\u6548\u7387\u5f88\u9ad8,\u4f46\u662f\u5206\u914d\u7684\u5185\u5b58\u5bb9\u91cf\u6709\u9650\u3002 (3)\u4ece\u5806\u4e0a\u5206\u914d:\r\n\u5373\u52a8\u6001\u5185\u5b58\u5206\u914d\u3002\u7a0b\u5e8f\u5728\u8fd0\u884c\u7684\u65f6\u5019\u7528 malloc \u6216 new \u7533\u8bf7\u4efb\u610f\u5927\u5c0f\u7684\u5185\u5b58,\u7a0b\u5e8f\u5458\u81ea\u5df1\u8d1f\u8d23\u5728\u4f55\r\n\u65f6\u7528 free \u6216 delete \u91ca\u653e\u5185\u5b58\u3002\u52a8\u6001\u5185\u5b58\u7684\u751f\u5b58\u671f\u7531\u7a0b\u5e8f\u5458\u51b3\u5b9a,\u4f7f\u7528\u975e\u5e38\u7075\u6d3b\u3002\u5982\u679c\u5728\u5806\u4e0a\u5206\u914d\u4e86\u7a7a\u95f4, \u5c31\u6709\u8d23\u4efb\u56de\u6536\u5b83,\u5426\u5219\u8fd0\u884c\u7684\u7a0b\u5e8f\u4f1a\u51fa\u73b0\u5185\u5b58\u6cc4\u6f0f,\u53e6\u5916\u9891\u7e41\u5730\u5206\u914d\u548c\u91ca\u653e\u4e0d\u540c\u5927\u5c0f\u7684\u5806\u7a7a\u95f4\u5c06\u4f1a\u4ea7\u751f \u5806\u5185\u788e\u5757\u3002\r\n\u4e00\u4e2a C\u3001C++\u7a0b\u5e8f\u7f16\u8bd1\u65f6\u5185\u5b58\u5206\u4e3a 5 \u5927\u5b58\u50a8\u533a:\u5806\u533a\u3001\u6808\u533a\u3001\u5168\u5c40\u533a\u3001\u6587\u5b57\u5e38\u91cf\u533a\u3001\u7a0b\u5e8f\u4ee3\u7801\u533a\u3002\r\n"},{"ID":"211","typeID":"12","question":"a \u548c&a \u6709\u4ec0\u4e48\u533a\u522b","answer":"\u8bf7\u5199\u51fa\u4ee5\u4e0b\u4ee3\u7801\u7684\u6253\u5370\u7ed3\u679c,\u4e3b\u8981\u76ee\u7684\u662f\u8003\u5bdf a \u548c&a \u7684\u533a\u522b\u3002\r\n#include<stdio.h> void main( void ) {\r\nint a[5]={1,2,3,4,5}; int *ptr=(int *)(&a+1);\r\nprintf(\"%d,%d\",*(a+1),*(ptr-1));\r\nreturn; }\r\n\u8f93\u51fa\u7ed3\u679c:2,5\u3002\r\n\u6ce8\u610f:\u6570\u7ec4\u540d a \u53ef\u4ee5\u4f5c\u6570\u7ec4\u7684\u9996\u5730\u5740,\u800c&a \u662f\u6570\u7ec4\u7684\u6307\u9488\u3002\u601d\u8003,\u5c06\u539f\u5f0f\u7684 int *ptr=(int *)(&a+1); \u6539\u4e3a int *ptr=(int *)(a+1);\u65f6\u8f93\u51fa\u7ed3\u679c\u5c06\u662f\u4ec0\u4e48\u5462?"},{"ID":"210","typeID":"12","question":"\u4e00\u4e2a\u6307\u9488\u53ef\u4ee5\u662f volatile \u5417","answer":"\u53ef\u4ee5,\u56e0\u4e3a\u6307\u9488\u548c\u666e\u901a\u53d8\u91cf\u4e00\u6837,\u6709\u65f6\u4e5f\u6709\u53d8\u5316\u7a0b\u5e8f\u7684\u4e0d\u53ef\u63a7\u6027\u3002\u5e38\u89c1\u4f8b:\u5b50\u4e2d\u65ad\u670d\u52a1\u5b50\u7a0b\u5e8f\u4fee\u6539 \u4e00\u4e2a\u6307\u5411\u4e00\u4e2a buffer \u7684\u6307\u9488\u65f6,\u5fc5\u987b\u7528 volatile \u6765\u4fee\u9970\u8fd9\u4e2a\u6307\u9488\u3002\r\n\u8bf4\u660e:\u6307\u9488\u662f\u4e00\u79cd\u666e\u901a\u7684\u53d8\u91cf,\u4ece\u8bbf\u95ee\u4e0a\u6ca1\u6709\u4ec0\u4e48\u4e0d\u540c\u4e8e\u5176\u4ed6\u53d8\u91cf\u7684\u7279\u6027\u3002\u5176\u4fdd\u5b58\u7684\u6570\u503c\u662f\u4e2a\u6574\u578b \u6570\u636e,\u548c\u6574\u578b\u53d8\u91cf\u4e0d\u540c\u7684\u662f,\u8fd9\u4e2a\u6574\u578b\u6570\u636e\u6307\u5411\u7684\u662f\u4e00\u6bb5\u5185\u5b58\u5730\u5740\u3002\r\n"},{"ID":"209","typeID":"12","question":"\u5199\u4e00\u4e2a\u201c\u6807\u51c6\u201d\u5b8f MIN","answer":"#define min(a,b)((a)<=(b)?(a):(b))\r\n\u6ce8\u610f:\u5728\u8c03\u7528\u65f6\u4e00\u5b9a\u8981\u6ce8\u610f\u8fd9\u4e2a\u5b8f\u5b9a\u4e49\u7684\u526f\u4f5c\u7528,\u5982\u4e0b\u8c03\u7528:\r\n((++*p)<=(x)?(++*p):(x)\u3002\r\np \u6307\u9488\u5c31\u81ea\u52a0\u4e86\u4e24\u6b21,\u8fdd\u80cc\u4e86 MIN \u7684\u672c\u610f\u3002"},{"ID":"208","typeID":"12","question":"C\u4e2d\u7684 malloc \u548cC++\u4e2d\u7684 new \u6709\u4ec0\u4e48\u533a\u522b","answer":"malloc \u548c new \u6709\u4ee5\u4e0b\u4e0d\u540c:\r\n(1)new\u3001delete \u662f\u64cd\u4f5c\u7b26,\u53ef\u4ee5\u91cd\u8f7d,\u53ea\u80fd\u5728 C++\u4e2d\u4f7f\u7528\u3002\r\n(2)malloc\u3001free \u662f\u51fd\u6570,\u53ef\u4ee5\u8986\u76d6,C\u3001C++\u4e2d\u90fd\u53ef\u4ee5\u4f7f\u7528\u3002\r\n(3)new \u53ef\u4ee5\u8c03\u7528\u5bf9\u8c61\u7684\u6784\u9020\u51fd\u6570,\u5bf9\u5e94\u7684 delete \u8c03\u7528\u76f8\u5e94\u7684\u6790\u6784\u51fd\u6570\u3002\r\n(4)malloc \u4ec5\u4ec5\u5206\u914d\u5185\u5b58,free \u4ec5\u4ec5\u56de\u6536\u5185\u5b58,\u5e76\u4e0d\u6267\u884c\u6784\u9020\u548c\u6790\u6784\u51fd\u6570\r\n(5)new\u3001delete \u8fd4\u56de\u7684\u662f\u67d0\u79cd\u6570\u636e\u7c7b\u578b\u6307\u9488,malloc\u3001free \u8fd4\u56de\u7684\u662f void \u6307\u9488\u3002\r\n\u6ce8\u610f:malloc \u7533\u8bf7\u7684\u5185\u5b58\u7a7a\u95f4\u8981\u7528 free \u91ca\u653e,\u800c new \u7533\u8bf7\u7684\u5185\u5b58\u7a7a\u95f4\u8981\u7528 delete \u91ca\u653e,\u4e0d\u8981\u6df7\u7528\u3002\r\n\u56e0\u4e3a\u4e24\u8005\u5b9e\u73b0\u7684\u673a\u7406\u4e0d\u540c\u3002"},{"ID":"207","typeID":"12","question":"C \u8bed\u8a00\u7684\u5173\u952e\u5b57 static \u548c C++ \u7684\u5173\u952e\u5b57 static \u6709\u4ec0\u4e48\u533a\u522b","answer":"\u5728 C \u4e2d static \u7528\u6765\u4fee\u9970\u5c40\u90e8\u9759\u6001\u53d8\u91cf\u548c\u5916\u90e8\u9759\u6001\u53d8\u91cf\u3001\u51fd\u6570\u3002\u800c C++\u4e2d\u9664\u4e86\u4e0a\u8ff0\u529f\u80fd\u5916,\u8fd8\u7528\u6765\u5b9a \u4e49\u7c7b\u7684\u6210\u5458\u53d8\u91cf\u548c\u51fd\u6570\u3002\u5373\u9759\u6001\u6210\u5458\u548c\u9759\u6001\u6210\u5458\u51fd\u6570\u3002\r\n\u6ce8\u610f:\u7f16\u7a0b\u65f6 static \u7684\u8bb0\u5fc6\u6027,\u548c\u5168\u5c40\u6027\u7684\u7279\u70b9\u53ef\u4ee5\u8ba9\u5728\u4e0d\u540c\u65f6\u671f\u8c03\u7528\u7684\u51fd\u6570\u8fdb\u884c\u901a\u4fe1,\u4f20\u9012\u4fe1\u606f, \u800c C++\u7684\u9759\u6001\u6210\u5458\u5219\u53ef\u4ee5\u5728\u591a\u4e2a\u5bf9\u8c61\u5b9e\u4f8b\u95f4\u8fdb\u884c\u901a\u4fe1,\u4f20\u9012\u4fe1\u606f\u3002"},{"ID":"206","typeID":"12","question":"sizeof \u548c strlen \u7684\u533a\u522b","answer":"sizeof \u548c strlen \u6709\u4ee5\u4e0b\u533a\u522b:\r\n\uf071 sizeof \u662f\u4e00\u4e2a\u64cd\u4f5c\u7b26,strlen \u662f\u5e93\u51fd\u6570\u3002\r\n\uf071 sizeof \u7684\u53c2\u6570\u53ef\u4ee5\u662f\u6570\u636e\u7684\u7c7b\u578b,\u4e5f\u53ef\u4ee5\u662f\u53d8\u91cf,\u800c strlen \u53ea\u80fd\u4ee5\u7ed3\u5c3e\u4e3a\u2018\u0000\u2018\u7684\u5b57\u7b26\u4e32\u4f5c\u53c2\u6570\u3002\r\n\uf071 \u7f16\u8bd1\u5668\u5728\u7f16\u8bd1\u65f6\u5c31\u8ba1\u7b97\u51fa\u4e86 sizeof \u7684\u7ed3\u679c\u3002\u800c strlen \u51fd\u6570\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u624d\u80fd\u8ba1\u7b97\u51fa\u6765\u3002\u5e76\u4e14 sizeof\r\n\u8ba1\u7b97\u7684\u662f\u6570\u636e\u7c7b\u578b\u5360\u5185\u5b58\u7684\u5927\u5c0f,\u800c strlen \u8ba1\u7b97\u7684\u662f\u5b57\u7b26\u4e32\u5b9e\u9645\u7684\u957f\u5ea6\u3002\r\n\uf071 \u6570\u7ec4\u505a sizeof \u7684\u53c2\u6570\u4e0d\u9000\u5316,\u4f20\u9012\u7ed9 strlen \u5c31\u9000\u5316\u4e3a\u6307\u9488\u4e86\u3002\r\n\u6ce8\u610f:\u6709\u4e9b\u662f\u64cd\u4f5c\u7b26\u770b\u8d77\u6765\u50cf\u662f\u51fd\u6570,\u800c\u6709\u4e9b\u51fd\u6570\u540d\u770b\u8d77\u6765\u53c8\u50cf\u64cd\u4f5c\u7b26,\u8fd9\u7c7b\u5bb9\u6613\u6df7\u6dc6\u7684\u540d\u79f0\u4e00\u5b9a \u8981\u52a0\u4ee5\u533a\u5206,\u5426\u5219\u9047\u5230\u6570\u7ec4\u540d\u8fd9\u7c7b\u7279\u6b8a\u6570\u636e\u7c7b\u578b\u4f5c\u53c2\u6570\u65f6\u5c31\u5f88\u5bb9\u6613\u51fa\u9519\u3002\u6700\u5bb9\u6613\u6df7\u6dc6\u4e3a\u51fd\u6570\u7684\u64cd\u4f5c\u7b26\u5c31 \u662f sizeof\u3002"},{"ID":"205","typeID":"12","question":"\u5199\u51fa bool \u3001int\u3001 float\u3001\u6307\u9488\u53d8\u91cf\u4e0e\u201c\u96f6\u503c\u201d\u6bd4\u8f83\u7684 if \u8bed\u53e5","answer":"bool \u578b\u6570\u636e:\r\nint \u578b\u6570\u636e:\r\n\u6307\u9488\u578b\u6570:\r\nfloat \u578b\u6570\u636e:\r\nif( flag )\r\n{\r\nA;\r\n} else {\r\nB; }\r\nif( 0 != flag )\r\n{\r\nA;\r\n} else {\r\nB; }\r\nif( NULL == flag ) {\r\nA; }\r\nelse\r\n{\r\nB;\r\n}\r\nif ( ( flag >= NORM ) && ( flag <= NORM ) ) {\r\nA;\r\n\ufffc\ufffc\r\n}\r\n\u6ce8\u610f:\u5e94\u7279\u522b\u6ce8\u610f\u5728 int\u3001\u6307\u9488\u578b\u53d8\u91cf\u548c\u201c\u96f6\u503c\u201d\u6bd4\u8f83\u7684\u65f6\u5019,\u628a\u201c\u96f6\u503c\u201d\u653e\u5728\u5de6\u8fb9,\u8fd9\u6837\u5f53\u628a\u201c==\u201d \u8bef\u5199\u6210\u201c=\u201d\u65f6,\u7f16\u8bd1\u5668\u53ef\u4ee5\u62a5\u9519,\u5426\u5219\u8fd9\u79cd\u903b\u8f91\u9519\u8bef\u4e0d\u5bb9\u6613\u53d1\u73b0,\u5e76\u4e14\u53ef\u80fd\u5bfc\u81f4\u5f88\u4e25\u91cd\u7684\u540e\u679c\u3002"},{"ID":"204","typeID":"12","question":"\u53d8\u91cf\u7684\u58f0\u660e\u548c\u5b9a\u4e49\u6709\u4ec0\u4e48\u533a\u522b\uff1f","answer":"\u4e3a\u53d8\u91cf\u5206\u914d\u5730\u5740\u548c\u5b58\u50a8\u7a7a\u95f4\u7684\u79f0\u4e3a\u5b9a\u4e49,\u4e0d\u5206\u914d\u5730\u5740\u7684\u79f0\u4e3a\u58f0\u660e\u3002\u4e00\u4e2a\u53d8\u91cf\u53ef\u4ee5\u5728\u591a\u4e2a\u5730\u65b9\u58f0\u660e, \u4f46\u662f\u53ea\u5728\u4e00\u4e2a\u5730\u65b9\u5b9a\u4e49\u3002\u52a0\u5165 extern \u4fee\u9970\u7684\u662f\u53d8\u91cf\u7684\u58f0\u660e,\u8bf4\u660e\u6b64\u53d8\u91cf\u5c06\u5728\u6587\u4ef6\u4ee5\u5916\u6216\u5728\u6587\u4ef6\u540e\u9762\u90e8\u5206 \u5b9a\u4e49\u3002\r\n\u8bf4\u660e:\u5f88\u591a\u65f6\u5019\u4e00\u4e2a\u53d8\u91cf,\u53ea\u662f\u58f0\u660e\u4e0d\u5206\u914d\u5185\u5b58\u7a7a\u95f4,\u76f4\u5230\u5177\u4f53\u4f7f\u7528\u65f6\u624d\u521d\u59cb\u5316,\u5206\u914d\u5185\u5b58\u7a7a\u95f4, \u5982\u5916\u90e8\u53d8\u91cf\u3002"},{"ID":"24","typeID":"12","question":"\u5982\u4f55\u6253\u5370\u51fa\u5f53\u524d\u6e90\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u4ee5\u53ca\u6e90\u6587\u4ef6\u7684\u5f53\u524d\u884c\u53f7\uff1f","answer":"cout << __FILE__ ;\r\ncout<<__LINE__ ;\r\n__FILE__\u548c__LINE__\u662f\u7cfb\u7edf\u9884\u5b9a\u4e49\u5b8f\uff0c\u8fd9\u79cd\u5b8f\u5e76\u4e0d\u662f\u5728\u67d0\u4e2a\u6587\u4ef6\u4e2d\u5b9a\u4e49\u7684\uff0c\u800c\u662f\u7531\u7f16\u8bd1\u5668\u5b9a\u4e49\u7684\u3002"},{"ID":"23","typeID":"12","question":"\u7c7b\u6210\u5458\u51fd\u6570\u7684\u91cd\u8f7d\u3001\u8986\u76d6\u548c\u9690\u85cf\u533a\u522b\uff1f","answer":"a.\u6210\u5458\u51fd\u6570\u88ab\u91cd\u8f7d\u7684\u7279\u5f81\uff1a\r\n\uff081\uff09\u76f8\u540c\u7684\u8303\u56f4\uff08\u5728\u540c\u4e00\u4e2a\u7c7b\u4e2d\uff09\uff1b\r\n\uff082\uff09\u51fd\u6570\u540d\u5b57\u76f8\u540c\uff1b\r\n\uff083\uff09\u53c2\u6570\u4e0d\u540c\uff1b\r\n\uff084\uff09virtual \u5173\u952e\u5b57\u53ef\u6709\u53ef\u65e0\u3002\r\nb.\u8986\u76d6\u662f\u6307\u6d3e\u751f\u7c7b\u51fd\u6570\u8986\u76d6\u57fa\u7c7b\u51fd\u6570\uff0c\u7279\u5f81\u662f\uff1a\r\n\uff081\uff09\u4e0d\u540c\u7684\u8303\u56f4\uff08\u5206\u522b\u4f4d\u4e8e\u6d3e\u751f\u7c7b\u4e0e\u57fa\u7c7b\uff09\uff1b\r\n\uff082\uff09\u51fd\u6570\u540d\u5b57\u76f8\u540c\uff1b\r\n\uff083\uff09\u53c2\u6570\u76f8\u540c\uff1b\r\n\uff084\uff09\u57fa\u7c7b\u51fd\u6570\u5fc5\u987b\u6709virtual \u5173\u952e\u5b57\u3002\r\nc.\u201c\u9690\u85cf\u201d\u662f\u6307\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u5c4f\u853d\u4e86\u4e0e\u5176\u540c\u540d\u7684\u57fa\u7c7b\u51fd\u6570\uff0c\u89c4\u5219\u5982\u4e0b\uff1a\r\n\uff081\uff09\u5982\u679c\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u4e0e\u57fa\u7c7b\u7684\u51fd\u6570\u540c\u540d\uff0c\u4f46\u662f\u53c2\u6570\u4e0d\u540c\u3002\u6b64\u65f6\uff0c\u4e0d\u8bba\u6709\u65e0virtual\u5173\u952e\u5b57\uff0c\u57fa\u7c7b\u7684\u51fd\u6570\u5c06\u88ab\u9690\u85cf\uff08\u6ce8\u610f\u522b\u4e0e\u91cd\u8f7d\u6df7\u6dc6\uff09\u3002\r\n\uff082\uff09\u5982\u679c\u6d3e\u751f\u7c7b\u7684\u51fd\u6570\u4e0e\u57fa\u7c7b\u7684\u51fd\u6570\u540c\u540d\uff0c\u5e76\u4e14\u53c2\u6570\u4e5f\u76f8\u540c\uff0c\u4f46\u662f\u57fa\u7c7b\u51fd\u6570\u6ca1\u6709virtual \u5173\u952e\u5b57\u3002\u6b64\u65f6\uff0c\u57fa\u7c7b\u7684\u51fd\u6570\u88ab\u9690\u85cf\uff08\u6ce8\u610f\u522b\u4e0e\u8986\u76d6\u6df7\u6dc6\uff09"},{"ID":"22","typeID":"12","question":"\u8bf7\u8bf4\u51faconst\u4e0e#define \u76f8\u6bd4\uff0c\u6709\u4f55\u4f18\u70b9\uff1f","answer":"1\uff09 const \u5e38\u91cf\u6709\u6570\u636e\u7c7b\u578b\uff0c\u800c\u5b8f\u5e38\u91cf\u6ca1\u6709\u6570\u636e\u7c7b\u578b\u3002\u7f16\u8bd1\u5668\u53ef\u4ee5\u5bf9\u524d\u8005\u8fdb\u884c\u7c7b\u578b\u5b89\u5168\u68c0\u67e5\u3002\u800c\u5bf9\u540e\u8005\u53ea\u8fdb\u884c\u5b57\u7b26\u66ff\u6362\uff0c\u6ca1\u6709\u7c7b\u578b\u5b89\u5168\u68c0\u67e5\uff0c\u5e76\u4e14\u5728\u5b57\u7b26\u66ff\u6362\u53ef\u80fd\u4f1a\u4ea7\u751f\u610f\u6599\u4e0d\u5230\u7684\u9519\u8bef\u3002\r\n      2\uff09 \u6709\u4e9b\u96c6\u6210\u5316\u7684\u8c03\u8bd5\u5de5\u5177\u53ef\u4ee5\u5bf9const \u5e38\u91cf\u8fdb\u884c\u8c03\u8bd5\uff0c\u4f46\u662f\u4e0d\u80fd\u5bf9\u5b8f\u5e38\u91cf\u8fdb\u884c\u8c03\u8bd5\u3002"},{"ID":"21","typeID":"12","question":"\u5206\u522b\u5199\u51faBOOL,int,float,\u6307\u9488\u7c7b\u578b\u7684\u53d8\u91cfa \u4e0e\u201c\u96f6\u201d\u7684\u6bd4\u8f83\u8bed\u53e5\uff1f","answer":"BOOL :    if ( !a ) or if(a)\r\nint :     if ( a == 0)\r\nfloat :   const EXPRESSION EXP = 0.000001\r\n          if ( a < EXP && a >-EXP)\r\npointer : if ( a != NULL) or if(a == NULL)"},{"ID":"20","typeID":"12","question":"C++\u662f\u4e0d\u662f\u7c7b\u578b\u5b89\u5168\u7684\uff1f","answer":"\u4e0d\u662f\u3002\u4e24\u4e2a\u4e0d\u540c\u7c7b\u578b\u7684\u6307\u9488\u4e4b\u95f4\u53ef\u4ee5\u5f3a\u5236\u8f6c\u6362\uff08\u7528reinterpret cast)\u3002C#\u662f\u7c7b\u578b\u5b89\u5168\u7684\u3002"},{"ID":"19","typeID":"12","question":"New delete \u4e0emalloc free \u7684\u8054\u7cfb\u4e0e\u533a\u522b?","answer":"\u90fd\u662f\u5728\u5806(heap)\u4e0a\u8fdb\u884c\u52a8\u6001\u7684\u5185\u5b58\u64cd\u4f5c\u3002\u7528malloc\u51fd\u6570\u9700\u8981\u6307\u5b9a\u5185\u5b58\u5206\u914d\u7684\u5b57\u8282\u6570\u5e76\u4e14\u4e0d\u80fd\u521d\u59cb\u5316\u5bf9\u8c61\uff0cnew \u4f1a\u81ea\u52a8\u8c03\u7528\u5bf9\u8c61\u7684\u6784\u9020\u51fd\u6570\u3002delete \u4f1a\u8c03\u7528\u5bf9\u8c61\u7684destructor\uff0c\u800cfree \u4e0d\u4f1a\u8c03\u7528\u5bf9\u8c61\u7684destructor."},{"ID":"18","typeID":"12","question":" Ado\u4e0eAdo.net\u7684\u76f8\u540c\u4e0e\u4e0d\u540c\uff1f","answer":"\u9664\u4e86\u201c\u80fd\u591f\u8ba9\u5e94\u7528\u7a0b\u5e8f\u5904\u7406\u5b58\u50a8\u4e8eDBMS \u4e2d\u7684\u6570\u636e\u201c\u8fd9\u4e00\u57fa\u672c\u76f8\u4f3c\u70b9\u5916\uff0c\u4e24\u8005\u6ca1\u6709\u592a\u591a\u5171\u540c\u4e4b\u5904\u3002\u4f46\u662fAdo\u4f7f\u7528OLE DB \u63a5\u53e3\u5e76\u57fa\u4e8e\u5fae\u8f6f\u7684COM \u6280\u672f\uff0c\u800cADO.NET \u62e5\u6709\u81ea\u5df1\u7684ADO.NET \u63a5\u53e3\u5e76\u4e14\u57fa\u4e8e\u5fae\u8f6f\u7684.NET \u4f53\u7cfb\u67b6\u6784\u3002\u4f17\u6240\u5468\u77e5.NET \u4f53\u7cfb\u4e0d\u540c\u4e8eCOM \u4f53\u7cfb\uff0cADO.NET \u63a5\u53e3\u4e5f\u5c31\u5b8c\u5168\u4e0d\u540c\u4e8eADO\u548cOLE DB \u63a5\u53e3\uff0c\u8fd9\u4e5f\u5c31\u662f\u8bf4ADO.NET \u548cADO\u662f\u4e24\u79cd\u6570\u636e\u8bbf\u95ee\u65b9\u5f0f\u3002ADO.net \u63d0\u4f9b\u5bf9XML \u7684\u652f\u6301\u3002"},{"ID":"17","typeID":"12","question":"\u591a\u6001\u7684\u4f5c\u7528\uff1f","answer":"\u4e3b\u8981\u662f\u4e24\u4e2a\uff1a1. \u9690\u85cf\u5b9e\u73b0\u7ec6\u8282\uff0c\u4f7f\u5f97\u4ee3\u7801\u80fd\u591f\u6a21\u5757\u5316\uff1b\u6269\u5c55\u4ee3\u7801\u6a21\u5757\uff0c\u5b9e\u73b0\u4ee3\u7801\u91cd\u7528\uff1b2. \u63a5\u53e3\u91cd\u7528\uff1a\u4e3a\u4e86\u7c7b\u5728\u7ee7\u627f\u548c\u6d3e\u751f\u7684\u65f6\u5019\uff0c\u4fdd\u8bc1\u4f7f\u7528\u5bb6\u65cf\u4e2d\u4efb\u4e00\u7c7b\u7684\u5b9e\u4f8b\u7684\u67d0\u4e00\u5c5e\u6027\u65f6\u7684\u6b63\u786e\u8c03\u7528\u3002"},{"ID":"16","typeID":"12","question":"\u5df2\u77e5strcpy\u7684\u51fd\u6570\u539f\u578b\uff1achar *strcpy(char *strDest, const char *strSrc)\u5176\u4e2dstrDest \u662f\u76ee\u7684\u5b57\u7b26\u4e32\uff0cstrSrc \u662f\u6e90\u5b57\u7b26\u4e32\u3002\u4e0d\u8c03\u7528C++\/C \u7684\u5b57\u7b26\u4e32\u5e93\u51fd\u6570\uff0c\u8bf7\u7f16\u5199\u51fd\u6570 strcpy\u3002","answer":"char *strcpy(char *strDest, const char *strSrc)\r\n{\r\nif ( strDest == NULL || strSrc == NULL)\r\nreturn NULL ;\r\nif ( strDest == strSrc)\r\nreturn strDest ;\r\nchar *tempptr = strDest ;\r\nwhile( (*strDest++ = *strSrc++) != \u2018\/0\u2019)\r\n;\r\nreturn tempptr ;\r\n}"},{"ID":"15","typeID":"12","question":"\u7ed3\u6784\u4e0e\u8054\u5408\u6709\u548c\u533a\u522b\uff1f","answer":"1. \u7ed3\u6784\u548c\u8054\u5408\u90fd\u662f\u7531\u591a\u4e2a\u4e0d\u540c\u7684\u6570\u636e\u7c7b\u578b\u6210\u5458\u7ec4\u6210, \u4f46\u5728\u4efb\u4f55\u540c\u4e00\u65f6\u523b, \u8054\u5408\u4e2d\u53ea\u5b58\u653e\u4e86\u4e00\u4e2a\u88ab\u9009\u4e2d\u7684\u6210\u5458\uff08\u6240\u6709\u6210\u5458\u5171\u7528\u4e00\u5757\u5730\u5740\u7a7a\u95f4\uff09, \u800c\u7ed3\u6784\u7684\u6240\u6709\u6210\u5458\u90fd\u5b58\u5728\uff08\u4e0d\u540c\u6210\u5458\u7684\u5b58\u653e\u5730\u5740\u4e0d\u540c\uff09\u3002 \r\n 2. \u5bf9\u4e8e\u8054\u5408\u7684\u4e0d\u540c\u6210\u5458\u8d4b\u503c, \u5c06\u4f1a\u5bf9\u5176\u5b83\u6210\u5458\u91cd\u5199,  \u539f\u6765\u6210\u5458\u7684\u503c\u5c31\u4e0d\u5b58\u5728\u4e86, \u800c\u5bf9\u4e8e\u7ed3\u6784\u7684\u4e0d\u540c\u6210\u5458\u8d4b\u503c\u662f\u4e92\u4e0d\u5f71\u54cd\u7684\u3002"},{"ID":"14","typeID":"12","question":" \u201c\u5f15\u7528\u201d\u4e0e\u6307\u9488\u7684\u533a\u522b\u662f\u4ec0\u4e48\uff1f","answer":"\u6307\u9488\u901a\u8fc7\u67d0\u4e2a\u6307\u9488\u53d8\u91cf\u6307\u5411\u4e00\u4e2a\u5bf9\u8c61\u540e\uff0c\u5bf9\u5b83\u6240\u6307\u5411\u7684\u53d8\u91cf\u95f4\u63a5\u64cd\u4f5c\u3002\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u6307\u9488\uff0c\u7a0b\u5e8f\u7684\u53ef\u8bfb\u6027\u5dee\uff1b\u800c\u5f15\u7528\u672c\u8eab\u5c31\u662f\u76ee\u6807\u53d8\u91cf\u7684\u522b\u540d\uff0c\u5bf9\u5f15\u7528\u7684\u64cd\u4f5c\u5c31\u662f\u5bf9\u76ee\u6807\u53d8\u91cf\u7684\u64cd\u4f5c\u3002\u6b64\u5916\uff0c\u5c31\u662f\u4e0a\u9762\u63d0\u5230\u7684\u5bf9\u51fd\u6570\u4f20ref\u548cpointer\u7684\u533a\u522b\u3002"}]}
