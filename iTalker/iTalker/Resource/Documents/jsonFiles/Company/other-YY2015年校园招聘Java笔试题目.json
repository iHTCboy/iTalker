{"success":1,"total":2100,"result":[
  {
    "ID" : "55e429cee4b0152a610c8324",
    "typeID" : "",
    "optionD" : "迭代HashMap采用快速失败机制，而Hashtable不是",
    "optionC" : "HashMap不是同步的，而Hashtable是同步的",
    "optionAnswer" : "B",
    "answer" : "A：HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对）\rB：HashTable不允许null值(key和value都不可以),HashMap允许null值(key和value都可以)。\rC：Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。\rD：由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。Hashtable和HashMap的区别主要是前者是同步的，后者是快速失败机制保证",
    "optionB" : "Hashtable允许null值作为key和value，而HashMap不可以",
    "type" : "1",
    "optionA" : "两者都是用key-value方式获取数据",
    "knowledge" : "Java",
    "question" : "关于HashMap与HashTbale，以下说法错误的是（）"
  },
  {
    "ID" : "55e429cee4b0152a610c8326",
    "typeID" : "",
    "optionD" : "list.remove(obj,index);",
    "optionC" : "list.remove(index);",
    "optionAnswer" : "A",
    "answer" : "Iterator  支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。这样做的好处是可以避免 ConcurrentModifiedException ，当打开 Iterator 迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。",
    "optionB" : "list.remove(obj);",
    "type" : "1",
    "optionA" : "it.remove();",
    "knowledge" : "Java",
    "question" : "list是一个ArrayList的对象，哪个选项的代码填到\/\/todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）\rIterator it = list.iterator();\rint index = 0;\rwhile (it.hasNext())\r{\r    Object obj = it.next();\r    if (needDelete(obj))  \/\/needDelete返回boolean，决定是否要删除\r    {\r        \/\/todo delete\r    }\r    index ++;\r}"
  },
  {
    "ID" : "55e429cee4b0152a610c8327",
    "typeID" : "",
    "optionD" : "64",
    "optionC" : "32",
    "optionAnswer" : "C",
    "answer" : "二叉树第K层最多有2的k-1次方个节点\r2^(6-1)=2^5=32",
    "optionB" : "16",
    "type" : "1",
    "optionA" : "8",
    "knowledge" : "Java",
    "question" : "在一颗二叉树上第6层的结点数最多是（）。"
  },
  {
    "ID" : "55e429cee4b0152a610c8328",
    "typeID" : "",
    "optionD" : "顺序存储结构和链式存储结构都能存储",
    "optionC" : "顺序存储结构和链式存储结构都不能使用",
    "optionAnswer" : "D",
    "answer" : "二叉树是非线性结构，即每个数据结点至多只有一个前驱，但可以有多个后继。它可采用顺序存储结构和链式存储结构。\r1．顺序存储结构\r    二叉树的顺序存储，就是用一组连续的存储单元存放二叉树中的结点。\r2．链式存储结构\r    二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。",
    "optionB" : "它不能用链式存储结构存储",
    "type" : "1",
    "optionA" : "它不能用顺序存储结构存储",
    "knowledge" : "Java",
    "question" : "二叉树是非线性数据结构，所以（）。"
  },
  {
    "ID" : "55e429cee4b0152a610c8329",
    "typeID" : "",
    "optionD" : "cedba",
    "optionC" : "deabc",
    "optionAnswer" : "D",
    "answer" : "后续遍历的最后一个节点为二叉树的跟节点，所以c是跟节点\r然后根据中序遍历结果，根节点边为左子树，右边为右子树，可以看到其右子树为空\r根据后续遍历结果，可以看出左子树的根节点为e，递归查询就可以得到二叉树的结构\r然后进行前序遍历得到结果为cedba",
    "optionB" : "decab",
    "type" : "1",
    "optionA" : "acbed",
    "knowledge" : "Java",
    "question" : "已知某二叉树的后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历是（）"
  },
  {
    "ID" : "55e429cee4b0152a610c832a",
    "typeID" : "",
    "optionD" : "平衡二叉树",
    "optionC" : "二叉排序树",
    "optionAnswer" : "A",
    "answer" : "以最小堆为例，\rB，堆不保证节点的个数正好能构成满二叉树\rC，最小堆只保证父节点比孩子节点小，并不是二叉排序树\rD，堆不保证平衡",
    "optionB" : "满二叉树",
    "type" : "1",
    "optionA" : "完全二叉树",
    "knowledge" : "树、堆",
    "question" : "堆的形状是一颗（）。"
  },
  {
    "ID" : "55e429cee4b0152a610c832b",
    "typeID" : "",
    "optionD" : "选择排序",
    "optionC" : "插入排序",
    "optionAnswer" : "D",
    "answer" : "每一插入已排序的数据的一端，所以是选择排序",
    "optionB" : "归并排序",
    "type" : "1",
    "optionA" : "希尔排序",
    "knowledge" : "排序",
    "question" : "排序方法中，从未排序序列中挑选元素，并将其一次插入已排序序列（初始时为空）的一端的方法，称为（）。"
  },
  {
    "ID" : "55e429cee4b0152a610c832c",
    "typeID" : "",
    "optionD" : "软件",
    "optionC" : "硬件",
    "optionAnswer" : "A",
    "answer" : "一般来说，操作系统可以分为五大管理功能部分：\r1）设备管理：主要是负责内核与外围设备的数据交互，实质是对硬件设备的管理，包括对输入输出设备的分配，初始化，维护与回收等。例如管理音频输入输出。\r2）作业管理：这部分功能主要是负责人机交互，图形界面或者系统任务的管理。\r3）文件管理：这部分功能涉及文件的逻辑组织和物理组织，目录结构和管理等。从操作系统的角度来看，文件系统是系统对文件存储器的存储空间进行分配，维护和回收，同时负责文件的索引，共享和权限保护。而从用户的角度来说，文件系统是按照文件目录和文件名来进行存取的。\r4）进程管理：说明一个进程存在的唯一标志是pcb（进程控制块），负责维护进程的信息和状态。进程管理实质上是系统采取某些进程调度算法来使处理合理的分配给每个任务使用。\r5）存储管理：数据的存储方式和组织结构。",
    "optionB" : "储存器",
    "type" : "1",
    "optionA" : "进程",
    "knowledge" : "操作系统",
    "question" : "操作系统的功能是进行处理机管理，（）管理，设备管理，文件管理和作业管理等"
  },
  {
    "ID" : "55e429cee4b0152a610c832d",
    "typeID" : "",
    "optionD" : "日态程序执行特权指令",
    "optionC" : "断电",
    "optionAnswer" : "A",
    "answer" : "运行程序请求分配内存不是强迫性的，是非强迫中断",
    "optionB" : "传输结束",
    "type" : "1",
    "optionA" : "运行的程序请求分配一块内存",
    "knowledge" : "操作系统",
    "question" : "下列中断不属于强迫性中断的是（）。"
  },
  {
    "ID" : "55e429cee4b0152a610c832e",
    "typeID" : "",
    "optionD" : "提交队列",
    "optionC" : "作业后备队列",
    "optionAnswer" : "A",
    "answer" : "就绪队列是等待CPU时间的队列，其中存放着等待执行的任务",
    "optionB" : "等待队列",
    "type" : "1",
    "optionA" : "就绪队列",
    "knowledge" : "操作系统",
    "question" : "进程调度是从（）选择一个进程投入运行。"
  },
  {
    "ID" : "55e429cee4b0152a610c832f",
    "typeID" : "",
    "optionD" : "多个并发进程竞争独占型资源",
    "optionC" : "硬件故障",
    "optionAnswer" : "D",
    "answer" : "死锁是多个进程或者多线程竞争互斥资源时长见的问题，假如两个进程a,b，进程a占据了资源S1,申请访问资源S2，进程b占据了资源S2，申请访问S1,两个进程互不相让，都在等待对方进程释放该资源，这就造成了死锁",
    "optionB" : "某个进程申请资源数超过了系统拥有的最大资源数",
    "type" : "1",
    "optionA" : "某个进程申请系统中不存在的资源",
    "knowledge" : "操作系统",
    "question" : "“死锁”问题的讨论是针对（）的。"
  },
  {
    "ID" : "55e429cfe4b0152a610c8330",
    "typeID" : "",
    "optionD" : "7",
    "optionC" : "6",
    "optionAnswer" : "B",
    "answer" : "不发生死锁的条件是至少能保证一个进程能获得三台打印机资源。\r最坏的情况是1个进程获取三台打印机资源，另外N-1个进程获取到两台打印机，等待获取第三台。\r3+（N-1）*2=11\rN=5",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "4",
    "knowledge" : "操作系统",
    "question" : "某系统中有11台打印机，N个进程共享打印机资源，每个进程要求3台，当N的取值不超过（）时系统不会发生死锁。"
  },
  {
    "ID" : "55e429cfe4b0152a610c8331",
    "typeID" : "",
    "optionD" : "传输层",
    "optionC" : "应用层",
    "optionAnswer" : "A",
    "answer" : "IP是英文Internet Protocol（网络之间互连的协议）的缩写，中文简称为“网协”，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。\rIP协议定义在OSI-RM第三层———网络层，是internet最重要的协议。在IP协议中规定了在internet上进行通信时应遵守的规则，例如IP数据包的组成、路由器如何将IP数据包送到目的主机等。\rIP协议工作在网络层是无连接的，不可靠的数据包协议，主要是用于路由数据包及主机之间寻址 。",
    "optionB" : "数据链路层",
    "type" : "1",
    "optionA" : "网络互联层",
    "knowledge" : "网络基础",
    "question" : "IP协议属于（）层。"
  },
  {
    "ID" : "55e429cfe4b0152a610c8332",
    "typeID" : "",
    "optionD" : "RARP",
    "optionC" : "ARP",
    "optionAnswer" : "D",
    "answer" : "A，ip协议是网络层协议，提供ip路由功能\rB，ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP\/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。\rC，ARP协议是地址解析协议，用于将ip地址转换为对应的mac地址\rD，RARP是逆地址解析协议，跟ARP相反，用于将Mac地址转换为ip地址",
    "optionB" : "ICMP",
    "type" : "1",
    "optionA" : "IP ",
    "knowledge" : "网络基础",
    "question" : "将网络物理地址转换为IP地址的协议是（）。"
  },
  {
    "ID" : "55e429cfe4b0152a610c8333",
    "typeID" : "",
    "optionD" : "130.63.160",
    "optionC" : "63.16",
    "optionAnswer" : "B",
    "answer" : "130.63.160.2是B类IP地址\rB类IP地址前16位（两个字节）为网络号，后16位是主机号\r划分子网就是将主机号中的一部分拿出来当做子网号\r这里子网掩码为255.255.255.0也就是把前三个字节当成了网络号\r与B类IP默认的前两个字节作为网络号相比，第三个字节就是子网号，就是160\r所以这个ip的网络号是130.63 子网号是 160 主机号是2",
    "optionB" : "160",
    "type" : "1",
    "optionA" : "160.2",
    "knowledge" : "网络基础",
    "question" : "对于IP地址130.63.160.2，MASK为255.255.255.0，子网号为（）"
  },
  {
    "ID" : "55e429cfe4b0152a610c8334",
    "typeID" : "",
    "optionD" : "D",
    "optionC" : "C",
    "optionAnswer" : "C",
    "answer" : "IP地址的四大类型 \r  IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。   \r  A类：第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。  \r  B类：前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。  \r  C类：前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。  \r特殊地址 \r  D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户。  \r  E类：是保留地址。该类IP地址的最前面为“11110”，所以地址的网络号取值于240~255之间。  \r  回送地址：127.0.0.1。一般用于测试使用。例如：ping 127.0.0.1 来测试本机TCP\/IP是否正常。",
    "optionB" : "B",
    "type" : "1",
    "optionA" : "A",
    "knowledge" : "网络基础",
    "question" : "对于IP地址为200.5.6.3，属于（）类"
  },
  {
    "ID" : "55e429cfe4b0152a610c8335",
    "typeID" : "",
    "optionD" : "NIC",
    "optionC" : "集线器",
    "optionAnswer" : "B",
    "answer" : "网关是局域网连接广域网的出口，可以工作在OSI模型网络层以上的不同层次",
    "optionB" : "网关",
    "type" : "1",
    "optionA" : "路由器",
    "knowledge" : "网络基础",
    "question" : "一个广域网和一个局域网相连，且需要进行协议转换，需要的设备是什么。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ec5",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "可以修改StringBuilder和StringBuffer的内容",
    "optionC" : "StringBuilder是线程安全",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "StringBuffer是线程安全",
    "type" : "1",
    "optionA" : "对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象",
    "knowledge" : "Java",
    "question" : "关于String，StringBuilder以及StringBuffer，描述错误的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ec6",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "Float",
    "optionC" : "Byte",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "String",
    "type" : "1",
    "optionA" : "int",
    "knowledge" : "Java",
    "question" : "以下哪个类型是基本数据类型（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ec7",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "static",
    "optionC" : "serialize",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "volatile",
    "type" : "1",
    "optionA" : "synchronized",
    "knowledge" : "Java",
    "question" : "哪个关键字可以对对象加互斥锁？（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ec8",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "29",
    "optionC" : "28",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "27",
    "type" : "1",
    "optionA" : "26",
    "knowledge" : "Java",
    "question" : "二进制数11101转化为十进制数是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ec9",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "JAVA程序的main方法中，如果只有一条语句，可以不用{}（大括号）括起来",
    "optionC" : "JAVA程序中类名必须与文件名一样",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "JAVA程序中只有一个main方法",
    "type" : "1",
    "optionA" : "JAVA程序的main方法必须写在类里面",
    "knowledge" : "Java",
    "question" : "下列说法正确的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26eca",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "一个class只能定义一个constructor",
    "optionC" : "constructor在一个对象被new时执行",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "constructor必须与class同名，但方法不能与class同名",
    "type" : "1",
    "optionA" : "class中的constructor不可省略",
    "knowledge" : "Java",
    "question" : "下列说法正确的有（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ecb",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "static",
    "optionC" : "final",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "abstract",
    "type" : "1",
    "optionA" : "public",
    "knowledge" : "Java",
    "question" : "类声明中，声明一个类不能再被继承的关键字是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ecc",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "abstract类的子类必须实现其超类的所有abstract方法",
    "optionC" : "abstract类不能实例化",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "final类的方法都不能是abstract，因为final类不能有子类",
    "type" : "1",
    "optionA" : "abstract关键字可以修饰类或方法",
    "knowledge" : "Java",
    "question" : "下面关于abstract关键字描述错误的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ecd",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "deSf",
    "optionC" : "void",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "x3x",
    "type" : "1",
    "optionA" : "STRING",
    "knowledge" : "Java",
    "question" : "以下（）不是合法的标识符？"
  },
  {
    "ID" : "55fa695be4b043d0caf26ece",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "676",
    "optionC" : "677",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "667",
    "type" : "1",
    "optionA" : "666",
    "knowledge" : "Java",
    "question" : "以下程序的运行结果是( )\npublic class Increment\n{\n    public static void main(String args[])\n    {\n        int a;\n        a = 6;\n        System.out.print(a);\n        System.out.print(a++);\n        System.out.print(a);\n    }\n}"
  },
  {
    "ID" : "55fa695be4b043d0caf26ecf",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "只要没有定义不带参数的构造函数，JVM都会为类生成一个默认构造函数",
    "optionC" : "使用别的类的方法仅仅需要引用方法的名字即可",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "局部变量的作用范围仅仅在定义它的方法内，或者是在定义它的控制流块中",
    "type" : "1",
    "optionA" : "在类中定义的变量称为类的成员变量，在别的类中可以直接使用",
    "knowledge" : "Java",
    "question" : "关于类的叙述正确的是（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed0",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "子类通过super关键字只能调用父类的属性，而不能调用父类的方法",
    "optionC" : "子类通过super关键字只能调用父类的方法，而不能调用父类的属性",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "super关键字不仅可以指代子类的直接父类，还可以指代父类的父类",
    "type" : "1",
    "optionA" : "super关键字是在子类对象内部指代其父类对象的引用",
    "knowledge" : "Java",
    "question" : "下列选项中关于Java中super关键字的说法正确的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed1",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "finally exception in main finished",
    "optionC" : "exception in main finally",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "finally finished",
    "type" : "1",
    "optionA" : "finally exception in main finished",
    "knowledge" : "Java",
    "question" : "给定以下JAVA代码，这段代码运行后输出的结果是（）\npublic class Test\n{\n    public static int aMethod(int i)throws Exception\n    {\n        try{\n            return i \/ 10;\n        }\n        catch (Exception ex)\n        {\n            throw new Exception(\"exception in a Method\");\n        } finally{\n            System.out.printf(\"finally\");\n        }\n    }\n \n    public static void main(String [] args)\n    {\n        try\n        {\n            aMethod(0);\n        }\n        catch (Exception ex)\n        {\n            System.out.printf(\"exception in main\");\n        }\n        System.out.printf(\"finished\");\n    }\n}\n \n"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed2",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "suspend",
    "optionC" : "wait",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "sleep",
    "type" : "1",
    "optionA" : "stop",
    "knowledge" : "Java",
    "question" : "Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed3",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "程序员无法明确强制垃圾回收器运行",
    "optionC" : "赋值给该项对象的引用为null",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "代用system.gc()方法",
    "type" : "1",
    "optionA" : "调用free()方法",
    "knowledge" : "Java",
    "question" : "如何放掉一个指定占据的内存空间？（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed4",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "spring提供了AOP方式的日志系统",
    "optionC" : "使用spring可以实现声明事务",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "spring是“依赖注入”模式的实现",
    "type" : "1",
    "optionA" : "spring是一个轻量级JAVA EE的框架集合",
    "knowledge" : "Java",
    "question" : "关于spring说法错误的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed5",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "JDBC驱动程序",
    "optionC" : "数据库系统",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "Hibernate",
    "type" : "1",
    "optionA" : "Java应用程序",
    "knowledge" : "Java",
    "question" : "事务隔离级别是由谁实现的？"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed6",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "依赖注入指对象在使用时动态注入",
    "optionC" : "依赖注入提供使用接口编程",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "依赖注入使组件之间相互依赖，相互制约",
    "type" : "1",
    "optionA" : "依赖注入能够独立开发各组件，然后根据组件间关系进行组装",
    "knowledge" : "Java",
    "question" : "关于依赖注入，下列选项中说法错误的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed7",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "迭代HashMap采用快速失败机制，而Hashtable不是",
    "optionC" : "HashMap不是同步的，而Hashtable是同步的",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "Hashtable允许null值作为key和value，而HashMap不可以",
    "type" : "1",
    "optionA" : "两者都是用key-value方式获取数据",
    "knowledge" : "Java",
    "question" : "关于HashMap与HashTbale，以下说法错误的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed8",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "输出结果",
    "optionC" : "储存数据",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "处理数据",
    "type" : "1",
    "optionA" : "输入数据",
    "knowledge" : "Java",
    "question" : "下列不属于算法结构的是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ed9",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "list.remove(obj,index);",
    "optionC" : "list.remove(index);",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "list.remove(obj);",
    "type" : "1",
    "optionA" : "it.remove();",
    "knowledge" : "Java",
    "question" : "list是一个ArrayList的对象，哪个选项的代码填到\/\/todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）\nIterator it = list.iterator();\nint index = 0;\nwhile (it.hasNext())\n{\n    Object obj = it.next();\n    if (needDelete(obj))  \/\/needDelete返回boolean，决定是否要删除\n    {\n        \/\/todo delete\n    }\n    index ++;\n}"
  },
  {
    "ID" : "55fa695be4b043d0caf26eda",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "64",
    "optionC" : "32",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "16",
    "type" : "1",
    "optionA" : "8",
    "knowledge" : "Java",
    "question" : "在一颗二叉树上第6层的结点数最多是（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26edb",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "顺序存储结构和链式存储结构都能存储",
    "optionC" : "顺序存储结构和链式存储结构都不能使用",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "它不能用链式存储结构存储",
    "type" : "1",
    "optionA" : "它不能用顺序存储结构存储",
    "knowledge" : "Java",
    "question" : "二叉树是非线性数据结构，所以（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26edc",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "cedba",
    "optionC" : "deabc",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "decab",
    "type" : "1",
    "optionA" : "acbed",
    "knowledge" : "Java",
    "question" : "已知某二叉树的后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历是（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26edd",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "平衡二叉树",
    "optionC" : "二叉排序树",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "满二叉树",
    "type" : "1",
    "optionA" : "完全二叉树",
    "knowledge" : "树、堆",
    "question" : "堆的形状是一颗（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ede",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "选择排序",
    "optionC" : "插入排序",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "归并排序",
    "type" : "1",
    "optionA" : "希尔排序",
    "knowledge" : "排序",
    "question" : "排序方法中，从未排序序列中挑选元素，并将其一次插入已排序序列（初始时为空）的一端的方法，称为（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26edf",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "软件",
    "optionC" : "硬件",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "储存器",
    "type" : "1",
    "optionA" : "进程",
    "knowledge" : "操作系统",
    "question" : "操作系统的功能是进行处理机管理，（）管理，设备管理，文件管理和作业管理等"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee0",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "日态程序执行特权指令",
    "optionC" : "断电",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "传输结束",
    "type" : "1",
    "optionA" : "运行的程序请求分配一块内存",
    "knowledge" : "操作系统",
    "question" : "下列中断不属于强迫性中断的是（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee1",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "提交队列",
    "optionC" : "作业后备队列",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "等待队列",
    "type" : "1",
    "optionA" : "就绪队列",
    "knowledge" : "操作系统",
    "question" : "进程调度是从（）选择一个进程投入运行。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee2",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "多个并发进程竞争独占型资源",
    "optionC" : "硬件故障",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "某个进程申请资源数超过了系统拥有的最大资源数",
    "type" : "1",
    "optionA" : "某个进程申请系统中不存在的资源",
    "knowledge" : "操作系统",
    "question" : "“死锁”问题的讨论是针对（）的。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee3",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "7",
    "optionC" : "6",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "5",
    "type" : "1",
    "optionA" : "4",
    "knowledge" : "操作系统",
    "question" : "某系统中有11台打印机，N个进程共享打印机资源，每个进程要求3台，当N的取值不超过（）时系统不会发生死锁。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee4",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "传输层",
    "optionC" : "应用层",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "数据链路层",
    "type" : "1",
    "optionA" : "网络互联层",
    "knowledge" : "网络基础",
    "question" : "IP协议属于（）层。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee5",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "RARP",
    "optionC" : "ARP",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "ICMP",
    "type" : "1",
    "optionA" : "IP ",
    "knowledge" : "网络基础",
    "question" : "将网络物理地址转换为IP地址的协议是（）。"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee6",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "130.63.160",
    "optionC" : "63.16",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "160",
    "type" : "1",
    "optionA" : "160.2",
    "knowledge" : "网络基础",
    "question" : "对于IP地址130.63.160.2，MASK为255.255.255.0，子网号为（）"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee7",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "D",
    "optionC" : "C",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "B",
    "type" : "1",
    "optionA" : "A",
    "knowledge" : "网络基础",
    "question" : "对于IP地址为200.5.6.3，属于（）类"
  },
  {
    "ID" : "55fa695be4b043d0caf26ee8",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "NIC",
    "optionC" : "集线器",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "网关",
    "type" : "1",
    "optionA" : "路由器",
    "knowledge" : "网络基础",
    "question" : "一个广域网和一个局域网相连，且需要进行协议转换，需要的设备是什么。"
  }
]}
