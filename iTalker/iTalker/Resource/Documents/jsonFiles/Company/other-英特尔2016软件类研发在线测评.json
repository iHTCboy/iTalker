{"success":1,"total":2100,"result":[
  {
    "ID" : "55fa6a87e4b043d0caf27282",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "scanf(\"%d%s\",b,&c);",
    "optionC" : "scanf(\"%d%s\",b,c);",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "scanf(\"%d%s\",&b,c);",
    "type" : "1",
    "optionA" : "scanf(\"%d%s\",&b,&c);",
    "knowledge" : "C\/C++",
    "question" : "有定义语句：\nint b;\nchar c[10];\n则正确的输入语句是______。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27283",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "和之前的第一个if配对",
    "optionC" : "和之前与其最近的且不带else的if配对",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "和之前与其最近的if配对",
    "type" : "1",
    "optionA" : "和之前与其具有相同缩进位置的if配对",
    "knowledge" : "C\/C++",
    "question" : "在嵌套使用if语句时，C语言规定else总是______。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27284",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "369",
    "optionC" : "852",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "741",
    "type" : "1",
    "optionA" : "258",
    "knowledge" : "C\/C++",
    "question" : "以下程序的输出结果是______。\n\n#include <stdio.h>\nint main()\n{   \n    int i,a[10];\n    for(i=9;i>=0;i--)  a[i]=10-i;\n    printf(\"%d%d%d\",a[2],a[5],a[8]);\n    return 0;\n}"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27285",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "a",
    "optionC" : "a=0",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "!a",
    "type" : "1",
    "optionA" : "a<>0",
    "knowledge" : "C\/C++",
    "question" : "若要求在if后一对圆括号中表示a不等于0的关系，则能正确表示这一关系的表达式为______。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27286",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "int a[2][]={{1,2},{3,4}};",
    "optionC" : "int a[2][2]={{1},2,3};",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "int a[][2]={1,2,3,4};",
    "type" : "1",
    "optionA" : "int a[2][2]={{1},{2}};",
    "knowledge" : "C\/C++",
    "question" : "以下不能正确定义二维数组的选项是______。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27287",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "11,16",
    "optionC" : "16,12",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "13,12",
    "type" : "1",
    "optionA" : "16,16",
    "knowledge" : "C\/C++",
    "question" : "在32位系统环境，编译选项为4字节对齐，那么sizeof(A)和sizeof(B)是： \n\nstruct A\n{\n int a;\n short b;\n int c;\n char d;\n};\nstruct B\n{\n int a;\n short b;\n char c;\n int d;\n};"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27288",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "不确定",
    "optionC" : "3 2 1",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "1 3 2 ",
    "type" : "1",
    "optionA" : "1 2 3",
    "knowledge" : "C\/C++",
    "question" : "下面程序的输出是什么？\n\n#include<stdio.h>\n#include<string.h>\n#include <pthread.h>\n  \nvoid* print1(void* data){\n    printf(\"1 \");\n}\n  \nvoid* print2(void* data){\n    printf(\"2 \");\n}\n \nvoid* print3(void* data){\n    printf(\"3 \");\n}\n \nint main(void){\n    pthread_t t,t1,t2;\n     \n    pthread_create(&t,0,print1,NULL);\n    pthread_create(&t1,0,print2,NULL);\n    pthread_create(&t2,0,print3,NULL);\n     \n    pthread_join(t,NULL);\n    pthread_join(t1,NULL);\n    pthread_join(t2,NULL);\n    printf(\"\\n\");\n}"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27289",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "n, n+1, n+1",
    "optionC" : "n, n, n",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "n+1, n, n",
    "type" : "1",
    "optionA" : "n+1, n, n+1",
    "knowledge" : "C\/C++",
    "question" : "下列代码试图打印数字1-9的全排列组合。\n\n#include \"stdio.h\"\n#define N 9\nint x[N];\nint count = 0;\n \nvoid dump() {\n  int i = 0;\n  for (i = 0; i < N; i++) {\n    printf(\"%d\", x[i]);\n  }\n  printf(\"\\n\");\n}\n \nvoid swap(int a, int b) {\n  int t = x[a];\n  x[a] = x[b];\n  x[b] = t;\n}\n \nvoid run(int n) {\n  int i;\n  if (N - 1 == n) {\n    dump();\n    count ++;\n    return;\n  }\n  for (i = ___; i < N; i++) {\n    swap(___, i);\n    run(n + 1);\n    swap(___, i);\n  }\n}\n \nint main() {\n  int i;\n  for (i = 0; i < N; i++) {\n    x[i] = i + 1;\n  }\n  run(0);\n  printf(\"* Total: %d\\n\", count);\n}\n其中run函数中缺失的部分应该依次为："
  },
  {
    "ID" : "55fa6a87e4b043d0caf2728a",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "广度优先遍历",
    "optionC" : "求关键路径",
    "optionAnswer" : "A",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "求最短路径",
    "type" : "1",
    "optionA" : "拓扑排序",
    "knowledge" : "图",
    "question" : "判断有向图是否存在回路，利用( )方法最佳 。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf2728b",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "8 2 3 5 1 4 7 6",
    "optionC" : "3 8 2 5 1 6 7 4",
    "optionAnswer" : "A",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "3 2 8 5 1 4 6 7",
    "type" : "1",
    "optionA" : "8 3 2 5 1 6 4 7",
    "knowledge" : "树",
    "question" : "初始序列为1 8 6 2 5 4 7 3的一组数采用堆排序，当建堆(小根堆)完毕时，堆所对应的二叉树中序遍历序列为：( )"
  },
  {
    "ID" : "55fa6a87e4b043d0caf2728c",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "p->data==-1",
    "optionC" : "p->next->next==h",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "p->next==h",
    "type" : "1",
    "optionA" : "p->next==NULL",
    "knowledge" : "链表",
    "question" : "在一个以 h 为头指针的单循环链中，p 指针指向链尾结点的条件是( )。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf2728d",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "不造",
    "optionC" : "不确定",
    "optionAnswer" : "A",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "不稳定",
    "type" : "1",
    "optionA" : "稳定",
    "knowledge" : "编程基础",
    "question" : "请阅读该程序：\nPROCEDURE bubblesort(r,n)\nBEGIN\n  i:=1; m:=n-1; flag:=1;\n  WHILE (i<=m) AND (flag=1) DO\n   BEGIN\n     flag:=0;\n     FOR j:=1 TO m DO\n       IF r[j].key>r[j+1].key THEN\n       BEGIN\n         flag:=1; t:=r[j]; r[j]:=r[j+1]; r[j+1]:=t\n       END;\n       i:=i+1;m:=m-1\n   END;\nEND.\n该分类算法稳定吗？(  )"
  },
  {
    "ID" : "55fa6a87e4b043d0caf2728e",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "不可能",
    "optionC" : "21",
    "optionAnswer" : "A",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "24",
    "type" : "1",
    "optionA" : "18",
    "knowledge" : "智力题",
    "question" : "n从1开始，每个操作可以选择对n加1或者对n加倍。若想获得整数2013，最少需要多少个操作：( )"
  },
  {
    "ID" : "55fa6a87e4b043d0caf2728f",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "5",
    "optionC" : "4",
    "optionAnswer" : "A",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "3",
    "type" : "1",
    "optionA" : "2",
    "knowledge" : "智力题",
    "question" : "2^100 mod 7 =____"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27290",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "存在度为2的结点的二叉树",
    "optionC" : "高度为n的二叉树",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "结点均无右孩子的二叉树",
    "type" : "1",
    "optionA" : "结点均无左孩子的二叉树",
    "knowledge" : "树",
    "question" : "若一棵具有n(n>0)个结点的二叉树的先序序列与后序序列正好相反，则该二叉树一定？"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27291",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "quick sort",
    "optionC" : "merge sort",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "heap sort",
    "type" : "1",
    "optionA" : "bubble sort",
    "knowledge" : "排序",
    "question" : "以下排序算法中是稳定的且时间复杂度最小的是："
  },
  {
    "ID" : "55fa6a87e4b043d0caf27292",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "三层以上",
    "optionC" : "三层",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "二层",
    "type" : "1",
    "optionA" : "一层",
    "knowledge" : "网络基础",
    "question" : "交换机工作在OSI七层的哪一层？（ ）"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27293",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "包转发率",
    "optionC" : "路由权",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "路由器优先级",
    "type" : "1",
    "optionA" : "路由",
    "knowledge" : "网络基础",
    "question" : "各个路由协议衡量路由的好坏标准是（ ）。"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27294",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "键盘",
    "optionC" : "RAM",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "Cache",
    "type" : "1",
    "optionA" : "CPU",
    "knowledge" : "编译和体系结构",
    "question" : "不属于冯诺依曼体系结构必要组成部分是：( )"
  },
  {
    "ID" : "55fa6a87e4b043d0caf27295",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "线程越多越好",
    "optionC" : "12",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "8",
    "type" : "1",
    "optionA" : "4",
    "knowledge" : "编译和体系结构",
    "question" : "有一台4核CPU的服务器，上面运行着1种在线服务。如果该在线服务处理一个请求在非独占IO上的等待时间和CPU计算上消耗的时间比为2:1，假定IO带宽充足，那么至少开（）个线程能最大化性能地使用该服务器？"
  }
]}