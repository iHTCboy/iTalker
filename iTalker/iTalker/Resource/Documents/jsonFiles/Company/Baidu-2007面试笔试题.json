{"success":1,"total":2100,"result":[
  {
    "ID" : "55e429cee4b0152a610c8309",
    "typeID" : "",
    "optionD" : "选择排序",
    "optionC" : "直接插入排序",
    "optionAnswer" : "D",
    "answer" : "希尔排序是插入排序的改进，冒泡排序是直接交换排序。选项A、B、C的排序思想都与初始排序次序有关，只有选择排序才无关。",
    "optionB" : "归并排序",
    "type" : "1",
    "optionA" : "Shell排序",
    "knowledge" : "排序方法",
    "question" : "在排序方法中，关键码比较次数与记录地初始排列无关的是 . "
  },
  {
    "ID" : "55e429cee4b0152a610c830b",
    "typeID" : "",
    "optionD" : "栈",
    "optionC" : "堆",
    "optionAnswer" : "A",
    "answer" : "静态局部变量有以下特点：\r该变量在全局数据区分配内存；\r静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；\r静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；\r它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；",
    "optionB" : "未初始化数据段",
    "type" : "1",
    "optionA" : "已初始化数据段",
    "knowledge" : "C\/C++",
    "question" : "代码  \rvoid func() {  \r      static int val;   \r      ···\r}   中，变量val的内存地址位于："
  },
  {
    "ID" : "55e429cee4b0152a610c830c",
    "typeID" : "",
    "optionD" : "thread ID",
    "optionC" : "register set",
    "optionAnswer" : "B",
    "answer" : "线程共享的内容包括：\r1.进程代码段\r2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)\r3.进程打开的文件描述符、\r4.信号的处理器、\r5.进程的当前目录和\r6.进程用户ID与进程组ID\r线程独有的内容包括：\r1.线程ID\r2.寄存器组的值\r3.线程的堆栈\r4.错误返回码\r5.线程的信号屏蔽码",
    "optionB" : "data section",
    "type" : "1",
    "optionA" : "stack ",
    "knowledge" : "线程",
    "question" : "同一进程下的线程可以共享以下"
  },
  {
    "ID" : "55e429cee4b0152a610c830d",
    "typeID" : "",
    "optionD" : "200",
    "optionC" : "100",
    "optionAnswer" : "D",
    "answer" : "short的大小为2字节；short [100]的大小就是200字节",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "2",
    "knowledge" : "C\/C++",
    "question" : "short a[100]，sizeof(a)返回？"
  },
  {
    "ID" : "55e429cee4b0152a610c830e",
    "typeID" : "",
    "optionD" : "CORBA",
    "optionC" : "COM",
    "optionAnswer" : "B",
    "answer" : "ACD都是windows编程里面的东西\rA 是个跨平台组件，实现了framework框架\rC COM组件由以Win 32动态链接库（DLL）或可执行文件（EXE）形式所组成\rD 是一个体系结构，是为了硬件和软件系统的互连而提出的一种解决方案",
    "optionB" : "XP",
    "type" : "1",
    "optionA" : "XPCOM",
    "knowledge" : "C\/C++",
    "question" : "以下哪种不是基于组件的开发技术_____。 "
  },
  {
    "ID" : "55e429cee4b0152a610c830f",
    "typeID" : "",
    "optionD" : "1112",
    "optionC" : "120",
    "optionAnswer" : "C",
    "answer" : "sizeof(st_t)是40\rst [ 2 ]. errstr + 32 相当于st[3]的地址\r( p - ( char *)( st ) 是 st[3]的地址减去 st的首地址。",
    "optionB" : "114",
    "type" : "1",
    "optionA" : "32",
    "knowledge" : "C\/C++",
    "question" : "以下代码打印的结果是（假设运行在i386系列计算机上）：\r  struct st_t  { \r     int status;  \r     short* pdata; \r char errstr[32]; \r };\rst_t st[16];   \rchar* p = (char*)(st[2].errstr   32); \r printf(\"%d\", (p - (char*)(st))); "
  },
  {
    "ID" : "55e429cee4b0152a610c8310",
    "typeID" : "",
    "optionD" : "vector",
    "optionC" : "list",
    "optionAnswer" : "A",
    "answer" : "vector底层封装了数组,list封装了链表，map底层是红黑树,set底层也是二叉树",
    "optionB" : "set",
    "type" : "1",
    "optionA" : "map",
    "knowledge" : "C\/C++",
    "question" : "STL中的哪种结构是连续形式的存储"
  },
  {
    "ID" : "55e429cee4b0152a610c8311",
    "typeID" : "",
    "optionD" : "ABCDE",
    "optionC" : "DECAB",
    "optionAnswer" : "C",
    "answer" : "选项A：压入ABCDE，再依次弹出\r选项B：压入ABCD，弹出D，压入E，弹出E，再弹出CBA\r选项C：不可能\r选项D：压入X，弹出X\r所以答案是C",
    "optionB" : "DECBA",
    "type" : "1",
    "optionA" : "EDCBA",
    "knowledge" : "C\/C++",
    "question" : "一个栈的入栈序列是A，B，C，D，E，则栈的不可能的输出序列是（ ）"
  },
  {
    "ID" : "55fa697ee4b043d0caf26fed",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "选择排序",
    "optionC" : "直接插入排序",
    "optionAnswer" : "D",
    "answer" : " ",
    "optionB" : "归并排序",
    "type" : "1",
    "optionA" : "Shell排序",
    "knowledge" : "排序方法",
    "question" : "在排序方法中，关键码比较次数与记录地初始排列无关的是 . "
  },
  {
    "ID" : "55fa697ee4b043d0caf26fee",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "x=1",
    "optionC" : " ++x",
    "optionAnswer" : "D",
    "answer" : " ",
    "optionB" : "x++",
    "type" : "1",
    "optionA" : "x=y",
    "knowledge" : "多线程",
    "question" : "以下多线程对int型变量x的操作，哪个不需要进行同步："
  },
  {
    "ID" : "55fa697ee4b043d0caf26fef",
    "typeID" : "562754ec60b2260e064b54cf",
    "optionD" : "栈",
    "optionC" : "堆",
    "optionAnswer" : "A",
    "answer" : " ",
    "optionB" : "未初始化数据段",
    "type" : "1",
    "optionA" : "已初始化数据段",
    "knowledge" : "C\/C++",
    "question" : "代码  \nvoid func() {  \n      static int val;   \n      ···\n}   中，变量val的内存地址位于："
  },
  {
    "ID" : "55fa697ee4b043d0caf26ff0",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "thread ID",
    "optionC" : "register set",
    "optionAnswer" : "B",
    "answer" : " ",
    "optionB" : "data section",
    "type" : "1",
    "optionA" : "stack ",
    "knowledge" : "线程",
    "question" : "同一进程下的线程可以共享以下"
  },
  {
    "ID" : "55fa697ee4b043d0caf26ff1",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "200",
    "optionC" : "100",
    "optionAnswer" : "D",
    "answer" : " ",
    "optionB" : "4",
    "type" : "1",
    "optionA" : "2",
    "knowledge" : "C\/C++",
    "question" : "short a[100]，sizeof(a)返回？"
  },
  {
    "ID" : "55fa697ee4b043d0caf26ff2",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "CORBA",
    "optionC" : "COM",
    "optionAnswer" : "B",
    "answer" : " ",
    "optionB" : "XP",
    "type" : "1",
    "optionA" : "XPCOM",
    "knowledge" : "C\/C++",
    "question" : "以下哪种不是基于组件的开发技术_____。 "
  },
  {
    "ID" : "55fa697ee4b043d0caf26ff3",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "1112",
    "optionC" : "120",
    "optionAnswer" : "C",
    "answer" : " ",
    "optionB" : "114",
    "type" : "1",
    "optionA" : "32",
    "knowledge" : "C\/C++",
    "question" : "以下代码打印的结果是（假设运行在i386系列计算机上）：\n  struct st_t  { \n     int status;  \n     short* pdata; \n char errstr[32]; \n };\nst_t st[16];   \nchar* p = (char*)(st[2].errstr   32); \n printf(\"%d\", (p - (char*)(st))); "
  },
  {
    "ID" : "55fa697ee4b043d0caf26ff4",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "vector",
    "optionC" : "list",
    "optionAnswer" : "A",
    "answer" : " ",
    "optionB" : "set",
    "type" : "1",
    "optionA" : "map",
    "knowledge" : "C\/C++",
    "question" : "STL中的哪种结构是连续形式的存储"
  },
  {
    "ID" : "55fa697ee4b043d0caf26ff5",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "ABCDE",
    "optionC" : "DECAB",
    "optionAnswer" : "C",
    "answer" : " ",
    "optionB" : "DECBA",
    "type" : "1",
    "optionA" : "EDCBA",
    "knowledge" : "C\/C++",
    "question" : "一个栈的入栈序列是A，B，C，D，E，则栈的不可能的输出序列是（ ）"
  }
]}
