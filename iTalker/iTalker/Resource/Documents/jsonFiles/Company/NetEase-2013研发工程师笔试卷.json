{"success":1,"total":2100,"result":[
  {
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "ID" : "55fa6a43e4b043d0caf27224",
    "typeID" : "55dd5e2360b258078b9e4458",
    "type" : "2",
    "knowledge" : "",
    "question" : "两个圆相交，交点是A1，A2。现在过A1点做一直线与两个圆分别相交另外一点B1，B2.问在什么情况下，B1B2最长?"
  },
  {
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "ID" : "55fa6a43e4b043d0caf27225",
    "typeID" : "55dd5e2360b258078b9e4458",
    "type" : "2",
    "knowledge" : "",
    "question" : "Smith夫妇召开宴会，并邀请其他4对夫妇参加宴会。在宴会上，他们彼此握手， 并且满足没有一个人同自己握手，没有两个人握手一次以上，并且夫妻之间不握手。 然后Mr. Smith问其它客人握手的次数，每个人的答案是不一样的。 求Mrs Smith握手的次数"
  },
  {
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "ID" : "55fa6a43e4b043d0caf27226",
    "typeID" : "55dd5e2360b258078b9e4458",
    "type" : "2",
    "knowledge" : "",
    "question" : "有6种不同颜色的球，分别记为1,2,3,4,5,6，每种球有无数个。现在取5个球，求在以下的条件下：\n1、5种不同颜色，\n2、4种不同颜色的球，\n3、3种不同颜色的球， \n4、2种不同颜色的球，\n它们的概率。"
  },
  {
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "ID" : "55fa6a43e4b043d0caf27227",
    "typeID" : "55dd5e2360b258078b9e4458",
    "type" : "2",
    "knowledge" : "",
    "question" : "有一次数学比赛，共有A，B和C三道题目。所有人都至少解答出一道题目，总共有25人。\n在没有答出A的人中，答出B的人数是答出C的人数的两倍；单单答出A的人，比其他答出A的人总数多1；在所有只有答出一道题目的人当中，答出B和C的人数刚好是一半。\n求只答出B的人数。"
  },
  {
    "answer" : "可以有两个方法：如果可以破坏链表m_pNext,那可以一个循环将所有m_pNext指向上一个接点，然后一个循环输出，然后再还原接点。\n个人觉得这个太复杂。\n方法二：使用递归或借助栈来做。（所有递归都可以通过栈来转成非递归）\n\nvoid PutRlist(const listNode * pNode)\n{\n    if（!pNode） return;\n    PutRlist(pNode->m_pNext);\n    \/\/输出。\n    std::cout<<pNode->m_nKey<< \"<-\";\n}",
    "ID" : "55fa6a43e4b043d0caf27228",
    "typeID" : "55dd5e2360b258078b9e4458",
    "type" : "2",
    "knowledge" : "",
    "question" : "从尾到头输出链表\n题目：输入一个链表的头结点，从尾到头反过来输出每个结点的值。链表结点定义如下：\nstruct ListNode\n{\n    int  m_nKey;\n    ListNode *m_pNext;\n};"
  },
  {
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "ID" : "55fa6a43e4b043d0caf27229",
    "typeID" : "55dd5e2360b258078b9e4458",
    "type" : "2",
    "knowledge" : "",
    "question" : "10个房间里放着随机数量的金币。每个房间只能进入一次，并只能在一个房间中拿金币。 一个人采取如下策略：前四个房间只看不拿。随后的房间只要看到比前四个房间都多的金币数， 就拿。否则就拿最后一个房间的金币。编程计算这种策略拿到最多金币的概率。"
  }
]}