{"success":1,"total":14,"result":[
  {
    "ID" : "55fa6a71e4b043d0caf27274",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "实现运行时多态性的机制称为动态绑定",
    "optionC" : "运行时的多态性可通过模板和虚函数实现",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "编译时的多态性可通过函数重载实现",
    "type" : "1",
    "optionA" : "C++语言的多态性分为编译时的多态性和运行时的多态性",
    "knowledge" : "C\/C++",
    "question" : "下面关于多态性的描述，错误的是："
  },
  {
    "ID" : "55fa6a71e4b043d0caf27275",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "类是具有共同行为的若干对象的统一描述体",
    "optionC" : "对象是类的实例，一个对象必须属于一个已知的类",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "类和对象之间的关系是抽象和具体的关系",
    "type" : "1",
    "optionA" : "类就是C语言中的结构体类型，对象就是C语言中的结构体变量",
    "knowledge" : "C\/C++",
    "question" : "下面关于类和对象的描述中，错误的是："
  },
  {
    "ID" : "55fa6a71e4b043d0caf27276",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "语句#include?“stdlib.h”是错误的",
    "optionC" : "语句#include?<stdlib.h>和#include?“stdlib.h”都是正确的，程序编译速度没有区别",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "语句#include?<stdlib.h>是正确的，而且程序编译速度比#include?“stdlib.h”要快",
    "type" : "1",
    "optionA" : "语句#include?“stdlib.h”是正确的，而且程序编译速度比#include?<stdlib.h>要快",
    "knowledge" : "C\/C++",
    "question" : "引用标准库时，下面的说法你认为哪个是正确的："
  },
  {
    "ID" : "55fa6a71e4b043d0caf27277",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "7",
    "optionC" : "2",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "knowledge" : "C\/C++",
    "question" : "设a、b、c、d、m、n均为int型变量，且a=5、b=6、c=7、d=8、m=2、n=2,则逻辑表达式（m=a>b）&&(n=c>d)运算后，n的值为："
  },
  {
    "ID" : "55fa6a71e4b043d0caf27278",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "函数名称",
    "optionC" : "函数类型",
    "optionAnswer" : "C",
    "answer" : "  ",
    "optionB" : "参数类型",
    "type" : "1",
    "optionA" : "参数个数",
    "knowledge" : "C\/C++",
    "question" : "不能作为重载函数的调用的依据是："
  },
  {
    "ID" : "55fa6a71e4b043d0caf27279",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "16",
    "optionC" : "15",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "10",
    "type" : "1",
    "optionA" : "0",
    "knowledge" : "C\/C++",
    "question" : "下列程序的输出结果为:#include<iostream.h>\nint func(int n)\n{\n　　 if(n<1)\n       return 1;\n    else\n       return n+func(n-1);\n    return 0;\n}\nvoid main() {\n    cout<< func(5) <<endl;\n}"
  },
  {
    "ID" : "55fa6a71e4b043d0caf2727a",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "cba",
    "optionC" : "cab",
    "optionAnswer" : "A",
    "answer" : "  ",
    "optionB" : "acb",
    "type" : "1",
    "optionA" : "abc",
    "knowledge" : "C\/C++\/Java",
    "question" : "建立派生类对象时,3种构造函数分别是a(基类的构造函数)、b(成员对象的构造函数)、c(派生类的构造函数)这3种构造函数的调用顺序为:"
  },
  {
    "ID" : "55fa6a71e4b043d0caf2727b",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "重载错误",
    "optionC" : "选项A）和选项B）都可能",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "二元运算符",
    "type" : "1",
    "optionA" : "一元运算符",
    "knowledge" : "C\/C++",
    "question" : "如果友元函数重载一个运算符时，其参数表中没有任何参数则说明该运算符是："
  },
  {
    "ID" : "55fa6a71e4b043d0caf2727c",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "-2, 9",
    "optionC" : "-2, 5",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "3, 5",
    "type" : "1",
    "optionA" : "3,?4",
    "knowledge" : "C\/C++",
    "question" : "#define F(X,Y)   (X)--, (Y)++, (X)*(Y);\n?\nint i, a = 3, b = 4;\nfor( i = 0; i<5; i++)\n    F(a,b)\nprintf(“%d, %d”, a, b);输出结果是"
  },
  {
    "ID" : "55fa6a71e4b043d0caf2727d",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "b这个字符的哈夫曼编码值位数应该最短，d这个字符的哈夫曼编码值位数应该最长",
    "optionC" : "使用哈夫曼算法进行编码，a、b、c、d、e这5个字符对应的编码值可以有多套，但每个字符编码的位（bit）数是确定的",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "使用哈夫曼算法进行编码，a、b、c、d、e这5个字符对应的编码值是唯一确定的",
    "type" : "1",
    "optionA" : "使用哈夫曼算法编码后，用编码值来存储这段文本将花费最少的存储空间",
    "knowledge" : "树\/字符串",
    "question" : "已知一段文本有1382个字符，使用了1382个字节进行存储，这段文本全部是由a、b、c、d、e这5个字符组成，a出现了354次，b出现了483次，c出现了227次，d出现了96次，e出现了232次，对这5个字符使用哈夫曼（Huffman）算法进行编码，则以下哪些说法不正确（）"
  },
  {
    "ID" : "55fa6a71e4b043d0caf2727e",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "以上说法均正确",
    "optionC" : "break语句不可以出现在循环体内",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "do-while循环可以写成while循环的格式",
    "type" : "1",
    "optionA" : "while循环语句的循环体至少执行1次",
    "knowledge" : "编程基础",
    "question" : "下面描述正确的是（）"
  },
  {
    "ID" : "55fa6a71e4b043d0caf2727f",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "以上均为非法的",
    "optionC" : "template<class C1, ypename C2>class C3{};",
    "optionAnswer" : "B",
    "answer" : "  ",
    "optionB" : "template<class T, U, class V>class C2;",
    "type" : "1",
    "optionA" : "template<class Type>class C1;",
    "knowledge" : "C\/C++",
    "question" : "下面模板声明中，哪些是非法的（）"
  },
  {
    "ID" : "55fa6a71e4b043d0caf27280",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "拷贝初始化构造函数的作用是将一个已知对象的数据成员值拷贝给正在创建的另一个同类的对象",
    "optionC" : "每个类都必须有一个拷贝初始化构造函数，如果类中没有说明拷贝构造函数，则编译器系统会自动生成一个缺省拷贝构造函数，作为该类的保护成员",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "该函数只有一个参数，必须是对某个对象的引用",
    "type" : "1",
    "optionA" : "该函数名同类名，也是一种构造函数，该函数返回自身引用",
    "knowledge" : "C\/C++",
    "question" : "拷贝构造函数的特点是（）"
  },
  {
    "ID" : "55fa6a71e4b043d0caf27281",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "int add(int a , int b)",
    "optionC" : "double add(double a , double b)",
    "optionAnswer" : "D",
    "answer" : "  ",
    "optionB" : "int add(double a , double b)",
    "type" : "1",
    "optionA" : "int add(int a ,int b ,int c)",
    "knowledge" : "C\/C++",
    "question" : "下列对函数double add(int a , int b)进行重载，错误的是（）"
  }
]}
