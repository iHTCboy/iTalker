{"success":1,"total":2100,"result":[
  {
    "ID" : "55fa696ee4b043d0caf26fa0",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "6",
    "optionC" : "8",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "9",
    "type" : "1",
    "optionA" : "10",
    "knowledge" : "C\/C++",
    "question" : "假定CSomething是一个类，执行下面这些语句之后，内存里创建了____个CSomething对象。\n\nCSomething a();\nCSomething b(2);\nCSomething c[3];\nCSomething &ra = b;\nCSomething d=b;\nCSomething *pA = c;\nCSomething *p = new CSomething(4);"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa1",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "0.1435",
    "optionC" : "0.6316",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "0.4582",
    "type" : "1",
    "optionA" : "0.5371",
    "knowledge" : "概率统计",
    "question" : "假设淘宝网上某商品A在任一时刻t内若有人浏览，则该商品在下一时刻t+1内无人浏览的概率为0.35（即下一时刻的浏览情况仅与当前时段相关），定义此条件概率为 P(O_{t+1}=0|O_t=1)=0.35(即用“1”代表有人浏览的事件，用“0”代表无人浏览的事件），类似得定义P(O_{t+1}=1|O_t=1)=0.65，P(O_{t+1}=0|O_t=0)=0.4，P(O_{t+1}=1|O_t=0)=0.6。若此商品A在t=0时有人浏览，它在t=100000时有人浏览的概率是____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa2",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "3",
    "optionC" : "2",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "1",
    "type" : "1",
    "optionA" : "0",
    "knowledge" : "智力题",
    "question" : "猜数字游戏的过程是你输入一个4位数（数字选取0~9，不会重复），电脑会告诉你两个信息：A个数字和位置均正确，B个数字正确但位置错误。例如正确答案是7890你输入0789，电脑会告诉你0A4B，表示有0个数字和位置完全正确，但有4个数字正确但位置错误。现在牛妹猜了三次的结果分别是：1234=>0A4B，2341=>1A3B，3412=>2A2B，那么牛妹最少还要猜____次才能保证一定得到4A0B的结果。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa3",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "5",
    "optionC" : "3",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "knowledge" : "树",
    "question" : "对一棵二叉树进行后续遍历，其输出结果为A，B，C，这样的二叉树有____棵。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa4",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "队列和堆栈",
    "optionC" : "哈希表和队列",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "链表和哈希表",
    "type" : "1",
    "optionA" : "数组和链表",
    "knowledge" : "栈 链表 数组",
    "question" : "下面数据结构能够支持随机的插入和删除操作、并具有较好的性能的是____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa5",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "b c d",
    "optionC" : "b c d e",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "  b c",
    "type" : "1",
    "optionA" : "a b c",
    "knowledge" : "C\/C++",
    "question" : "有一个类A，其数据成员如下：\n\nclass A {\n...\nprivate:\n     int a;\npublic:\n     const int b;\n     float* &c;\n     static const char* d;\n     static double* e;\n}\n则构造函数中，成员变量一定要通过初始化列表来初始化的是：______。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa6",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "256.8",
    "optionC" : "232.8",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "200",
    "type" : "1",
    "optionA" : "186.6",
    "knowledge" : "概率统计",
    "question" : "一个英雄基础攻击力为100，携带了三件暴击武器，武器A有40%的概率打出2倍攻击，武器B有20%的概率打出4倍攻击，武器C有10%概率打出6倍攻击，各暴击效果触发是独立事件，但是多个暴击效果在一次攻击中同时触发时只有后面武器的暴击真正生效，例如一次攻击中武器A判定不暴击，武器B和武器C都判定触发暴击，那么这次攻击实际是600攻击力。那么这个英雄攻击力的数学期望是____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa7",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "putchar",
    "optionC" : "pwrite",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "putc",
    "type" : "1",
    "optionA" : "fwrite",
    "knowledge" : "C\/C++ Linux",
    "question" : "以下函数中，和其他函数不属于一类的是____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa8",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "5120",
    "optionC" : "4096",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "3584",
    "type" : "1",
    "optionA" : "4608",
    "knowledge" : "操作系统",
    "question" : "操作系统采用分页存储管理方式，下图给出了进程A和进程B的页表结构。如果物理页的大小为512字节，那么进程A与进程B的物理内存总共使用了____字节。\n进程A页表：                     进程B页表：\n\n逻辑页    物理页             逻辑页    物理页\n\n0            9                       0            1\n\n1            2                       1            3\n\n2            4                       2            4\n\n3            6                       3            7\n\n4                                    4            2\n\n5                                    5"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fa9",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "快速排序",
    "optionC" : "归并排序",
    "optionAnswer" : "C",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "插入排序",
    "type" : "1",
    "optionA" : "堆排序",
    "knowledge" : "排序",
    "question" : "现有1G数据需要排序，计算资源只有1G内存可用，下列排序方法中最可能出现性能问题的是____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26faa",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "17",
    "optionC" : "13",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "11",
    "type" : "1",
    "optionA" : "10",
    "knowledge" : " 加密和安全",
    "question" : "凯撒（Caesar)密码是一种基于字符替换的对称式加密方法，它是通过对26个英文字母循环移位和替换来进行编码的。设待加密的消息为\"Alibaba Group\"，加密后的密文是\"RCzsrsr XIFLG\"，则采用的密匙k是____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fab",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "  18\/5",
    "optionC" : "  16\/5",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "  12\/5",
    "type" : "1",
    "optionA" : "2",
    "knowledge" : "概率统计",
    "question" : "有1,2,3,......无穷个格子，你从1号格子出发，每次1\/2概率向前跳一格，1\/2概率向前跳两格，走到格子编号为4的倍数时结束，结束时期望走的步数为____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fac",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "33",
    "optionC" : "30",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "27",
    "type" : "1",
    "optionA" : "25",
    "knowledge" : "智力题",
    "question" : "从1,2,3,......,49,50里选择一个集合S，使得若x属于S，则2x不属于S，则S最多能有____个元素。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fad",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "任何一个进程删除该文件时，另外一个进程会立即出现读写失败",
    "optionC" : "进程可以通过系统调用对文件加锁，从而实现对文件内容的保护",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "两个进程可以任意对文件进行读写操作，操作系统并不保证写的原子性",
    "type" : "1",
    "optionA" : "两个进程中分别产生生成两个独立的fd",
    "knowledge" : "Linux",
    "question" : "Linux下两个进程可以同时打开同一个文件，这时如下描述错误的是："
  },
  {
    "ID" : "55fa696ee4b043d0caf26fae",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "无数次",
    "optionC" : "4",
    "optionAnswer" : "D",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "2",
    "type" : "1",
    "optionA" : "1",
    "knowledge" : "查找",
    "question" : "考虑以下二分查找的代码：\n\n#include <stdio.h>\nint bsearch(int array[], int n, int v)\n{\n    int left, right, middle;\n    left = 0, right = n - 1;\n    while (left <= right) {\n        middle = left + (right - left) \/ 2;\n        if (array[middle] > v ) {\n            right = middle;\n        } else if (array[middle] < v) {\n            left = middle;\n        } else {\n            return middle;\n        }\n  } \n    return -1;\n}\n对于输入array为：{2, 6, 8, 10, 13, 25, 36, 45, 53, 76, 88, 100, 127}， n = 13, v = 127时,\n运行bsearch函数，while循环调用的次数为____。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26faf",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "15",
    "optionC" : "14",
    "optionAnswer" : "B",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "13",
    "type" : "1",
    "optionA" : "12",
    "knowledge" : "树",
    "question" : "设一棵二叉树有 3 个叶子节点，有 8 个度为 1 的节点，则该二叉树中总的节点数为______。"
  },
  {
    "ID" : "55fa696ee4b043d0caf26fb0",
    "typeID" : "55dd5e2360b258078b9e4458",
    "optionD" : "700",
    "optionC" : "600",
    "optionAnswer" : "A",
    "answer" : "解析正在重新整理中……请不要离开和卸载，其实陪伴是最长情的告白。",
    "optionB" : "500",
    "type" : "1",
    "optionA" : "400",
    "knowledge" : "排序",
    "question" : "一台机器对200个单词进行排序花了200秒(使用冒泡排序)，那么花费800秒，大概可以对多少个单词进行排序"
  }
]}